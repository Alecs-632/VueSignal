import{r as Ut,I as li}from"./vendor-BohjmEtK.js";var Er=Object.defineProperty,zr=(o,t,e)=>t in o?Er(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,l=(o,t,e)=>(zr(o,typeof t!="symbol"?t+"":t,e),e),sr=(o=>(o[o.Sunday=0]="Sunday",o[o.Monday=1]="Monday",o[o.Tuesday=2]="Tuesday",o[o.Wednesday=3]="Wednesday",o[o.Thursday=4]="Thursday",o[o.Friday=5]="Friday",o[o.Saturday=6]="Saturday",o))(sr||{}),tt=(o=>(o[o.Automatic=0]="Automatic",o[o.Adaptive=1]="Adaptive",o[o.PreferSharpness=2]="PreferSharpness",o[o.PreferSpeed=3]="PreferSpeed",o[o.PreferGeometricAccuracy=4]="PreferGeometricAccuracy",o))(tt||{}),N=(o=>(o[o.Left=-1]="Left",o[o.Center=0]="Center",o[o.Right=1]="Right",o))(N||{}),E=(o=>(o[o.Top=-1]="Top",o[o.Middle=0]="Middle",o[o.Bottom=1]="Bottom",o))(E||{}),X=(o=>(o[o.Miter=0]="Miter",o[o.Round=1]="Round",o[o.Bevel=2]="Bevel",o))(X||{}),_=(o=>(o[o.Solid=0]="Solid",o[o.Dash=1]="Dash",o[o.Dot=2]="Dot",o[o.DashDot=3]="DashDot",o[o.DashDashDot=4]="DashDashDot",o[o.DashDotDot=5]="DashDotDot",o[o.DashDashDotDot=6]="DashDashDotDot",o[o.LongDash=7]="LongDash",o[o.LongDashDot=8]="LongDashDot",o[o.LongDashDotDot=9]="LongDashDotDot",o[o.None=10]="None",o[o.Automatic=11]="Automatic",o))(_||{}),ct=(o=>(o[o.None=0]="None",o[o.Circle=1]="Circle",o[o.Square=2]="Square",o[o.Diamond=3]="Diamond",o[o.Triangle=4]="Triangle",o[o.Cross=5]="Cross",o[o.Plus=6]="Plus",o[o.Star=7]="Star",o[o.Custom=8]="Custom",o))(ct||{});const $e={Bold:700,Normal:400};var Ce=(o=>(o[o.Zoom=0]="Zoom",o[o.Pan=1]="Pan",o[o.Reset=2]="Reset",o))(Ce||{}),Ve=(o=>(o[o.BelowSeries=0]="BelowSeries",o[o.AboveSeries=1]="AboveSeries",o))(Ve||{}),v=(o=>(o[o.None=0]="None",o[o.Left=1]="Left",o[o.Right=2]="Right",o[o.Top=3]="Top",o[o.Bottom=4]="Bottom",o[o.All=5]="All",o))(v||{}),z=(o=>(o[o.Auto=0]="Auto",o[o.Manual=1]="Manual",o[o.Milliseconds=2]="Milliseconds",o[o.Seconds=3]="Seconds",o[o.Minutes=4]="Minutes",o[o.Hours=5]="Hours",o[o.Days=6]="Days",o[o.Weeks=7]="Weeks",o[o.Months=8]="Months",o[o.Years=9]="Years",o))(z||{}),Yt=(o=>(o[o.Crossing=0]="Crossing",o[o.Inside=1]="Inside",o[o.Outside=2]="Outside",o[o.None=3]="None",o))(Yt||{}),be=(o=>(o[o.Default=0]="Default",o[o.Pan=1]="Pan",o[o.ZoomRectangle=2]="ZoomRectangle",o[o.ZoomHorizontal=3]="ZoomHorizontal",o[o.ZoomVertical=4]="ZoomVertical",o))(be||{}),Ee=(o=>(o[o.All=0]="All",o[o.Single=1]="Single",o[o.Multiple=2]="Multiple",o))(Ee||{}),Bt=(o=>(o[o.Outside=0]="Outside",o[o.Inside=1]="Inside",o[o.Middle=2]="Middle",o[o.Base=3]="Base",o))(Bt||{});const vs=Object.freeze({x:NaN,y:NaN}),is=Object.freeze({x:0,y:0});function ss(o){return isNaN(o.x)&&isNaN(o.y)}function Or(o){return!ss(o)}function $(o,t){return{x:o,y:t}}function $r(o){return o&&typeof o.x=="number"&&typeof o.y=="number"}function Yr(o,t){return new Xr(o.x-t.x,o.y-t.y)}function Ns(o,t){return $(o.x-t.x,o.y-t.y)}function di(o,t){return $(o.x+t.x,o.y+t.y)}const rs=class je{constructor(t,e){l(this,"_x"),l(this,"_y"),this._x=t,this._y=e}get length(){return Math.sqrt(this._x*this._x+this._y*this._y)}get lengthSquared(){return this._x*this._x+this._y*this._y}get x(){return this._x}get y(){return this._y}times(t){const e=this;return new je(e._x*t,e._y*t)}plus(t){const e=this;return new je(e._x+t._x,e._y+t._y)}minus(t){const e=this;return new je(e._x-t._x,e._y-t._y)}negate(){const t=this;return new je(-t._x,-t._y)}equals(t){return this._x===t._x&&this._y===t._y}toString(){return`${this._x} ${this._y}`}isDefined(){return this._x===this._x&&this._y===this._y}};l(rs,"Undefined",new rs(NaN,NaN));let Xr=rs;const Ci=Object.freeze({x:NaN,y:NaN}),te=Object.freeze({x:0,y:0});function y(o,t){return{x:o,y:t}}function It(o,t){return y(o.x+t.x,o.y+t.y)}function rr(o,t){return ot(o.x-t.x,o.y-t.y)}function Jt(o,t){return wt.fromVector(rr(o,t))}function _e(o,t){return y(o.x-t.x,o.y-t.y)}function Cs(o,t){const e=t.x-o.x,i=t.y-o.y;return Math.sqrt(e*e+i*i)}function Ye(o,t){const e=t.x-o.x,i=t.y-o.y;return e*e+i*i}function bi(o){return isNaN(o.x)&&isNaN(o.y)}function $i(o,t){return o.x===t.x&&o.y===t.y}function ot(o,t){return Object.freeze({x:o,y:t})}function os(o,t){return wt.fromXY(o,t)}const Wr=Object.freeze(ot(0,0));class wt{constructor(t){l(this,"_v"),this._v=t}get x(){return this._v.x}get y(){return this._v.y}get vector(){return this._v}get length(){return Me.length(this._v)}get lengthSquared(){return Me.lengthSquared(this._v)}minus(t){return wt.fromVector(Me.minus(this._v,t))}times(t){return wt.fromVector(Me.times(this._v,t))}negate(){return wt.fromVector(Me.negate(this._v))}normalize(){return this._v=Me.normalize(this._v),this}static fromVector(t){return new wt(t)}static fromXY(t,e){return new wt(ot(t,e))}}class Me{static length(t){return Math.sqrt(t.x*t.x+t.y*t.y)}static lengthSquared(t){return t.x*t.x+t.y*t.y}static normalize(t){if(t===Wr)throw new Error("Cannot normalize the zero vector");const e=Math.sqrt(t.x*t.x+t.y*t.y);return e>0?{x:t.x/e,y:t.y/e}:t}static plus(t,e){return ot(t.x+e.x,t.y+e.y)}static minus(t,e){return ot(t.x-e.x,t.y-e.y)}static times(t,e){return ot(t.x*e,t.y*e)}static negate(t){return ot(-t.x,-t.y)}static equals(t,e){return t.x===e.x&&t.y===e.y}}function Ur(o,t){return Hr(o,e=>e[t])}function Hr(o,t){return o.reduce((e,i)=>{const r=t(i);let n=e.get(r);return n?n.push(i):(n=[i],e.set(r,n)),e},new Map)}function jr(o,t,e=0){for(let i=e;i<o.length;i++)if(t.includes(o[i]))return i;return-1}function re(o,t,e){const i=Array(o);for(let r=0;r<o;r++)i[r]=new Array(t),e!==void 0&&i[r].fill(e);return i}function hi(o,t){const e=o.indexOf(t);return e>-1?(o.splice(e,1),!0):!1}function Bs(o,t){let e=0;for(let i=o.length-1;i>=0;i--)t(o[i])&&(o.splice(i,1),e++);return e}function Xe(o,t){for(let e=0;e<t.length;e++)o.push(t[e])}function Ge(o){if(!o||o.length===0)return[];const t=[];return Xe(t,o),t.reverse()}function Mt(o,...t){let e=0;return o.length>=1e5?e=o.reduce(function(i,r){return Math.max(i,r)}):e=Math.max.apply(null,o),!t||t.length===0?e:Math.max(e,...t)}function mt(o,...t){let e=0;return o.length>=1e5?e=o.reduce(function(i,r){return Math.min(i,r)}):e=Math.min.apply(null,o),!t||t.length===0?e:Math.min(e,...t)}function Bn(o){const t=Array.from(o,e=>String.fromCharCode(e));return btoa(t.join(""))}const Gr=new Date(9999,11,31,23,59,59,999),he=new Date(1,0,1,0,0,0,0);he.setUTCFullYear(1);he.setUTCMonth(0);he.setUTCDate(1);he.setUTCHours(0);he.setUTCMinutes(0);he.setUTCSeconds(0);he.setUTCMilliseconds(0);var or=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function nr(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}var ar={exports:{}};(function(o,t){(function(e,i){o.exports=i()})(or,function(){var e="minute",i=/[+-]\d\d(?::?\d\d)?/g,r=/([+-]|\d\d)/g;return function(n,a,h){var m=a.prototype;h.utc=function(x){var R={date:x,utc:!0,args:arguments};return new a(R)},m.utc=function(x){var R=h(this.toDate(),{locale:this.$L,utc:!0});return x?R.add(this.utcOffset(),e):R},m.local=function(){return h(this.toDate(),{locale:this.$L,utc:!1})};var u=m.parse;m.parse=function(x){x.utc&&(this.$u=!0),this.$utils().u(x.$offset)||(this.$offset=x.$offset),u.call(this,x)};var c=m.init;m.init=function(){if(this.$u){var x=this.$d;this.$y=x.getUTCFullYear(),this.$M=x.getUTCMonth(),this.$D=x.getUTCDate(),this.$W=x.getUTCDay(),this.$H=x.getUTCHours(),this.$m=x.getUTCMinutes(),this.$s=x.getUTCSeconds(),this.$ms=x.getUTCMilliseconds()}else c.call(this)};var g=m.utcOffset;m.utcOffset=function(x,R){var M=this.$utils().u;if(M(x))return this.$u?0:M(this.$offset)?g.call(this):this.$offset;if(typeof x=="string"&&(x=function(P){P===void 0&&(P="");var C=P.match(i);if(!C)return null;var D=(""+C[0]).match(r)||["-",0,0],k=D[0],L=60*+D[1]+ +D[2];return L===0?0:k==="+"?L:-L}(x),x===null))return this;var S=Math.abs(x)<=16?60*x:x,T=this;if(R)return T.$offset=S,T.$u=x===0,T;if(x!==0){var A=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(T=this.local().add(S+A,e)).$offset=S,T.$x.$localOffset=A}else T=this.utc();return T};var f=m.format;m.format=function(x){var R=x||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return f.call(this,R)},m.valueOf=function(){var x=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*x},m.isUTC=function(){return!!this.$u},m.toISOString=function(){return this.toDate().toISOString()},m.toString=function(){return this.toDate().toUTCString()};var d=m.toDate;m.toDate=function(x){return x==="s"&&this.$offset?h(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():d.call(this)};var b=m.diff;m.diff=function(x,R,M){if(x&&this.$u===x.$u)return b.call(this,x,R,M);var S=this.local(),T=h(x).local();return b.call(S,T,R,M)}}})})(ar);var Kr=ar.exports;const Zr=nr(Kr);var lr={exports:{}};(function(o,t){(function(e,i){o.exports=i()})(or,function(){var e={year:0,month:1,day:2,hour:3,minute:4,second:5},i={};return function(r,n,a){var h,m=function(f,d,b){b===void 0&&(b={});var x=new Date(f),R=function(M,S){S===void 0&&(S={});var T=S.timeZoneName||"short",A=M+"|"+T,P=i[A];return P||(P=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:M,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",timeZoneName:T}),i[A]=P),P}(d,b);return R.formatToParts(x)},u=function(f,d){for(var b=m(f,d),x=[],R=0;R<b.length;R+=1){var M=b[R],S=M.type,T=M.value,A=e[S];A>=0&&(x[A]=parseInt(T,10))}var P=x[3],C=P===24?0:P,D=x[0]+"-"+x[1]+"-"+x[2]+" "+C+":"+x[4]+":"+x[5]+":000",k=+f;return(a.utc(D).valueOf()-(k-=k%1e3))/6e4},c=n.prototype;c.tz=function(f,d){f===void 0&&(f=h);var b=this.utcOffset(),x=this.toDate(),R=x.toLocaleString("en-US",{timeZone:f}),M=Math.round((x-new Date(R))/1e3/60),S=a(R,{locale:this.$L}).$set("millisecond",this.$ms).utcOffset(15*-Math.round(x.getTimezoneOffset()/15)-M,!0);if(d){var T=S.utcOffset();S=S.add(b-T,"minute")}return S.$x.$timezone=f,S},c.offsetName=function(f){var d=this.$x.$timezone||a.tz.guess(),b=m(this.valueOf(),d,{timeZoneName:f}).find(function(x){return x.type.toLowerCase()==="timezonename"});return b&&b.value};var g=c.startOf;c.startOf=function(f,d){if(!this.$x||!this.$x.$timezone)return g.call(this,f,d);var b=a(this.format("YYYY-MM-DD HH:mm:ss:SSS"),{locale:this.$L});return g.call(b,f,d).tz(this.$x.$timezone,!0)},a.tz=function(f,d,b){var x=b&&d,R=b||d||h,M=u(+a(),R);if(typeof f!="string")return a(f).tz(R);var S=function(C,D,k){var L=C-60*D*1e3,et=u(L,k);if(D===et)return[L,D];var ht=u(L-=60*(et-D)*1e3,k);return et===ht?[L,et]:[C-60*Math.min(et,ht)*1e3,Math.max(et,ht)]}(a.utc(f,x).valueOf(),M,R),T=S[0],A=S[1],P=a(T).utcOffset(A);return P.$x.$timezone=R,P},a.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},a.tz.setDefault=function(f){h=f}}})})(lr);var Jr=lr.exports;const qr=nr(Jr);function Yi(){return Qr}Ut.extend(Zr);Ut.extend(qr);const Qr={format:(o,t)=>Ut(o).format(t),convertTime:(o,t)=>Ut(o).tz(t).toDate(),addYears:(o,t)=>Ut(o).add(t,"year").toDate(),addMonths:(o,t)=>Ut(o).add(t,"month").toDate(),addTimespan:(o,t)=>{let e=Ut(o);return t.days&&(e=e.add(t.days,"day")),t.hours&&(e=e.add(t.hours,"hour")),t.minutes&&(e=e.add(t.minutes,"minute")),t.seconds&&(e=e.add(t.seconds,"second")),t.milliseconds&&(e=e.add(t.milliseconds,"millisecond")),e.toDate()},dayOfWeek:o=>Ut(o).day(),diff:(o,t)=>{const e=Ut(o).diff(Ut(t));return Ft.fromMilliseconds(e)}};let Xi=null;function to(){return Xi||(Xi=new eo,Xi)}class eo{async decode(t){const e=await li.load(t),i=e.height,r=e.width,n=e.data,a=re(r,i);for(let h=0;h<i;h++)for(let m=0;m<r;m++){let u=h*r+m;const c=n[u++],g=n[u++],f=n[u++],d=n[u++];a[h][m]=F.fromArgb(d,c,g,f)}return a}encode(t){const e=new DataView(new ArrayBuffer(t.imageInfo.width*t.imageInfo.height*4));let i=0;const r=t.pixels;for(let a=0;a<t.imageInfo.height;a++)for(let h=0;h<t.imageInfo.width;h++){const m=s.fromOxyColor(r.get(h,a));e.setUint8(i++,m.r),e.setUint8(i++,m.g),e.setUint8(i++,m.b),e.setUint8(i++,m.a)}const n=new li(t.imageInfo.width,t.imageInfo.height,new Uint8Array(e.buffer)).toBuffer();return Promise.resolve(n)}async getImageInfo(t){const e=await li.load(t);return{width:e.width,height:e.height,bitsPerPixel:e.bitDepth,dpiX:0,dpiY:0,format:Ei.getImageFormat(t)}}async load(t){const e=(await li.load(t)).toBuffer();return{...await this.getImageInfo(e),data:Array.from(e)}}}function io(o){if(o){if(o.includes("=>"))return new Function("return "+o)();if(o.includes("function"))return new Function("return "+o)()}}function ne(o){return o===void 0}function J(o){return o==null}function Es(o,...t){if(o)for(const e of t)delete o[e]}function lt(o,t,e){if(!o||!t)return e;const i=o[t];return J(i)?e:i}function ae(o,t){if(ne(o))return o;const e=o;if(Array.isArray(e))return e.forEach(r=>ae(r,t)),o;const i=Object.assign({removeNull:!1,removeEmptyStr:!1,deep:1},t);return Object.keys(e).forEach(r=>{const n=e[r];if(n===void 0){delete e[r];return}if(n===null&&i.removeNull){delete e[r];return}if(i.removeEmptyStr&&typeof n=="string"&&n.length==0){delete e[r];return}if(typeof n=="object"&&i.deep>1){const a=Object.assign({},i,{deep:i.deep-1});ae(n,a);return}}),o}function hr(o){let t=0;for(let e=0;e<o.length;e++)t=Math.imul(31,t)+o[e];return t}function so(o,t,e){const i={},r=o;function n(a,h){return e?t&&e.excludeDefault===!0&&as(h,t[a])?!1:e.filter?e.filter(a,h):!0:!0}return Object.keys(r).forEach(a=>{const h=r[a];if(h!==void 0&&n(a,h)){if(typeof h=="function"){if(!a.includes("Formatter"))return;i[a]=String(h);return}i[a]=h}}),i}function mr(o,t,e){return so(o,t,{filter:(i,r)=>{var n;if(e!=null&&e.filter){const a=e.filter(i,r);if(a!==void 0)return a}return i.startsWith("__")&&i.endsWith("__")?!0:!(i.startsWith("_")||i.startsWith("actual")||(n=e==null?void 0:e.excludeKeys)!=null&&n.includes(i))},excludeDefault:(e==null?void 0:e.excludeDefault)??!0})}const ro=o=>Object.prototype.toString.call(o);function ns(o){if(o===null)return"null";const t=ro(o).slice(8,-1).toLowerCase();return typeof o=="object"||typeof o=="function"?t:typeof o}function as(o,t){if(o===t)return!0;const e=ns(o),i=ns(t);if(e!==i)return!1;if(e==="array")return o.length!==t.length?!1:o.every((r,n)=>as(r,t[n]));if(e==="object"){const r=Object.keys(o);return r.length!==Object.keys(t).length?!1:r.every(n=>as(o[n],t[n]))}return Object.is(o,t)}function q(o,t,e,i){var r;const n=(Array.isArray(e)?e:[e]).filter(h=>h);n.unshift(t),n.reverse();const a=Object.keys(t);for(const h of a){if((r=i==null?void 0:i.exclude)!=null&&r.includes(h))continue;const m=Object.getOwnPropertyDescriptor(o,h);if(!(m===void 0||!m.writable))for(const u of n){const c=u[h];if(c!==void 0){if(u!==t)o[h]=c;else{const g=ns(c);g==="array"||g==="object"?o[h]=oo(c):o[h]=c}break}}}return o}function it(o,t,e,i=!1){if(!o||!t||!e)return;const r=o,n=e[t];if(n){if(typeof n=="function"){r[t]=n,i&&delete e[t];return}if(typeof n=="string"){r[t]=io(n),i&&delete e[t];return}throw new Error(`Invalid method type: ${n}`)}}function oo(o){return Array.isArray(o)?Array.from(o):Object.assign({},o)}const W=-17976931348623157e292,B=Number.MAX_VALUE;function Et(o,t){if(isNaN(o)||!isFinite(o))return NaN;const e=Math.pow(10,t);return Math.round((o+Number.EPSILON)*e)/e}function xe(o){return!isFinite(o)}function zs(o){return o===Number.NEGATIVE_INFINITY}function Os(o){return o===Number.POSITIVE_INFINITY}function fe(o){return o>=0?o:o>>>0}function no(o,t){let e;if(o>=1e6||o<=-1e6?e=o.toExponential(t):e=o.toString(),e.includes("e")){const i=Number(e.split("e")[0]);return Et(i,t).toString()+"e"+e.split("e")[1]}return Et(o,t).toString()}function ao(o,t=1){return J(o)?"":isNaN(o)?"NaN":Et(o*100,t)+"%"}function j(o){return isNaN(o)||J(o)}function lo(o,t){return o&&o.replace(new RegExp(`^${t}+|${t}+$`,"g"),"")}function mi(o,t,e){return e===void 0?o.substring(t):o.substring(t,t+e)}const Re=1e3,ye=6e4,Se=36e5,we=864e5;class Ft{constructor(t){l(this,"_totalMs",0),l(this,"_ms",0),l(this,"_seconds",0),l(this,"_minutes",0),l(this,"_hours",0),l(this,"_days",0),l(this,"toString",()=>`${this._days}day ${this._hours}hour ${this._minutes}minute ${this._seconds}second ${this._ms}ms`),this.ms=t,this._totalMs=t;const e=t<0?-1:1;let i=Math.abs(t);i>=we&&(this._days=e*Math.floor(i/we),i=i%we),i>=Se&&(this._hours=e*Math.floor(i/Se),i=i%Se),i>=ye&&(this._minutes=e*Math.floor(i/ye),i=i%ye),i>=Re&&(this._seconds=e*Math.floor(i/Re),i=i%Re),this._ms=e*i}get milliseconds(){return this._ms}get seconds(){return this._seconds}get minutes(){return this._minutes}get hours(){return this._hours}get days(){return this._days}get totalMs(){return this._totalMs}get totalSeconds(){return this._totalMs/Re}get totalMinutes(){return this._totalMs/ye}get totalHours(){return this._totalMs/Se}get totalDays(){return this._totalMs/we}static fromMilliseconds(t){return new Ft(t)}static fromSeconds(t){return new Ft(t*Re)}static fromMinutes(t){return new Ft(t*ye)}static fromHours(t){return new Ft(t*Se)}static fromDays(t){return new Ft(t*we)}static from(t=0,e=0,i=0,r=0,n=0){return new Ft(t*we+e*Se+i*ye+r*Re+n)}}class Pi{constructor(t,e,i){l(this,"_data"),this.columnCount=t,this.rowCount=e,this._data=re(e,t,i)}static fromArray(t){const e=t.length,i=t[0].length,r=new Pi(i,e);for(let n=0;n<e;n++)for(let a=0;a<i;a++)r.set(a,n,t[n][a]);return r}toArray(){const t=re(this.rowCount,this.columnCount);for(let e=0;e<this.rowCount;e++)for(let i=0;i<this.columnCount;i++)t[e][i]=this.get(i,e);return t}get height(){return this.rowCount}get width(){return this.columnCount}get(t,e){return this._data[e][t]}set(t,e,i){this._data[e][t]=i}}class oe{constructor(t){l(this,"_rect"),this._rect=t}get rect(){return this._rect}get left(){return this._rect.left}get top(){return this._rect.top}get topLeft(){return w.topLeft(this._rect)}get topRight(){return w.topRight(this._rect)}get right(){return w.right(this._rect)}get bottom(){return w.bottom(this._rect)}get bottomLeft(){return w.bottomLeft(this._rect)}get bottomRight(){return w.bottomRight(this._rect)}get height(){return this._rect.height}get width(){return this._rect.width}get center(){return w.center(this._rect)}offset(t,e){const i=w.offset(this._rect,t,e);return oe.fromRect(i)}clip(t){const e=w.clip(this._rect,t);return oe.fromRect(e)}deflate(t){const e=w.deflate(this._rect,t);return oe.fromRect(e)}static fromRect(t){return new oe(t)}static fromScreenPoints(t,e){return new oe(w.fromScreenPoints(t,e))}}function Y(o,t,e,i){if(e<0)throw new Error("width;The width should not be negative.");if(i<0)throw new Error("height;The height should not be negative.");return Object.freeze({left:o,top:t,width:e,height:i})}const Pe=Object.freeze(Y(0,0,1/0,1/0)),Le=Object.freeze(Y(0,0,0,0));class w{static fromScreenPoints(t,e){return Y(Math.min(t.x,e.x),Math.min(t.y,e.y),Math.abs(e.x-t.x),Math.abs(e.y-t.y))}static fromScreenPointAndSize(t,e){return Y(t.x,t.y,e.width,e.height)}static bottom(t){return t.top+t.height}static right(t){return t.left+t.width}static center(t){return y(t.left+t.width*.5,t.top+t.height*.5)}static topLeft(t){return y(t.left,t.top)}static topRight(t){return y(this.right(t),t.top)}static bottomLeft(t){return y(t.left,this.bottom(t))}static bottomRight(t){return y(this.right(t),this.bottom(t))}static create(t,e,i,r){return Y(Math.min(t,i),Math.min(e,r),Math.abs(i-t),Math.abs(r-e))}static contains(t,e,i){return e>=t.left&&e<=this.right(t)&&i>=t.top&&i<=this.bottom(t)}static containsPoint(t,e){return this.contains(t,e.x,e.y)}static equals(t,e){return t.left===e.left&&t.top===e.top&&t.width===e.width&&t.height===e.height}static inflate(t,e,i){return Y(t.left-e,t.top-i,t.width+e*2,t.height+i*2)}static inflateAll(t,e){return Y(t.left-e.left,t.top-e.top,t.width+e.left+e.right,t.height+e.top+e.bottom)}static intersect(t,e){const i=Math.max(t.left,e.left),r=Math.max(t.top,e.top),n=Math.min(this.right(t),this.right(e)),a=Math.min(this.bottom(t),this.bottom(e));return n<i||a<r?Le:Y(i,r,n-i,a-r)}static deflate(t,e){return Y(t.left+e.left,t.top+e.top,Math.max(0,t.width-e.left-e.right),Math.max(0,t.height-e.top-e.bottom))}static offset(t,e,i){return Y(t.left+e,t.top+i,t.width,t.height)}static clip(t,e){const i=zs(e.left)&&Os(e.width)?this.right(e):1/0,r=zs(e.top)&&Os(e.height)?this.bottom(e):1/0;return this.create(Math.max(Math.min(t.left,i),e.left),Math.max(Math.min(t.top,r),e.top),Math.max(Math.min(this.right(t),i),e.left),Math.max(Math.min(this.bottom(t),r),e.top))}}function at(o,t){return Object.freeze({height:t||0,width:o||0})}const Wi=Object.freeze(at());class Ni{constructor(t){l(this,"_size"),this._size=t}get height(){return this._size.height}get width(){return this._size.width}static from(t){return new Ni(t)}static equals(t,e){return t.width===e.width&&t.height===e.height}static include(t,e){return at(Math.max(t.width,e.width),Math.max(t.height,e.height))}static getBounds(t,e,i,r){const n=i===N.Left?0:i===N.Center?.5:1,a=r===E.Top?0:r===E.Middle?.5:1,h=ot(n*t.width,a*t.height);if(e===0)return Y(-h.x,-h.y,t.width,t.height);const m=wt.fromXY(0,0).minus(h).vector,u=wt.fromXY(t.width,0).minus(h).vector,c=wt.fromXY(t.width,t.height).minus(h).vector,g=wt.fromXY(0,t.height).minus(h).vector,f=e*Math.PI/180,d=Math.cos(f),b=Math.sin(f),x=k=>ot(d*k.x-b*k.y,b*k.x+d*k.y),R=x(m),M=x(u),S=x(c),T=x(g),A=Math.min(Math.min(R.x,M.x),Math.min(S.x,T.x)),P=Math.min(Math.min(R.y,M.y),Math.min(S.y,T.y)),C=Math.max(Math.max(R.x-A,M.x-A),Math.max(S.x-A,T.x-A)),D=Math.max(Math.max(R.y-P,M.y-P),Math.max(S.y-P,T.y-P));return Y(A,P,C,D)}static getPolygon(t,e,i,r,n){const a=r===N.Left?0:r===N.Center?.5:1,h=n===E.Top?0:n===E.Middle?.5:1,m=ot(a*t.width,h*t.height);let u=wt.fromXY(0,0).minus(m).vector,c=wt.fromXY(t.width,0).minus(m).vector,g=wt.fromXY(t.width,t.height).minus(m).vector,f=wt.fromXY(0,t.height).minus(m).vector;if(i!==0){const d=i*Math.PI/180,b=Math.cos(d),x=Math.sin(d),R=M=>ot(b*M.x-x*M.y,x*M.x+b*M.y);u=R(u),c=R(c),g=R(g),f=R(f)}return[It(e,u),It(e,c),It(e,g),It(e,f)]}}function Dt(o,t,e,i){if(!J(o)&&J(t)&&J(e)&&J(i))return Object.freeze({left:o,top:o,right:o,bottom:o});if(!J(t)&&!J(e)&&!J(i))return Object.freeze({left:o,top:t,right:e,bottom:i});debugger;throw new Error("Invalid arguments")}const Fi=Object.freeze(Dt(0));class Di{constructor(t){l(this,"_thickness"),this._thickness=t}static from(t){return new Di(t)}get bottom(){return this._thickness.bottom}get left(){return this._thickness.left}get right(){return this._thickness.right}get top(){return this._thickness.top}static equals(t,e){return t.left===e.left&&t.top===e.top&&t.right===e.right&&t.bottom===e.bottom}static include(t,e){return Dt(Math.max(e.left,t.left),Math.max(e.top,t.top),Math.max(e.right,t.right),Math.max(e.bottom,t.bottom))}}var ce=(o=>(o[o.Data=0]="Data",o[o.ScreenUnits=1]="ScreenUnits",o[o.RelativeToViewport=2]="RelativeToViewport",o[o.RelativeToPlotArea=3]="RelativeToPlotArea",o))(ce||{});function ke(o,t){return{value:o,unit:t}}const Ii="#00000000",ls="#00000001";class s{constructor(t,e,i,r){l(this,"a"),l(this,"b"),l(this,"g"),l(this,"r"),l(this,"hex"),this.a=t,this.r=e,this.g=i,this.b=r,this.hex=F.toHexString(e,i,r,t)}static fromArgb(t,e,i,r){return new s(t,e,i,r)}static fromHex(t){t||(t=Ii);const{a:e,r:i,g:r,b:n}=F.parseHex(t);return new s(e,i,r,n)}static fromOxyColor(t){if(t instanceof s)return t;if(ho(t))return s.fromHex(t);const e=mo(t);if(e)return s.fromHex(e);throw new Error("Invalid color:"+t)}static fromRgb(t,e,i){return this.fromArgb(255,t,e,i)}static fromHsv(t,e,i){return this.fromOxyColor(F.fromHsv(t,e,i))}static fromAColor(t,e){return this.fromOxyColor(F.fromAColor(t,e))}}class F{static isOxyColor(t){return!(!t||typeof t!="string")}static getOxyColor(t){return typeof t=="string"?t:s.fromOxyColor(t).hex}static parse(t){if(!t||t.toLowerCase()==="none")return Ii;if(t.toLowerCase()==="auto")return ls;const{a:e,r:i,g:r,b:n}=this.parseHex(t);return this.fromArgb(e,i,r,n)}static parseHex(t){if(t=t.trim(),t.startsWith("#")){t=lo(t,"#"),t.length===3&&(t=`${t[0]}${t[0]}${t[1]}${t[1]}${t[2]}${t[2]}`);let m=parseInt(t,16);return t.length<8&&(m+=4278190080),this.uint32ToArgb(m)}const e=t.split(",");if(e.length<3||e.length>4)throw new Error("Invalid color:"+t);let i=0,r=255;e.length>3&&(r=parseInt(e[i],10),i++);const n=parseInt(e[i],10),a=parseInt(e[i+1],10),h=parseInt(e[i+2],10);return{a:r,r:n,g:a,b:h}}static colorDifference(t,e){const i=(t.r-e.r)/255,r=(t.g-e.g)/255,n=(t.b-e.b)/255,a=(t.a-e.a)/255,h=i*i+r*r+n*n+a*a;return Math.sqrt(h)}static fromUInt32(t){const{a:e,r:i,g:r,b:n}=this.uint32ToArgb(t);return this.fromArgb(e,i,r,n)}static uint32ToArgb(t){const e=t>>24&255,i=t>>16&255,r=t>>8&255,n=t&255;return{a:e,r:i,g:r,b:n}}static fromHsv(t,e,i){let r,n,a=r=n=0;if(e===0)a=r=n=i;else{t===1&&(t=0),t*=6;const h=Math.floor(t),m=t-h,u=i*(1-e),c=i*(1-e*m),g=i*(1-e*(1-m));switch(h){case 0:a=i,r=g,n=u;break;case 1:a=c,r=i,n=u;break;case 2:a=u,r=i,n=g;break;case 3:a=u,r=c,n=i;break;case 4:a=g,r=u,n=i;break;case 5:a=i,r=u,n=c;break}}return this.fromRgb(Math.round(a*255),Math.round(r*255),Math.round(n*255))}static fromAColor(t,e){const i=s.fromOxyColor(e);return this.fromArgb(t,i.r,i.g,i.b)}static fromArgb(t,e,i,r){return this.toHexString(e,i,r,t)}static fromRgb(t,e,i){return this.fromArgb(255,t,e,i)}static interpolate(t,e,i){const r=s.fromOxyColor(t),n=s.fromOxyColor(e),a=r.a*(1-i)+n.a*i,h=r.r*(1-i)+n.r*i,m=r.g*(1-i)+n.g*i,u=r.b*(1-i)+n.b*i;return s.fromArgb(ui(a),ui(h),ui(m),ui(u))}static equals(t,e){if(typeof t=="string"&&typeof e=="string")return t===e;const i=s.fromOxyColor(t),r=s.fromOxyColor(e);return i.a===r.a&&i.r===r.r&&i.g===r.g&&i.b===r.b}static toArgb(t){const{r:e,g:i,b:r,a:n}=this.toArgbInner(t);return`#${n}${e}${i}${r}`}static toRgba(t){const{r:e,g:i,b:r,a:n}=this.toArgbInner(t);return`#${e}${i}${r}${n}`}static toRgb(t){const{r:e,g:i,b:r}=this.toArgbInner(t);return`#${e}${i}${r}$`}static toHexString(t,e,i,r){const n=He,[a,h,m]=[n(t),n(e),n(i)],u=`${a}${h}${m}`;return J(r)||r===255?a[0]===a[1]&&h[0]===h[1]&&m[0]===m[1]?`#${a[0]}${h[0]}${m[0]}`:`#${u}`:`#${n(r)}${u}`}static toArgbInner(t){const{r:e,g:i,b:r,a:n}=s.fromOxyColor(t);return{a:He(n),r:He(e),g:He(i),b:He(r)}}static isInvisible(t){return t?s.fromOxyColor(t).a===0:!0}static isVisible(t){return t?s.fromOxyColor(t).a>0:!1}static isUndefined(t){return this.equals(t,Ii)}static isAutomatic(t){return this.equals(t,ls)}static getActualColor(t,e){return this.isAutomatic(t)?this.getOxyColor(e):this.getOxyColor(t)}static changeIntensity(t,e){const i=this.toHsv(t);return i[2]*=e,i[2]>1&&(i[2]=1),s.fromHsv(i[0],i[1],i[2])}static changeSaturation(t,e){const i=this.toHsv(t);return i[1]*=e,i[1]>1&&(i[1]=1),s.fromHsv(i[0],i[1],i[2])}static changeOpacity(t,e){const{a:i}=s.fromOxyColor(t);return s.fromAColor(Math.round(i*e),t)}static complementary(t){const e=this.toHsv(t);let i=e[0]-.5;return i<0&&(i+=1),s.fromHsv(i,e[1],e[2])}static toHsv(t){const{r:e,g:i,b:r}=s.fromOxyColor(t),n=Math.min(Math.min(e,i),r),a=Math.max(Math.max(e,i),r),h=a-n,m=a===0?0:h/a;let u=0;m===0?u=0:(e===a?u=(i-r)/h:i===a?u=2+(r-e)/h:r===a&&(u=4+(e-i)/h),u*=60,u<0&&(u+=360));const c=new Array(3);return c[0]=u/360,c[1]=m,c[2]=a/255,c}static toUint(t){const{r:e,g:i,b:r,a:n}=s.fromOxyColor(t);let a=fe(n<<24);return a+=fe(e<<16),a+=fe(i<<8),a+=fe(r),fe(a)}static toByteString(t){const{r:e,g:i,b:r,a:n}=s.fromOxyColor(t);return`${n},${e},${i},${r}`}static hueDifference(t,e){const i=this.toHsv(t),r=this.toHsv(e);let n=i[0]-r[0];n>.5&&(n-=1),n<-.5&&(n+=1);const a=Math.pow(n,2);return Math.sqrt(a)}}function ho(o){return o?(o.startsWith("#")&&(o=o.substring(1)),o.length===8||o.length===6||o.length===3?/^[0-9A-F]+$/.test(o.toUpperCase()):!1):!1}function He(o){return o.toString(16).padStart(2,"0")}function ui(o){return Math.round(o)}const p={Undefined:Ii,Automatic:ls,AliceBlue:"#f0f8ff",AntiqueWhite:"#faebd7",Aqua:"#0ff",Aquamarine:"#7fffd4",Azure:"#f0ffff",Beige:"#f5f5dc",Bisque:"#ffe4c4",Black:"#000",BlanchedAlmond:"#ffebcd",Blue:"#00f",BlueViolet:"#8a2be2",Brown:"#a52a2a",BurlyWood:"#deb887",CadetBlue:"#5f9ea0",Chartreuse:"#7fff00",Chocolate:"#d2691e",Coral:"#ff7f50",CornflowerBlue:"#6495ed",Cornsilk:"#fff8dc",Crimson:"#dc143c",Cyan:"#0ff",DarkBlue:"#00008b",DarkCyan:"#008b8b",DarkGoldenrod:"#b8860b",DarkGray:"#a9a9a9",DarkGreen:"#006400",DarkKhaki:"#bdb76b",DarkMagenta:"#8b008b",DarkOliveGreen:"#556b2f",DarkOrange:"#ff8c00",DarkOrchid:"#9932cc",DarkRed:"#8b0000",DarkSalmon:"#e9967a",DarkSeaGreen:"#8fbc8f",DarkSlateBlue:"#483d8b",DarkSlateGray:"#2f4f4f",DarkTurquoise:"#00ced1",DarkViolet:"#9400d3",DeepPink:"#ff1493",DeepSkyBlue:"#00bfff",DimGray:"#696969",DodgerBlue:"#1e90ff",Firebrick:"#b22222",FloralWhite:"#fffaf0",ForestGreen:"#228b22",Fuchsia:"#f0f",Gainsboro:"#dcdcdc",GhostWhite:"#f8f8ff",Gold:"#ffd700",Goldenrod:"#daa520",Gray:"#808080",Green:"#008000",GreenYellow:"#adff2f",Honeydew:"#f0fff0",HotPink:"#ff69b4",IndianRed:"#cd5c5c",Indigo:"#4b0082",Ivory:"#fffff0",Khaki:"#f0e68c",Lavender:"#e6e6fa",LavenderBlush:"#fff0f5",LawnGreen:"#7cfc00",LemonChiffon:"#fffacd",LightBlue:"#add8e6",LightCoral:"#f08080",LightCyan:"#e0ffff",LightGoldenrodYellow:"#fafad2",LightGray:"#d3d3d3",LightGreen:"#90ee90",LightPink:"#ffb6c1",LightSalmon:"#ffa07a",LightSeaGreen:"#20b2aa",LightSkyBlue:"#87cefa",LightSlateGray:"#789",LightSteelBlue:"#b0c4de",LightYellow:"#ffffe0",Lime:"#0f0",LimeGreen:"#32cd32",Linen:"#faf0e6",Magenta:"#f0f",Maroon:"#800000",MediumAquamarine:"#66cdaa",MediumBlue:"#0000cd",MediumOrchid:"#ba55d3",MediumPurple:"#9370db",MediumSeaGreen:"#3cb371",MediumSlateBlue:"#7b68ee",MediumSpringGreen:"#00fa9a",MediumTurquoise:"#48d1cc",MediumVioletRed:"#c71585",MidnightBlue:"#191970",MintCream:"#f5fffa",MistyRose:"#ffe4e1",Moccasin:"#ffe4b5",NavajoWhite:"#ffdead",Navy:"#000080",OldLace:"#fdf5e6",Olive:"#808000",OliveDrab:"#6b8e23",Orange:"#ffa500",OrangeRed:"#ff4500",Orchid:"#da70d6",PaleGoldenrod:"#eee8aa",PaleGreen:"#98fb98",PaleTurquoise:"#afeeee",PaleVioletRed:"#db7093",PapayaWhip:"#ffefd5",PeachPuff:"#ffdab9",Peru:"#cd853f",Pink:"#ffc0cb",Plum:"#dda0dd",PowderBlue:"#b0e0e6",Purple:"#800080",Red:"#f00",RosyBrown:"#bc8f8f",RoyalBlue:"#4169e1",SaddleBrown:"#8b4513",Salmon:"#fa8072",SandyBrown:"#f4a460",SeaGreen:"#2e8b57",SeaShell:"#fff5ee",Sienna:"#a0522d",Silver:"#c0c0c0",SkyBlue:"#87ceeb",SlateBlue:"#6a5acd",SlateGray:"#708090",Snow:"#fffafa",SpringGreen:"#00ff7f",SteelBlue:"#4682b4",Tan:"#d2b48c",Teal:"#008080",Thistle:"#d8bfd8",Tomato:"#ff6347",Transparent:"#00ffffff",Turquoise:"#40e0d0",Violet:"#ee82ee",Wheat:"#f5deb3",White:"#fff",WhiteSmoke:"#f5f5f5",Yellow:"#ff0",YellowGreen:"#9acd32"};Object.freeze(p);function mo(o){if(!o)return;o=o.toLowerCase();const t=p;for(const e of Object.keys(t))if(e.toLowerCase()===o)return t[e]}function Zt(o){if(!(o!=null&&o.length))return Object.freeze({colors:[]});let t=o;return o[0].hex&&(t=o.map(e=>e.hex)),Object.freeze({colors:t})}class vt{static interpolate(t,...e){if(!e||e.length===0||t<1)return Zt([]);const i=[],r=t===1?0:1/(t-1);for(let n=0;n<t;n++){const a=n*r*(e.length-1),h=Math.floor(a),m=h+1<e.length?h+1:h,u=s.fromOxyColor(e[h]),c=s.fromOxyColor(e[m]);i[n]=F.interpolate(u,c,a-h)}return Zt(i)}static reverse(t){return Zt(Ge(t.colors))}}class Xt{static blackWhiteRed(t){return vt.interpolate(t,p.Black,p.White,p.Red)}static blueWhiteRed(t){return vt.interpolate(t,p.Blue,p.White,p.Red)}static cool(t){return vt.interpolate(t,p.Cyan,p.Magenta)}static gray(t){return vt.interpolate(t,p.Black,p.White)}static hot(t){return vt.interpolate(t,p.Black,s.fromRgb(127,0,0),s.fromRgb(255,127,0),s.fromRgb(255,255,127),p.White)}static hue(t){return vt.interpolate(t,p.Red,p.Yellow,p.Green,p.Cyan,p.Blue,p.Magenta,p.Red)}static hueDistinct(t){return vt.interpolate(t,p.Magenta,p.Blue,p.Cyan,p.Green,p.Yellow,p.Red)}static jet(t){return vt.interpolate(t,p.DarkBlue,p.Cyan,p.Yellow,p.Orange,p.DarkRed)}static rainbow(t){return vt.interpolate(t,p.Violet,p.Indigo,p.Blue,p.Green,p.Yellow,p.Orange,p.Red)}static cividis(t=256){return t===Ui.length?Zt(Ui):vt.interpolate(t,...Ui)}static inferno(t=256){return t===Hi.length?Zt(Hi):vt.interpolate(t,...Hi)}static magma(t=256){return t===ji.length?Zt(ji):vt.interpolate(t,...ji)}static plasma(t=256){return t===Gi.length?Zt(Gi):vt.interpolate(t,...Gi)}static viridis(t=256){return t===Ki.length?Zt(Ki):vt.interpolate(t,...Ki)}}l(Xt,"blueWhiteRed31"),l(Xt,"hot64"),l(Xt,"hue64");Xt.blueWhiteRed31=Xt.blueWhiteRed(31);Xt.hot64=Xt.hot(64);Xt.hue64=Xt.hue(64);const Ui=[s.fromRgb(0,32,77),s.fromRgb(0,33,78),s.fromRgb(0,34,80),s.fromRgb(0,34,82),s.fromRgb(0,35,83),s.fromRgb(0,36,85),s.fromRgb(0,37,87),s.fromRgb(0,37,88),s.fromRgb(0,38,90),s.fromRgb(0,39,92),s.fromRgb(0,39,94),s.fromRgb(0,40,96),s.fromRgb(0,41,97),s.fromRgb(0,42,99),s.fromRgb(0,42,101),s.fromRgb(0,43,103),s.fromRgb(0,44,105),s.fromRgb(0,44,106),s.fromRgb(0,45,108),s.fromRgb(0,46,110),s.fromRgb(0,46,111),s.fromRgb(0,47,111),s.fromRgb(0,47,111),s.fromRgb(0,48,111),s.fromRgb(0,48,111),s.fromRgb(0,49,111),s.fromRgb(0,50,111),s.fromRgb(0,51,111),s.fromRgb(0,51,111),s.fromRgb(0,52,111),s.fromRgb(0,53,110),s.fromRgb(1,54,110),s.fromRgb(6,54,110),s.fromRgb(11,55,110),s.fromRgb(15,56,110),s.fromRgb(18,56,109),s.fromRgb(21,57,109),s.fromRgb(24,58,109),s.fromRgb(26,59,109),s.fromRgb(29,59,109),s.fromRgb(31,60,109),s.fromRgb(33,61,109),s.fromRgb(35,62,108),s.fromRgb(36,62,108),s.fromRgb(38,63,108),s.fromRgb(40,64,108),s.fromRgb(42,64,108),s.fromRgb(43,65,108),s.fromRgb(45,66,108),s.fromRgb(46,67,108),s.fromRgb(48,67,108),s.fromRgb(49,68,107),s.fromRgb(50,69,107),s.fromRgb(52,69,107),s.fromRgb(53,70,107),s.fromRgb(54,71,107),s.fromRgb(56,72,107),s.fromRgb(57,72,107),s.fromRgb(58,73,107),s.fromRgb(59,74,107),s.fromRgb(61,74,107),s.fromRgb(62,75,107),s.fromRgb(63,76,107),s.fromRgb(64,77,107),s.fromRgb(65,77,107),s.fromRgb(66,78,107),s.fromRgb(67,79,107),s.fromRgb(68,79,107),s.fromRgb(70,80,107),s.fromRgb(71,81,107),s.fromRgb(72,82,107),s.fromRgb(73,82,107),s.fromRgb(74,83,107),s.fromRgb(75,84,108),s.fromRgb(76,84,108),s.fromRgb(77,85,108),s.fromRgb(78,86,108),s.fromRgb(79,87,108),s.fromRgb(80,87,108),s.fromRgb(81,88,108),s.fromRgb(82,89,108),s.fromRgb(83,89,108),s.fromRgb(84,90,108),s.fromRgb(85,91,109),s.fromRgb(86,92,109),s.fromRgb(87,92,109),s.fromRgb(88,93,109),s.fromRgb(89,94,109),s.fromRgb(89,95,109),s.fromRgb(90,95,109),s.fromRgb(91,96,110),s.fromRgb(92,97,110),s.fromRgb(93,97,110),s.fromRgb(94,98,110),s.fromRgb(95,99,110),s.fromRgb(96,100,111),s.fromRgb(97,100,111),s.fromRgb(98,101,111),s.fromRgb(99,102,111),s.fromRgb(100,102,111),s.fromRgb(100,103,112),s.fromRgb(101,104,112),s.fromRgb(102,105,112),s.fromRgb(103,105,112),s.fromRgb(104,106,113),s.fromRgb(105,107,113),s.fromRgb(106,108,113),s.fromRgb(107,108,113),s.fromRgb(108,109,114),s.fromRgb(108,110,114),s.fromRgb(109,110,114),s.fromRgb(110,111,115),s.fromRgb(111,112,115),s.fromRgb(112,113,115),s.fromRgb(113,113,116),s.fromRgb(114,114,116),s.fromRgb(114,115,116),s.fromRgb(115,116,117),s.fromRgb(116,116,117),s.fromRgb(117,117,117),s.fromRgb(118,118,118),s.fromRgb(119,119,118),s.fromRgb(120,119,119),s.fromRgb(120,120,119),s.fromRgb(121,121,119),s.fromRgb(122,122,120),s.fromRgb(123,122,120),s.fromRgb(124,123,120),s.fromRgb(125,124,120),s.fromRgb(126,125,120),s.fromRgb(127,125,120),s.fromRgb(128,126,121),s.fromRgb(129,127,121),s.fromRgb(130,128,121),s.fromRgb(131,128,121),s.fromRgb(132,129,121),s.fromRgb(132,130,121),s.fromRgb(133,131,121),s.fromRgb(134,131,121),s.fromRgb(135,132,121),s.fromRgb(136,133,121),s.fromRgb(137,134,121),s.fromRgb(138,135,121),s.fromRgb(139,135,121),s.fromRgb(140,136,121),s.fromRgb(141,137,121),s.fromRgb(142,138,121),s.fromRgb(143,138,121),s.fromRgb(144,139,121),s.fromRgb(145,140,120),s.fromRgb(146,141,120),s.fromRgb(147,142,120),s.fromRgb(148,142,120),s.fromRgb(149,143,120),s.fromRgb(150,144,120),s.fromRgb(151,145,120),s.fromRgb(152,146,120),s.fromRgb(153,146,120),s.fromRgb(154,147,119),s.fromRgb(155,148,119),s.fromRgb(156,149,119),s.fromRgb(157,150,119),s.fromRgb(158,150,119),s.fromRgb(159,151,119),s.fromRgb(160,152,119),s.fromRgb(161,153,118),s.fromRgb(162,154,118),s.fromRgb(163,154,118),s.fromRgb(164,155,118),s.fromRgb(165,156,118),s.fromRgb(166,157,117),s.fromRgb(168,158,117),s.fromRgb(169,159,117),s.fromRgb(170,159,117),s.fromRgb(171,160,116),s.fromRgb(172,161,116),s.fromRgb(173,162,116),s.fromRgb(174,163,116),s.fromRgb(175,164,115),s.fromRgb(176,164,115),s.fromRgb(177,165,115),s.fromRgb(178,166,114),s.fromRgb(179,167,114),s.fromRgb(180,168,114),s.fromRgb(181,169,113),s.fromRgb(182,169,113),s.fromRgb(183,170,113),s.fromRgb(184,171,112),s.fromRgb(185,172,112),s.fromRgb(186,173,112),s.fromRgb(187,174,111),s.fromRgb(188,175,111),s.fromRgb(190,175,111),s.fromRgb(191,176,110),s.fromRgb(192,177,110),s.fromRgb(193,178,109),s.fromRgb(194,179,109),s.fromRgb(195,180,109),s.fromRgb(196,181,108),s.fromRgb(197,181,108),s.fromRgb(198,182,107),s.fromRgb(199,183,107),s.fromRgb(200,184,106),s.fromRgb(201,185,106),s.fromRgb(203,186,105),s.fromRgb(204,187,105),s.fromRgb(205,188,104),s.fromRgb(206,188,104),s.fromRgb(207,189,103),s.fromRgb(208,190,103),s.fromRgb(209,191,102),s.fromRgb(210,192,102),s.fromRgb(211,193,101),s.fromRgb(212,194,100),s.fromRgb(214,195,100),s.fromRgb(215,196,99),s.fromRgb(216,197,99),s.fromRgb(217,197,98),s.fromRgb(218,198,97),s.fromRgb(219,199,97),s.fromRgb(220,200,96),s.fromRgb(221,201,95),s.fromRgb(222,202,95),s.fromRgb(224,203,94),s.fromRgb(225,204,93),s.fromRgb(226,205,92),s.fromRgb(227,206,92),s.fromRgb(228,207,91),s.fromRgb(229,208,90),s.fromRgb(230,209,89),s.fromRgb(232,210,89),s.fromRgb(233,211,88),s.fromRgb(234,211,87),s.fromRgb(235,212,86),s.fromRgb(236,213,85),s.fromRgb(237,214,84),s.fromRgb(239,215,83),s.fromRgb(240,216,82),s.fromRgb(241,217,81),s.fromRgb(242,218,80),s.fromRgb(243,219,79),s.fromRgb(244,220,78),s.fromRgb(246,221,77),s.fromRgb(247,222,76),s.fromRgb(248,223,75),s.fromRgb(249,224,74),s.fromRgb(250,225,73),s.fromRgb(251,226,72),s.fromRgb(253,227,70),s.fromRgb(254,228,69),s.fromRgb(255,229,68),s.fromRgb(255,230,66),s.fromRgb(255,231,66),s.fromRgb(255,232,67),s.fromRgb(255,233,68),s.fromRgb(255,234,70)],Hi=[s.fromRgb(0,0,4),s.fromRgb(1,0,5),s.fromRgb(1,1,6),s.fromRgb(1,1,8),s.fromRgb(2,1,10),s.fromRgb(2,2,12),s.fromRgb(2,2,14),s.fromRgb(3,2,16),s.fromRgb(4,3,18),s.fromRgb(4,3,20),s.fromRgb(5,4,23),s.fromRgb(6,4,25),s.fromRgb(7,5,27),s.fromRgb(8,5,29),s.fromRgb(9,6,31),s.fromRgb(10,7,34),s.fromRgb(11,7,36),s.fromRgb(12,8,38),s.fromRgb(13,8,41),s.fromRgb(14,9,43),s.fromRgb(16,9,45),s.fromRgb(17,10,48),s.fromRgb(18,10,50),s.fromRgb(20,11,52),s.fromRgb(21,11,55),s.fromRgb(22,11,57),s.fromRgb(24,12,60),s.fromRgb(25,12,62),s.fromRgb(27,12,65),s.fromRgb(28,12,67),s.fromRgb(30,12,69),s.fromRgb(31,12,72),s.fromRgb(33,12,74),s.fromRgb(35,12,76),s.fromRgb(36,12,79),s.fromRgb(38,12,81),s.fromRgb(40,11,83),s.fromRgb(41,11,85),s.fromRgb(43,11,87),s.fromRgb(45,11,89),s.fromRgb(47,10,91),s.fromRgb(49,10,92),s.fromRgb(50,10,94),s.fromRgb(52,10,95),s.fromRgb(54,9,97),s.fromRgb(56,9,98),s.fromRgb(57,9,99),s.fromRgb(59,9,100),s.fromRgb(61,9,101),s.fromRgb(62,9,102),s.fromRgb(64,10,103),s.fromRgb(66,10,104),s.fromRgb(68,10,104),s.fromRgb(69,10,105),s.fromRgb(71,11,106),s.fromRgb(73,11,106),s.fromRgb(74,12,107),s.fromRgb(76,12,107),s.fromRgb(77,13,108),s.fromRgb(79,13,108),s.fromRgb(81,14,108),s.fromRgb(82,14,109),s.fromRgb(84,15,109),s.fromRgb(85,15,109),s.fromRgb(87,16,110),s.fromRgb(89,16,110),s.fromRgb(90,17,110),s.fromRgb(92,18,110),s.fromRgb(93,18,110),s.fromRgb(95,19,110),s.fromRgb(97,19,110),s.fromRgb(98,20,110),s.fromRgb(100,21,110),s.fromRgb(101,21,110),s.fromRgb(103,22,110),s.fromRgb(105,22,110),s.fromRgb(106,23,110),s.fromRgb(108,24,110),s.fromRgb(109,24,110),s.fromRgb(111,25,110),s.fromRgb(113,25,110),s.fromRgb(114,26,110),s.fromRgb(116,26,110),s.fromRgb(117,27,110),s.fromRgb(119,28,109),s.fromRgb(120,28,109),s.fromRgb(122,29,109),s.fromRgb(124,29,109),s.fromRgb(125,30,109),s.fromRgb(127,30,108),s.fromRgb(128,31,108),s.fromRgb(130,32,108),s.fromRgb(132,32,107),s.fromRgb(133,33,107),s.fromRgb(135,33,107),s.fromRgb(136,34,106),s.fromRgb(138,34,106),s.fromRgb(140,35,105),s.fromRgb(141,35,105),s.fromRgb(143,36,105),s.fromRgb(144,37,104),s.fromRgb(146,37,104),s.fromRgb(147,38,103),s.fromRgb(149,38,103),s.fromRgb(151,39,102),s.fromRgb(152,39,102),s.fromRgb(154,40,101),s.fromRgb(155,41,100),s.fromRgb(157,41,100),s.fromRgb(159,42,99),s.fromRgb(160,42,99),s.fromRgb(162,43,98),s.fromRgb(163,44,97),s.fromRgb(165,44,96),s.fromRgb(166,45,96),s.fromRgb(168,46,95),s.fromRgb(169,46,94),s.fromRgb(171,47,94),s.fromRgb(173,48,93),s.fromRgb(174,48,92),s.fromRgb(176,49,91),s.fromRgb(177,50,90),s.fromRgb(179,50,90),s.fromRgb(180,51,89),s.fromRgb(182,52,88),s.fromRgb(183,53,87),s.fromRgb(185,53,86),s.fromRgb(186,54,85),s.fromRgb(188,55,84),s.fromRgb(189,56,83),s.fromRgb(191,57,82),s.fromRgb(192,58,81),s.fromRgb(193,58,80),s.fromRgb(195,59,79),s.fromRgb(196,60,78),s.fromRgb(198,61,77),s.fromRgb(199,62,76),s.fromRgb(200,63,75),s.fromRgb(202,64,74),s.fromRgb(203,65,73),s.fromRgb(204,66,72),s.fromRgb(206,67,71),s.fromRgb(207,68,70),s.fromRgb(208,69,69),s.fromRgb(210,70,68),s.fromRgb(211,71,67),s.fromRgb(212,72,66),s.fromRgb(213,74,65),s.fromRgb(215,75,63),s.fromRgb(216,76,62),s.fromRgb(217,77,61),s.fromRgb(218,78,60),s.fromRgb(219,80,59),s.fromRgb(221,81,58),s.fromRgb(222,82,56),s.fromRgb(223,83,55),s.fromRgb(224,85,54),s.fromRgb(225,86,53),s.fromRgb(226,87,52),s.fromRgb(227,89,51),s.fromRgb(228,90,49),s.fromRgb(229,92,48),s.fromRgb(230,93,47),s.fromRgb(231,94,46),s.fromRgb(232,96,45),s.fromRgb(233,97,43),s.fromRgb(234,99,42),s.fromRgb(235,100,41),s.fromRgb(235,102,40),s.fromRgb(236,103,38),s.fromRgb(237,105,37),s.fromRgb(238,106,36),s.fromRgb(239,108,35),s.fromRgb(239,110,33),s.fromRgb(240,111,32),s.fromRgb(241,113,31),s.fromRgb(241,115,29),s.fromRgb(242,116,28),s.fromRgb(243,118,27),s.fromRgb(243,120,25),s.fromRgb(244,121,24),s.fromRgb(245,123,23),s.fromRgb(245,125,21),s.fromRgb(246,126,20),s.fromRgb(246,128,19),s.fromRgb(247,130,18),s.fromRgb(247,132,16),s.fromRgb(248,133,15),s.fromRgb(248,135,14),s.fromRgb(248,137,12),s.fromRgb(249,139,11),s.fromRgb(249,140,10),s.fromRgb(249,142,9),s.fromRgb(250,144,8),s.fromRgb(250,146,7),s.fromRgb(250,148,7),s.fromRgb(251,150,6),s.fromRgb(251,151,6),s.fromRgb(251,153,6),s.fromRgb(251,155,6),s.fromRgb(251,157,7),s.fromRgb(252,159,7),s.fromRgb(252,161,8),s.fromRgb(252,163,9),s.fromRgb(252,165,10),s.fromRgb(252,166,12),s.fromRgb(252,168,13),s.fromRgb(252,170,15),s.fromRgb(252,172,17),s.fromRgb(252,174,18),s.fromRgb(252,176,20),s.fromRgb(252,178,22),s.fromRgb(252,180,24),s.fromRgb(251,182,26),s.fromRgb(251,184,29),s.fromRgb(251,186,31),s.fromRgb(251,188,33),s.fromRgb(251,190,35),s.fromRgb(250,192,38),s.fromRgb(250,194,40),s.fromRgb(250,196,42),s.fromRgb(250,198,45),s.fromRgb(249,199,47),s.fromRgb(249,201,50),s.fromRgb(249,203,53),s.fromRgb(248,205,55),s.fromRgb(248,207,58),s.fromRgb(247,209,61),s.fromRgb(247,211,64),s.fromRgb(246,213,67),s.fromRgb(246,215,70),s.fromRgb(245,217,73),s.fromRgb(245,219,76),s.fromRgb(244,221,79),s.fromRgb(244,223,83),s.fromRgb(244,225,86),s.fromRgb(243,227,90),s.fromRgb(243,229,93),s.fromRgb(242,230,97),s.fromRgb(242,232,101),s.fromRgb(242,234,105),s.fromRgb(241,236,109),s.fromRgb(241,237,113),s.fromRgb(241,239,117),s.fromRgb(241,241,121),s.fromRgb(242,242,125),s.fromRgb(242,244,130),s.fromRgb(243,245,134),s.fromRgb(243,246,138),s.fromRgb(244,248,142),s.fromRgb(245,249,146),s.fromRgb(246,250,150),s.fromRgb(248,251,154),s.fromRgb(249,252,157),s.fromRgb(250,253,161),s.fromRgb(252,255,164)],ji=[s.fromRgb(0,0,4),s.fromRgb(1,0,5),s.fromRgb(1,1,6),s.fromRgb(1,1,8),s.fromRgb(2,1,9),s.fromRgb(2,2,11),s.fromRgb(2,2,13),s.fromRgb(3,3,15),s.fromRgb(3,3,18),s.fromRgb(4,4,20),s.fromRgb(5,4,22),s.fromRgb(6,5,24),s.fromRgb(6,5,26),s.fromRgb(7,6,28),s.fromRgb(8,7,30),s.fromRgb(9,7,32),s.fromRgb(10,8,34),s.fromRgb(11,9,36),s.fromRgb(12,9,38),s.fromRgb(13,10,41),s.fromRgb(14,11,43),s.fromRgb(16,11,45),s.fromRgb(17,12,47),s.fromRgb(18,13,49),s.fromRgb(19,13,52),s.fromRgb(20,14,54),s.fromRgb(21,14,56),s.fromRgb(22,15,59),s.fromRgb(24,15,61),s.fromRgb(25,16,63),s.fromRgb(26,16,66),s.fromRgb(28,16,68),s.fromRgb(29,17,71),s.fromRgb(30,17,73),s.fromRgb(32,17,75),s.fromRgb(33,17,78),s.fromRgb(34,17,80),s.fromRgb(36,18,83),s.fromRgb(37,18,85),s.fromRgb(39,18,88),s.fromRgb(41,17,90),s.fromRgb(42,17,92),s.fromRgb(44,17,95),s.fromRgb(45,17,97),s.fromRgb(47,17,99),s.fromRgb(49,17,101),s.fromRgb(51,16,103),s.fromRgb(52,16,105),s.fromRgb(54,16,107),s.fromRgb(56,16,108),s.fromRgb(57,15,110),s.fromRgb(59,15,112),s.fromRgb(61,15,113),s.fromRgb(63,15,114),s.fromRgb(64,15,116),s.fromRgb(66,15,117),s.fromRgb(68,15,118),s.fromRgb(69,16,119),s.fromRgb(71,16,120),s.fromRgb(73,16,120),s.fromRgb(74,16,121),s.fromRgb(76,17,122),s.fromRgb(78,17,123),s.fromRgb(79,18,123),s.fromRgb(81,18,124),s.fromRgb(82,19,124),s.fromRgb(84,19,125),s.fromRgb(86,20,125),s.fromRgb(87,21,126),s.fromRgb(89,21,126),s.fromRgb(90,22,126),s.fromRgb(92,22,127),s.fromRgb(93,23,127),s.fromRgb(95,24,127),s.fromRgb(96,24,128),s.fromRgb(98,25,128),s.fromRgb(100,26,128),s.fromRgb(101,26,128),s.fromRgb(103,27,128),s.fromRgb(104,28,129),s.fromRgb(106,28,129),s.fromRgb(107,29,129),s.fromRgb(109,29,129),s.fromRgb(110,30,129),s.fromRgb(112,31,129),s.fromRgb(114,31,129),s.fromRgb(115,32,129),s.fromRgb(117,33,129),s.fromRgb(118,33,129),s.fromRgb(120,34,129),s.fromRgb(121,34,130),s.fromRgb(123,35,130),s.fromRgb(124,35,130),s.fromRgb(126,36,130),s.fromRgb(128,37,130),s.fromRgb(129,37,129),s.fromRgb(131,38,129),s.fromRgb(132,38,129),s.fromRgb(134,39,129),s.fromRgb(136,39,129),s.fromRgb(137,40,129),s.fromRgb(139,41,129),s.fromRgb(140,41,129),s.fromRgb(142,42,129),s.fromRgb(144,42,129),s.fromRgb(145,43,129),s.fromRgb(147,43,128),s.fromRgb(148,44,128),s.fromRgb(150,44,128),s.fromRgb(152,45,128),s.fromRgb(153,45,128),s.fromRgb(155,46,127),s.fromRgb(156,46,127),s.fromRgb(158,47,127),s.fromRgb(160,47,127),s.fromRgb(161,48,126),s.fromRgb(163,48,126),s.fromRgb(165,49,126),s.fromRgb(166,49,125),s.fromRgb(168,50,125),s.fromRgb(170,51,125),s.fromRgb(171,51,124),s.fromRgb(173,52,124),s.fromRgb(174,52,123),s.fromRgb(176,53,123),s.fromRgb(178,53,123),s.fromRgb(179,54,122),s.fromRgb(181,54,122),s.fromRgb(183,55,121),s.fromRgb(184,55,121),s.fromRgb(186,56,120),s.fromRgb(188,57,120),s.fromRgb(189,57,119),s.fromRgb(191,58,119),s.fromRgb(192,58,118),s.fromRgb(194,59,117),s.fromRgb(196,60,117),s.fromRgb(197,60,116),s.fromRgb(199,61,115),s.fromRgb(200,62,115),s.fromRgb(202,62,114),s.fromRgb(204,63,113),s.fromRgb(205,64,113),s.fromRgb(207,64,112),s.fromRgb(208,65,111),s.fromRgb(210,66,111),s.fromRgb(211,67,110),s.fromRgb(213,68,109),s.fromRgb(214,69,108),s.fromRgb(216,69,108),s.fromRgb(217,70,107),s.fromRgb(219,71,106),s.fromRgb(220,72,105),s.fromRgb(222,73,104),s.fromRgb(223,74,104),s.fromRgb(224,76,103),s.fromRgb(226,77,102),s.fromRgb(227,78,101),s.fromRgb(228,79,100),s.fromRgb(229,80,100),s.fromRgb(231,82,99),s.fromRgb(232,83,98),s.fromRgb(233,84,98),s.fromRgb(234,86,97),s.fromRgb(235,87,96),s.fromRgb(236,88,96),s.fromRgb(237,90,95),s.fromRgb(238,91,94),s.fromRgb(239,93,94),s.fromRgb(240,95,94),s.fromRgb(241,96,93),s.fromRgb(242,98,93),s.fromRgb(242,100,92),s.fromRgb(243,101,92),s.fromRgb(244,103,92),s.fromRgb(244,105,92),s.fromRgb(245,107,92),s.fromRgb(246,108,92),s.fromRgb(246,110,92),s.fromRgb(247,112,92),s.fromRgb(247,114,92),s.fromRgb(248,116,92),s.fromRgb(248,118,92),s.fromRgb(249,120,93),s.fromRgb(249,121,93),s.fromRgb(249,123,93),s.fromRgb(250,125,94),s.fromRgb(250,127,94),s.fromRgb(250,129,95),s.fromRgb(251,131,95),s.fromRgb(251,133,96),s.fromRgb(251,135,97),s.fromRgb(252,137,97),s.fromRgb(252,138,98),s.fromRgb(252,140,99),s.fromRgb(252,142,100),s.fromRgb(252,144,101),s.fromRgb(253,146,102),s.fromRgb(253,148,103),s.fromRgb(253,150,104),s.fromRgb(253,152,105),s.fromRgb(253,154,106),s.fromRgb(253,155,107),s.fromRgb(254,157,108),s.fromRgb(254,159,109),s.fromRgb(254,161,110),s.fromRgb(254,163,111),s.fromRgb(254,165,113),s.fromRgb(254,167,114),s.fromRgb(254,169,115),s.fromRgb(254,170,116),s.fromRgb(254,172,118),s.fromRgb(254,174,119),s.fromRgb(254,176,120),s.fromRgb(254,178,122),s.fromRgb(254,180,123),s.fromRgb(254,182,124),s.fromRgb(254,183,126),s.fromRgb(254,185,127),s.fromRgb(254,187,129),s.fromRgb(254,189,130),s.fromRgb(254,191,132),s.fromRgb(254,193,133),s.fromRgb(254,194,135),s.fromRgb(254,196,136),s.fromRgb(254,198,138),s.fromRgb(254,200,140),s.fromRgb(254,202,141),s.fromRgb(254,204,143),s.fromRgb(254,205,144),s.fromRgb(254,207,146),s.fromRgb(254,209,148),s.fromRgb(254,211,149),s.fromRgb(254,213,151),s.fromRgb(254,215,153),s.fromRgb(254,216,154),s.fromRgb(253,218,156),s.fromRgb(253,220,158),s.fromRgb(253,222,160),s.fromRgb(253,224,161),s.fromRgb(253,226,163),s.fromRgb(253,227,165),s.fromRgb(253,229,167),s.fromRgb(253,231,169),s.fromRgb(253,233,170),s.fromRgb(253,235,172),s.fromRgb(252,236,174),s.fromRgb(252,238,176),s.fromRgb(252,240,178),s.fromRgb(252,242,180),s.fromRgb(252,244,182),s.fromRgb(252,246,184),s.fromRgb(252,247,185),s.fromRgb(252,249,187),s.fromRgb(252,251,189),s.fromRgb(252,253,191)],Gi=[s.fromRgb(13,8,135),s.fromRgb(16,7,136),s.fromRgb(19,7,137),s.fromRgb(22,7,138),s.fromRgb(25,6,140),s.fromRgb(27,6,141),s.fromRgb(29,6,142),s.fromRgb(32,6,143),s.fromRgb(34,6,144),s.fromRgb(36,6,145),s.fromRgb(38,5,145),s.fromRgb(40,5,146),s.fromRgb(42,5,147),s.fromRgb(44,5,148),s.fromRgb(46,5,149),s.fromRgb(47,5,150),s.fromRgb(49,5,151),s.fromRgb(51,5,151),s.fromRgb(53,4,152),s.fromRgb(55,4,153),s.fromRgb(56,4,154),s.fromRgb(58,4,154),s.fromRgb(60,4,155),s.fromRgb(62,4,156),s.fromRgb(63,4,156),s.fromRgb(65,4,157),s.fromRgb(67,3,158),s.fromRgb(68,3,158),s.fromRgb(70,3,159),s.fromRgb(72,3,159),s.fromRgb(73,3,160),s.fromRgb(75,3,161),s.fromRgb(76,2,161),s.fromRgb(78,2,162),s.fromRgb(80,2,162),s.fromRgb(81,2,163),s.fromRgb(83,2,163),s.fromRgb(85,2,164),s.fromRgb(86,1,164),s.fromRgb(88,1,164),s.fromRgb(89,1,165),s.fromRgb(91,1,165),s.fromRgb(92,1,166),s.fromRgb(94,1,166),s.fromRgb(96,1,166),s.fromRgb(97,0,167),s.fromRgb(99,0,167),s.fromRgb(100,0,167),s.fromRgb(102,0,167),s.fromRgb(103,0,168),s.fromRgb(105,0,168),s.fromRgb(106,0,168),s.fromRgb(108,0,168),s.fromRgb(110,0,168),s.fromRgb(111,0,168),s.fromRgb(113,0,168),s.fromRgb(114,1,168),s.fromRgb(116,1,168),s.fromRgb(117,1,168),s.fromRgb(119,1,168),s.fromRgb(120,1,168),s.fromRgb(122,2,168),s.fromRgb(123,2,168),s.fromRgb(125,3,168),s.fromRgb(126,3,168),s.fromRgb(128,4,168),s.fromRgb(129,4,167),s.fromRgb(131,5,167),s.fromRgb(132,5,167),s.fromRgb(134,6,166),s.fromRgb(135,7,166),s.fromRgb(136,8,166),s.fromRgb(138,9,165),s.fromRgb(139,10,165),s.fromRgb(141,11,165),s.fromRgb(142,12,164),s.fromRgb(143,13,164),s.fromRgb(145,14,163),s.fromRgb(146,15,163),s.fromRgb(148,16,162),s.fromRgb(149,17,161),s.fromRgb(150,19,161),s.fromRgb(152,20,160),s.fromRgb(153,21,159),s.fromRgb(154,22,159),s.fromRgb(156,23,158),s.fromRgb(157,24,157),s.fromRgb(158,25,157),s.fromRgb(160,26,156),s.fromRgb(161,27,155),s.fromRgb(162,29,154),s.fromRgb(163,30,154),s.fromRgb(165,31,153),s.fromRgb(166,32,152),s.fromRgb(167,33,151),s.fromRgb(168,34,150),s.fromRgb(170,35,149),s.fromRgb(171,36,148),s.fromRgb(172,38,148),s.fromRgb(173,39,147),s.fromRgb(174,40,146),s.fromRgb(176,41,145),s.fromRgb(177,42,144),s.fromRgb(178,43,143),s.fromRgb(179,44,142),s.fromRgb(180,46,141),s.fromRgb(181,47,140),s.fromRgb(182,48,139),s.fromRgb(183,49,138),s.fromRgb(184,50,137),s.fromRgb(186,51,136),s.fromRgb(187,52,136),s.fromRgb(188,53,135),s.fromRgb(189,55,134),s.fromRgb(190,56,133),s.fromRgb(191,57,132),s.fromRgb(192,58,131),s.fromRgb(193,59,130),s.fromRgb(194,60,129),s.fromRgb(195,61,128),s.fromRgb(196,62,127),s.fromRgb(197,64,126),s.fromRgb(198,65,125),s.fromRgb(199,66,124),s.fromRgb(200,67,123),s.fromRgb(201,68,122),s.fromRgb(202,69,122),s.fromRgb(203,70,121),s.fromRgb(204,71,120),s.fromRgb(204,73,119),s.fromRgb(205,74,118),s.fromRgb(206,75,117),s.fromRgb(207,76,116),s.fromRgb(208,77,115),s.fromRgb(209,78,114),s.fromRgb(210,79,113),s.fromRgb(211,81,113),s.fromRgb(212,82,112),s.fromRgb(213,83,111),s.fromRgb(213,84,110),s.fromRgb(214,85,109),s.fromRgb(215,86,108),s.fromRgb(216,87,107),s.fromRgb(217,88,106),s.fromRgb(218,90,106),s.fromRgb(218,91,105),s.fromRgb(219,92,104),s.fromRgb(220,93,103),s.fromRgb(221,94,102),s.fromRgb(222,95,101),s.fromRgb(222,97,100),s.fromRgb(223,98,99),s.fromRgb(224,99,99),s.fromRgb(225,100,98),s.fromRgb(226,101,97),s.fromRgb(226,102,96),s.fromRgb(227,104,95),s.fromRgb(228,105,94),s.fromRgb(229,106,93),s.fromRgb(229,107,93),s.fromRgb(230,108,92),s.fromRgb(231,110,91),s.fromRgb(231,111,90),s.fromRgb(232,112,89),s.fromRgb(233,113,88),s.fromRgb(233,114,87),s.fromRgb(234,116,87),s.fromRgb(235,117,86),s.fromRgb(235,118,85),s.fromRgb(236,119,84),s.fromRgb(237,121,83),s.fromRgb(237,122,82),s.fromRgb(238,123,81),s.fromRgb(239,124,81),s.fromRgb(239,126,80),s.fromRgb(240,127,79),s.fromRgb(240,128,78),s.fromRgb(241,129,77),s.fromRgb(241,131,76),s.fromRgb(242,132,75),s.fromRgb(243,133,75),s.fromRgb(243,135,74),s.fromRgb(244,136,73),s.fromRgb(244,137,72),s.fromRgb(245,139,71),s.fromRgb(245,140,70),s.fromRgb(246,141,69),s.fromRgb(246,143,68),s.fromRgb(247,144,68),s.fromRgb(247,145,67),s.fromRgb(247,147,66),s.fromRgb(248,148,65),s.fromRgb(248,149,64),s.fromRgb(249,151,63),s.fromRgb(249,152,62),s.fromRgb(249,154,62),s.fromRgb(250,155,61),s.fromRgb(250,156,60),s.fromRgb(250,158,59),s.fromRgb(251,159,58),s.fromRgb(251,161,57),s.fromRgb(251,162,56),s.fromRgb(252,163,56),s.fromRgb(252,165,55),s.fromRgb(252,166,54),s.fromRgb(252,168,53),s.fromRgb(252,169,52),s.fromRgb(253,171,51),s.fromRgb(253,172,51),s.fromRgb(253,174,50),s.fromRgb(253,175,49),s.fromRgb(253,177,48),s.fromRgb(253,178,47),s.fromRgb(253,180,47),s.fromRgb(253,181,46),s.fromRgb(254,183,45),s.fromRgb(254,184,44),s.fromRgb(254,186,44),s.fromRgb(254,187,43),s.fromRgb(254,189,42),s.fromRgb(254,190,42),s.fromRgb(254,192,41),s.fromRgb(253,194,41),s.fromRgb(253,195,40),s.fromRgb(253,197,39),s.fromRgb(253,198,39),s.fromRgb(253,200,39),s.fromRgb(253,202,38),s.fromRgb(253,203,38),s.fromRgb(252,205,37),s.fromRgb(252,206,37),s.fromRgb(252,208,37),s.fromRgb(252,210,37),s.fromRgb(251,211,36),s.fromRgb(251,213,36),s.fromRgb(251,215,36),s.fromRgb(250,216,36),s.fromRgb(250,218,36),s.fromRgb(249,220,36),s.fromRgb(249,221,37),s.fromRgb(248,223,37),s.fromRgb(248,225,37),s.fromRgb(247,226,37),s.fromRgb(247,228,37),s.fromRgb(246,230,38),s.fromRgb(246,232,38),s.fromRgb(245,233,38),s.fromRgb(245,235,39),s.fromRgb(244,237,39),s.fromRgb(243,238,39),s.fromRgb(243,240,39),s.fromRgb(242,242,39),s.fromRgb(241,244,38),s.fromRgb(241,245,37),s.fromRgb(240,247,36),s.fromRgb(240,249,33)],Ki=[s.fromRgb(68,1,84),s.fromRgb(68,2,86),s.fromRgb(69,4,87),s.fromRgb(69,5,89),s.fromRgb(70,7,90),s.fromRgb(70,8,92),s.fromRgb(70,10,93),s.fromRgb(70,11,94),s.fromRgb(71,13,96),s.fromRgb(71,14,97),s.fromRgb(71,16,99),s.fromRgb(71,17,100),s.fromRgb(71,19,101),s.fromRgb(72,20,103),s.fromRgb(72,22,104),s.fromRgb(72,23,105),s.fromRgb(72,24,106),s.fromRgb(72,26,108),s.fromRgb(72,27,109),s.fromRgb(72,28,110),s.fromRgb(72,29,111),s.fromRgb(72,31,112),s.fromRgb(72,32,113),s.fromRgb(72,33,115),s.fromRgb(72,35,116),s.fromRgb(72,36,117),s.fromRgb(72,37,118),s.fromRgb(72,38,119),s.fromRgb(72,40,120),s.fromRgb(72,41,121),s.fromRgb(71,42,122),s.fromRgb(71,44,122),s.fromRgb(71,45,123),s.fromRgb(71,46,124),s.fromRgb(71,47,125),s.fromRgb(70,48,126),s.fromRgb(70,50,126),s.fromRgb(70,51,127),s.fromRgb(70,52,128),s.fromRgb(69,53,129),s.fromRgb(69,55,129),s.fromRgb(69,56,130),s.fromRgb(68,57,131),s.fromRgb(68,58,131),s.fromRgb(68,59,132),s.fromRgb(67,61,132),s.fromRgb(67,62,133),s.fromRgb(66,63,133),s.fromRgb(66,64,134),s.fromRgb(66,65,134),s.fromRgb(65,66,135),s.fromRgb(65,68,135),s.fromRgb(64,69,136),s.fromRgb(64,70,136),s.fromRgb(63,71,136),s.fromRgb(63,72,137),s.fromRgb(62,73,137),s.fromRgb(62,74,137),s.fromRgb(62,76,138),s.fromRgb(61,77,138),s.fromRgb(61,78,138),s.fromRgb(60,79,138),s.fromRgb(60,80,139),s.fromRgb(59,81,139),s.fromRgb(59,82,139),s.fromRgb(58,83,139),s.fromRgb(58,84,140),s.fromRgb(57,85,140),s.fromRgb(57,86,140),s.fromRgb(56,88,140),s.fromRgb(56,89,140),s.fromRgb(55,90,140),s.fromRgb(55,91,141),s.fromRgb(54,92,141),s.fromRgb(54,93,141),s.fromRgb(53,94,141),s.fromRgb(53,95,141),s.fromRgb(52,96,141),s.fromRgb(52,97,141),s.fromRgb(51,98,141),s.fromRgb(51,99,141),s.fromRgb(50,100,142),s.fromRgb(50,101,142),s.fromRgb(49,102,142),s.fromRgb(49,103,142),s.fromRgb(49,104,142),s.fromRgb(48,105,142),s.fromRgb(48,106,142),s.fromRgb(47,107,142),s.fromRgb(47,108,142),s.fromRgb(46,109,142),s.fromRgb(46,110,142),s.fromRgb(46,111,142),s.fromRgb(45,112,142),s.fromRgb(45,113,142),s.fromRgb(44,113,142),s.fromRgb(44,114,142),s.fromRgb(44,115,142),s.fromRgb(43,116,142),s.fromRgb(43,117,142),s.fromRgb(42,118,142),s.fromRgb(42,119,142),s.fromRgb(42,120,142),s.fromRgb(41,121,142),s.fromRgb(41,122,142),s.fromRgb(41,123,142),s.fromRgb(40,124,142),s.fromRgb(40,125,142),s.fromRgb(39,126,142),s.fromRgb(39,127,142),s.fromRgb(39,128,142),s.fromRgb(38,129,142),s.fromRgb(38,130,142),s.fromRgb(38,130,142),s.fromRgb(37,131,142),s.fromRgb(37,132,142),s.fromRgb(37,133,142),s.fromRgb(36,134,142),s.fromRgb(36,135,142),s.fromRgb(35,136,142),s.fromRgb(35,137,142),s.fromRgb(35,138,141),s.fromRgb(34,139,141),s.fromRgb(34,140,141),s.fromRgb(34,141,141),s.fromRgb(33,142,141),s.fromRgb(33,143,141),s.fromRgb(33,144,141),s.fromRgb(33,145,140),s.fromRgb(32,146,140),s.fromRgb(32,146,140),s.fromRgb(32,147,140),s.fromRgb(31,148,140),s.fromRgb(31,149,139),s.fromRgb(31,150,139),s.fromRgb(31,151,139),s.fromRgb(31,152,139),s.fromRgb(31,153,138),s.fromRgb(31,154,138),s.fromRgb(30,155,138),s.fromRgb(30,156,137),s.fromRgb(30,157,137),s.fromRgb(31,158,137),s.fromRgb(31,159,136),s.fromRgb(31,160,136),s.fromRgb(31,161,136),s.fromRgb(31,161,135),s.fromRgb(31,162,135),s.fromRgb(32,163,134),s.fromRgb(32,164,134),s.fromRgb(33,165,133),s.fromRgb(33,166,133),s.fromRgb(34,167,133),s.fromRgb(34,168,132),s.fromRgb(35,169,131),s.fromRgb(36,170,131),s.fromRgb(37,171,130),s.fromRgb(37,172,130),s.fromRgb(38,173,129),s.fromRgb(39,173,129),s.fromRgb(40,174,128),s.fromRgb(41,175,127),s.fromRgb(42,176,127),s.fromRgb(44,177,126),s.fromRgb(45,178,125),s.fromRgb(46,179,124),s.fromRgb(47,180,124),s.fromRgb(49,181,123),s.fromRgb(50,182,122),s.fromRgb(52,182,121),s.fromRgb(53,183,121),s.fromRgb(55,184,120),s.fromRgb(56,185,119),s.fromRgb(58,186,118),s.fromRgb(59,187,117),s.fromRgb(61,188,116),s.fromRgb(63,188,115),s.fromRgb(64,189,114),s.fromRgb(66,190,113),s.fromRgb(68,191,112),s.fromRgb(70,192,111),s.fromRgb(72,193,110),s.fromRgb(74,193,109),s.fromRgb(76,194,108),s.fromRgb(78,195,107),s.fromRgb(80,196,106),s.fromRgb(82,197,105),s.fromRgb(84,197,104),s.fromRgb(86,198,103),s.fromRgb(88,199,101),s.fromRgb(90,200,100),s.fromRgb(92,200,99),s.fromRgb(94,201,98),s.fromRgb(96,202,96),s.fromRgb(99,203,95),s.fromRgb(101,203,94),s.fromRgb(103,204,92),s.fromRgb(105,205,91),s.fromRgb(108,205,90),s.fromRgb(110,206,88),s.fromRgb(112,207,87),s.fromRgb(115,208,86),s.fromRgb(117,208,84),s.fromRgb(119,209,83),s.fromRgb(122,209,81),s.fromRgb(124,210,80),s.fromRgb(127,211,78),s.fromRgb(129,211,77),s.fromRgb(132,212,75),s.fromRgb(134,213,73),s.fromRgb(137,213,72),s.fromRgb(139,214,70),s.fromRgb(142,214,69),s.fromRgb(144,215,67),s.fromRgb(147,215,65),s.fromRgb(149,216,64),s.fromRgb(152,216,62),s.fromRgb(155,217,60),s.fromRgb(157,217,59),s.fromRgb(160,218,57),s.fromRgb(162,218,55),s.fromRgb(165,219,54),s.fromRgb(168,219,52),s.fromRgb(170,220,50),s.fromRgb(173,220,48),s.fromRgb(176,221,47),s.fromRgb(178,221,45),s.fromRgb(181,222,43),s.fromRgb(184,222,41),s.fromRgb(186,222,40),s.fromRgb(189,223,38),s.fromRgb(192,223,37),s.fromRgb(194,223,35),s.fromRgb(197,224,33),s.fromRgb(200,224,32),s.fromRgb(202,225,31),s.fromRgb(205,225,29),s.fromRgb(208,225,28),s.fromRgb(210,226,27),s.fromRgb(213,226,26),s.fromRgb(216,226,25),s.fromRgb(218,227,25),s.fromRgb(221,227,24),s.fromRgb(223,227,24),s.fromRgb(226,228,24),s.fromRgb(229,228,25),s.fromRgb(231,228,25),s.fromRgb(234,229,26),s.fromRgb(236,229,27),s.fromRgb(239,229,28),s.fromRgb(241,229,29),s.fromRgb(244,230,30),s.fromRgb(246,230,32),s.fromRgb(248,230,33),s.fromRgb(251,231,35),s.fromRgb(253,231,37)],xi={selectable:!0,selectionMode:Ee.All},ur=xi;class hs{constructor(t){l(this,"__oxy_element_name__"),l(this,"_parent"),l(this,"keyDown"),l(this,"mouseDown"),l(this,"mouseMove"),l(this,"mouseUp"),l(this,"touchStarted"),l(this,"touchDelta"),l(this,"touchCompleted"),l(this,"_selection"),l(this,"selectionChanged"),l(this,"selectable",xi.selectable),l(this,"selectionMode",xi.selectionMode),q(this,xi,t),this.getElementName&&(this.__oxy_element_name__=this.getElementName()),this.__oxy_element_name__||console.warn("The element name is not set. Please implement the getElementName method.")}set parent(t){this._parent=t}get parent(){return this._parent}hitTest(t){return this.hitTestOverride(t)}hitTestOverride(t){}onMouseDown(t){this.mouseDown&&this.mouseDown(this,t)}onMouseMove(t){this.mouseMove&&this.mouseMove(this,t)}onKeyDown(t){this.keyDown&&this.keyDown(this,t)}onMouseUp(t){this.mouseUp&&this.mouseUp(this,t)}onTouchStarted(t){this.touchStarted&&this.touchStarted(this,t)}onTouchDelta(t){this.touchDelta&&this.touchDelta(this,t)}onTouchCompleted(t){this.touchCompleted&&this.touchCompleted(this,t)}get actualSelectedColor(){return this.parent?F.getActualColor(this.parent.selectionColor,ds.DefaultSelectionColor):ds.DefaultSelectionColor}isSelected(){return!!this._selection}getSelectedItems(){return this.ensureSelection(),this._selection.getSelectedItems()}clearSelection(){this._selection=void 0,this.onSelectionChanged()}unselect(){this._selection=void 0,this.onSelectionChanged()}isItemSelected(t){return this._selection?t===-1?this._selection.isEverythingSelected():this._selection.isItemSelected(t):!1}select(){this._selection=Xs.Everything,this.onSelectionChanged()}selectItem(t){if(this.selectionMode===Ee.All)throw new Error("Use the select() method when using SelectionMode.All");this.ensureSelection(),this.selectionMode===Ee.Single&&this._selection.clear(),this._selection.select(t),this.onSelectionChanged()}unselectItem(t){if(this.selectionMode===Ee.All)throw new Error("Use the unselect() method when using SelectionMode.All");this.ensureSelection(),this._selection.unselect(t),this.onSelectionChanged()}getSelectableColor(t,e=-1){return F.isUndefined(t)?p.Undefined:this.isItemSelected(e)?this.actualSelectedColor:s.fromOxyColor(t).hex}getSelectableFillColor(t,e=-1){return this.getSelectableColor(t,e)}ensureSelection(){this._selection=this._selection||new Xs}onSelectionChanged(t){this.selectionChanged&&this.selectionChanged(this,t)}getJsonIgnoreProperties(){return[]}getElementDefaultValues(){return ur}toJSON(t){const e=this.getJsonIgnoreProperties(),i=this.getElementDefaultValues();return mr(this,i,{excludeKeys:e,excludeDefault:t==null?void 0:t.excludeDefault})}}const Fe={fontSize:NaN,fontWeight:$e.Normal,textColor:p.Automatic,edgeRenderingMode:tt.Automatic,font:void 0,toolTip:void 0},Ps={...ur,...Fe};class cr extends hs{constructor(t){super(t),l(this,"font"),l(this,"fontSize",Fe.fontSize),l(this,"fontWeight",Fe.fontWeight),l(this,"tag"),l(this,"textColor",Fe.textColor),l(this,"edgeRenderingMode",Fe.edgeRenderingMode),l(this,"toolTip"),l(this,"_plotElementId"),q(this,Fe,t)}get plotModel(){return this.parent}get actualFont(){return this.font||this.plotModel.defaultFont}get actualFontSize(){return j(this.fontSize)?this.plotModel.defaultFontSize:this.fontSize}get actualFontWeight(){return this.fontWeight}get actualTextColor(){return F.getActualColor(this.textColor,this.plotModel.textColor)}getClippingRect(){return Pe}getElementHashCode(){return ne(this._plotElementId)&&($s++,this._plotElementId=$s),this._plotElementId}}let $s=0;var se=(o=>(o[o.BelowAxes=0]="BelowAxes",o[o.BelowSeries=1]="BelowSeries",o[o.AboveSeries=2]="AboveSeries",o))(se||{}),gr=(o=>(o[o.Horizontal=0]="Horizontal",o[o.Vertical=1]="Vertical",o[o.AlongLine=2]="AlongLine",o))(gr||{});const uo={clipByXAxis:!0,clipByYAxis:!0,layer:se.AboveSeries,xAxisKey:void 0,yAxisKey:void 0,xAxis:void 0,yAxis:void 0},co={...Ps,...uo},go={},fo={...co,...go},bo={textHorizontalAlignment:N.Center,textVerticalAlignment:E.Middle,textPosition:vs,textRotation:0,text:void 0},xo={...fo,...bo};p.Undefined,Dt(4),p.Black,E.Bottom;const po={minimumX:W,maximumX:B,minimumY:W,maximumY:B,color:p.Blue,strokeThickness:1,lineStyle:_.Dash,lineJoin:X.Miter,textLinePosition:1,textOrientation:gr.AlongLine,textMargin:12,textHorizontalAlignment:N.Right,textVerticalAlignment:E.Top,minimumSegmentLength:2,textPadding:0,borderPadding:Fi,borderBackground:p.Undefined,borderStroke:p.Undefined,borderStrokeThickness:0},Fs={...xo,...po};({...Fs});p.LightBlue,p.Black;ct.Circle,E.Top;({...Fs});p.Blue,_.Solid,X.Miter;X.Miter,_.Solid;({...Fs});ke(.5,ce.RelativeToPlotArea),ke(.5,ce.RelativeToPlotArea),ke(0,ce.ScreenUnits),ke(0,ce.ScreenUnits),ke(NaN,ce.ScreenUnits),ke(NaN,ce.ScreenUnits),N.Center,E.Middle;const I={position:v.Left,positionTier:0,isAxisVisible:!0,layer:Ve.BelowSeries,absoluteMaximum:B,absoluteMinimum:W,minimum:Number.NaN,maximum:Number.NaN,minorStep:Number.NaN,majorStep:Number.NaN,minimumMinorStep:0,minimumMajorStep:0,minimumMajorIntervalCount:2,maximumMajorIntervalCount:B,minimumPadding:.01,maximumPadding:.01,minimumRange:0,maximumRange:Number.POSITIVE_INFINITY,minimumDataMargin:0,maximumDataMargin:0,minimumMargin:0,maximumMargin:0,tickStyle:Yt.Outside,ticklineColor:p.Black,minorTicklineColor:p.Automatic,axislineStyle:_.None,axislineColor:p.Black,axislineThickness:1,majorGridlineStyle:_.None,majorGridlineColor:F.fromArgb(64,0,0,0),majorGridlineThickness:1,minorGridlineStyle:_.None,minorGridlineColor:F.fromArgb(32,0,0,0),minorGridlineThickness:1,extraGridlineStyle:_.Solid,extraGridlineColor:p.Black,extraGridlineThickness:1,minorTickSize:4,majorTickSize:7,startPosition:0,endPosition:1,titlePosition:.5,titleFormatter:void 0,titleClippingLength:.9,titleColor:p.Automatic,titleFontSize:Number.NaN,titleFontWeight:$e.Normal,clipTitle:!0,useSuperExponentialFormat:!1,angle:0,isZoomEnabled:!0,isPanEnabled:!0,positionAtZeroCrossing:!1,intervalLength:60,cropGridlines:!1,axisTickToLabelDistance:4,axisTitleDistance:4,axisDistance:0,filterMinValue:W,filterMaxValue:B,positionTierMaxShift:0,positionTierMinShift:0,positionTierSize:0,extraGridlines:void 0,stringFormatter:void 0,title:void 0,unit:void 0,key:void 0,filterFunction:void 0,dataMaximum:void 0,dataMinimum:void 0,labelFormatter:void 0},fr={...Ps,...I},ie=class pi extends cr{constructor(t){super(t),l(this,"_offset",0),l(this,"_scale",1),l(this,"axisChanged"),l(this,"transformChanged"),l(this,"absoluteMaximum",I.absoluteMaximum),l(this,"absoluteMinimum",I.absoluteMinimum),l(this,"_actualMajorStep",0),l(this,"minimumMajorIntervalCount",I.minimumMajorIntervalCount),l(this,"maximumMajorIntervalCount",I.maximumMajorIntervalCount),l(this,"_actualMaximum",0),l(this,"_actualMinimum",0),l(this,"_clipMaximum",0),l(this,"_clipMinimum",0),l(this,"_actualMinorStep",0),l(this,"_actualStringFormatter"),l(this,"angle",I.angle),l(this,"axisTickToLabelDistance",I.axisTickToLabelDistance),l(this,"axisTitleDistance",I.axisTitleDistance),l(this,"axisDistance",I.axisDistance),l(this,"axislineColor",I.axislineColor),l(this,"axislineStyle",I.axislineStyle),l(this,"axislineThickness",I.axislineThickness),l(this,"clipTitle",I.clipTitle),l(this,"cropGridlines",I.cropGridlines),l(this,"_dataMaximum",Number.NaN),l(this,"_dataMinimum",Number.NaN),l(this,"endPosition",I.endPosition),l(this,"extraGridlineColor",I.extraGridlineColor),l(this,"extraGridlineStyle",I.extraGridlineStyle),l(this,"extraGridlineThickness",I.extraGridlineThickness),l(this,"extraGridlines"),l(this,"filterFunction"),l(this,"filterMaxValue",I.filterMaxValue),l(this,"filterMinValue",I.filterMinValue),l(this,"intervalLength",I.intervalLength),l(this,"isAxisVisible",I.isAxisVisible),l(this,"isPanEnabled",I.isAxisVisible),l(this,"isZoomEnabled",I.isZoomEnabled),l(this,"key"),l(this,"labelFormatter"),l(this,"layer",I.layer),l(this,"majorGridlineColor",I.majorGridlineColor),l(this,"majorGridlineStyle",I.majorGridlineStyle),l(this,"majorGridlineThickness",I.majorGridlineThickness),l(this,"majorStep",I.majorStep),l(this,"majorTickSize",I.majorTickSize),l(this,"maximum",I.maximum),l(this,"maximumPadding",I.maximumPadding),l(this,"maximumDataMargin",I.maximumDataMargin),l(this,"maximumMargin",I.maximumMargin),l(this,"maximumRange",I.maximumRange),l(this,"minimum",I.minimum),l(this,"minimumMajorStep",I.minimumMajorStep),l(this,"minimumMinorStep",I.minimumMinorStep),l(this,"minimumPadding",I.minimumPadding),l(this,"minimumDataMargin",I.minimumDataMargin),l(this,"minimumMargin",I.minimumMargin),l(this,"minimumRange",I.minimumRange),l(this,"minorGridlineColor",I.minorGridlineColor),l(this,"minorGridlineStyle",I.minorGridlineStyle),l(this,"minorGridlineThickness",I.minorGridlineThickness),l(this,"minorStep",I.majorStep),l(this,"minorTicklineColor",I.minorTicklineColor),l(this,"minorTickSize",I.minorTickSize),l(this,"position",I.position),l(this,"positionAtZeroCrossing",I.positionAtZeroCrossing),l(this,"positionTier",I.positionTier),l(this,"_screenMax",Ci),l(this,"_screenMin",Ci),l(this,"startPosition",I.startPosition),l(this,"stringFormatter"),l(this,"tickStyle",I.tickStyle),l(this,"ticklineColor",I.ticklineColor),l(this,"title"),l(this,"titleClippingLength",I.titleClippingLength),l(this,"titleColor",I.titleColor),l(this,"titleFont"),l(this,"titleFontSize",I.titleFontSize),l(this,"titleFontWeight",I.titleFontWeight),l(this,"titleFormatter",I.titleFormatter),l(this,"titlePosition",I.titlePosition),l(this,"unit"),l(this,"useSuperExponentialFormat",I.useSuperExponentialFormat),l(this,"_desiredMargin",Fi),l(this,"positionTierMaxShift",I.positionTierMaxShift),l(this,"positionTierMinShift",I.positionTierMinShift),l(this,"positionTierSize",I.positionTierSize),l(this,"viewMaximum",Number.NaN),l(this,"viewMinimum",Number.NaN),this.titleFormatter=pi.DefaultTitleFormatter,it(this,"titleFormatter",t),it(this,"stringFormatter",t),it(this,"labelFormatter",t),q(this,I,t,{exclude:["titleFormatter","stringFormatter","labelFormatter"]}),j(this.maximumRange)&&(this.maximumRange=I.maximumRange)}get actualMajorStep(){return this._actualMajorStep}set actualMajorStep(t){this._actualMajorStep=t}get actualMaximum(){return this._actualMaximum}set actualMaximum(t){this._actualMaximum=t}get actualMinimum(){return this._actualMinimum}set actualMinimum(t){this._actualMinimum=t}get clipMaximum(){return this._clipMaximum}set clipMaximum(t){this._clipMaximum=t}get clipMinimum(){return this._clipMinimum}set clipMinimum(t){this._clipMinimum=t}get actualMinorStep(){return this._actualMinorStep}set actualMinorStep(t){this._actualMinorStep=t}get actualStringFormatter(){return this._actualStringFormatter}set actualStringFormatter(t){this._actualStringFormatter=t}get actualTitle(){return this.unit?`${this.title} [${this.unit}]`:this.title}get dataMaximum(){return this._dataMaximum}set dataMaximum(t){this._dataMaximum=t}get dataMinimum(){return this._dataMinimum}set dataMinimum(t){this._dataMinimum=t}get isReversed(){return this.startPosition>this.endPosition}get offset(){return this._offset}get scale(){return this._scale}get screenMax(){return this._screenMax}set screenMax(t){this._screenMax=t}get screenMin(){return this._screenMin}set screenMin(t){this._screenMin=t}get desiredMargin(){return this._desiredMargin}set desiredMargin(t){this._desiredMargin=t}get actualTitleColor(){return F.getActualColor(this.titleColor,this.plotModel.textColor)}get actualTitleFont(){return this.titleFont||this.plotModel.defaultFont}get actualTitleFontSize(){return j(this.titleFontSize)?this.actualFontSize:this.titleFontSize}get actualTitleFontWeight(){return j(this.titleFontWeight)?this.actualFontWeight:this.titleFontWeight}itemToDouble(t){return Number(t)}static inverseTransform(t,e,i){return e.inverseTransformPoint(t.x,t.y,i)}formatValue(t){return this.labelFormatter?this.labelFormatter(t):this.formatValueOverride(t)}getTickValues(){const t=[],e=[],i=[],r=this.createTickValues(this.clipMinimum,this.clipMaximum,this.actualMinorStep);return e.push(...this.createTickValues(this.clipMinimum,this.clipMaximum,this.actualMajorStep)),t.push(...e),i.push(...si.filterRedundantMinorTicks(e,r)),{majorLabelValues:t,majorTickValues:e,minorTickValues:i}}getValue(t){return t}inverseTransformPoint(t,e,i){return $(this.inverseTransform(t),i?i.inverseTransform(e):0)}inverseTransform(t){return t/this._scale+this._offset}isHorizontal(){return this.position===v.Top||this.position===v.Bottom}isValidValue(t){return Number.isFinite(t)&&t<this.filterMaxValue&&t>this.filterMinValue&&(!this.filterFunction||this.filterFunction(t))}isVertical(){return this.position===v.Left||this.position===v.Right}isLogarithmic(){return!1}measure(t){if(this.position===v.None){this.desiredMargin=Dt(0);return}const{majorLabelValues:e}=this.getTickValues();let i=at();for(const f of e){const d=this.formatValue(f),b=O.measureText(t,d,this.actualFont,this.actualFontSize,this.actualFontWeight,this.angle);i=Ni.include(i,b)}const r=t.measureText(this.actualTitle||"",this.actualTitleFont,this.actualTitleFontSize,this.actualTitleFontWeight);let n=0,a=0,h=0,m=0;const u=Math.max(0,this.isReversed?this.maximumMargin:this.minimumMargin),c=Math.max(0,this.isReversed?this.minimumMargin:this.maximumMargin);let g=0;switch(this.tickStyle){case Yt.Outside:g=this.majorTickSize;break;case Yt.Crossing:g=this.majorTickSize*.75;break}switch(g+=this.axisDistance+this.axisTickToLabelDistance,r.height>0&&(g+=this.axisTitleDistance+r.height),this.position){case v.Left:n=g+i.width;break;case v.Right:h=g+i.width;break;case v.Top:a=g+i.height;break;case v.Bottom:m=g+i.height;break;case v.All:n=h=g+i.width,a=m=g+i.height;break;default:throw new Error("Invalid operation")}if(this.isPanEnabled||this.isZoomEnabled){const f=Math.min(this.startPosition,this.endPosition)<.01,d=Math.max(this.startPosition,this.endPosition)>.99;switch(this.position){case v.Left:case v.Right:f&&(m=Math.max(0,i.height/2-u)),d&&(a=Math.max(0,i.height/2-c));break;case v.Top:case v.Bottom:f&&(n=Math.max(0,i.width/2-u)),d&&(h=Math.max(0,i.width/2-c));break}}else if(e.length>0){const f=Math.min(...e),d=Math.max(...e),b=this.formatValue(f),x=this.formatValue(d);let R=O.measureText(t,b,this.actualFont,this.actualFontSize,this.actualFontWeight,this.angle),M=O.measureText(t,x,this.actualFont,this.actualFontSize,this.actualFontWeight,this.angle),S=this.transform(f),T=this.transform(d);S>T&&([S,T]=[T,S],[R,M]=[M,R]);let A=0,P=0,C=0,D=0;switch(this.position){case v.Left:case v.Right:A=Math.min(this.screenMin.y,this.screenMax.y),P=Math.max(this.screenMin.y,this.screenMax.y),a=Math.max(0,A-S+R.height/2-u),m=Math.max(0,T-P+M.height/2-c);break;case v.Top:case v.Bottom:C=Math.min(this.screenMin.x,this.screenMax.x),D=Math.max(this.screenMin.x,this.screenMax.x),n=Math.max(0,C-S+R.width/2-u),h=Math.max(0,T-D+M.width/2-c);break}}this.desiredMargin=Dt(n,a,h,m)}pan(t,e){if(typeof t=="number"){this.pan2(t);return}this.pan1(t,e)}pan1(t,e){if(!this.isPanEnabled)return;const i=this.isHorizontal()?e.x-t.x:e.y-t.y;this.pan(i)}pan2(t){if(!this.isPanEnabled)return;const e=this.actualMinimum,i=this.actualMaximum,r=t/this._scale;let n=this.actualMinimum-r,a=this.actualMaximum-r;n<this.absoluteMinimum&&(n=this.absoluteMinimum,a=Math.min(n+this.actualMaximum-this.actualMinimum,this.absoluteMaximum)),a>this.absoluteMaximum&&(a=this.absoluteMaximum,n=Math.max(a-(this.actualMaximum-this.actualMinimum),this.absoluteMinimum)),this.viewMinimum=n,this.viewMaximum=a,this.updateActualMaxMin();const h=this.actualMinimum-e,m=this.actualMaximum-i;this.onAxisChanged({changeType:Ce.Pan,deltaMaximum:m,deltaMinimum:h})}async render(t,e){this.position!==v.None&&await new de(t,this.plotModel).render(this,e)}reset(){const t=this.actualMinimum,e=this.actualMaximum;this.viewMinimum=NaN,this.viewMaximum=NaN,this.updateActualMaxMin();const i=this.actualMinimum-t,r=this.actualMaximum-e;this.onAxisChanged({changeType:Ce.Reset,deltaMinimum:i,deltaMaximum:r})}toString(){return`${this.constructor.name}(${this.position}, ${this.clipMinimum}, ${this.clipMaximum}, ${this.actualMajorStep})`}transformPoint(t,e,i){if(!i)throw new Error("Y axis should not be null when transforming.");return y(this.transform(t),i.transform(e))}transform(t){return(t-this._offset)*this._scale}zoomScale(t){const e=this.actualMinimum,i=this.actualMaximum,r=this.transform(this.actualMaximum),n=this.transform(this.actualMinimum),a=Math.sign(this._scale),h=(this.preTransform(this.actualMaximum)+this.preTransform(this.actualMinimum))/2,m=(this._offset-h)*this._scale/(a*t)+h;this.setTransform(a*t,m);let u=this.inverseTransform(r),c=this.inverseTransform(n);if(c<this.absoluteMinimum&&u>this.absoluteMaximum)c=this.absoluteMinimum,u=this.absoluteMaximum;else if(c<this.absoluteMinimum){const d=u-c;c=this.absoluteMinimum,u=this.absoluteMinimum+d,u>this.absoluteMaximum&&(u=this.absoluteMaximum)}else if(u>this.absoluteMaximum){const d=u-c;u=this.absoluteMaximum,c=this.absoluteMaximum-d,c<this.absoluteMinimum&&(c=this.absoluteMinimum)}this.clipMaximum=this.viewMaximum=u,this.clipMinimum=this.viewMinimum=c,this.updateActualMaxMin();const g=this.actualMinimum-e,f=this.actualMaximum-i;this.actualMaximumAndMinimumChangedOverride(),this.onAxisChanged({changeType:Ce.Zoom,deltaMinimum:g,deltaMaximum:f})}zoom(t,e){if(!this.isZoomEnabled)return;const i=this.actualMinimum,r=this.actualMaximum,n=Math.max(Math.min(t,e),this.absoluteMinimum),a=Math.min(Math.max(t,e),this.absoluteMaximum);this.viewMinimum=n,this.viewMaximum=a,this.updateActualMaxMin();const h=this.actualMinimum-i,m=this.actualMaximum-r;this.onAxisChanged({changeType:Ce.Zoom,deltaMinimum:h,deltaMaximum:m})}zoomAt(t,e){if(!this.isZoomEnabled)return;const i=this.actualMinimum,r=this.actualMaximum,n=(this.actualMinimum-e)*this._scale,a=(this.actualMaximum-e)*this._scale;this._scale*=t;let h=n/this._scale+e,m=a/this._scale+e;if(m-h>this.maximumRange){const g=(h+m)*.5;m=g+this.maximumRange*.5,h=g-this.maximumRange*.5}if(m-h<this.minimumRange){const g=(h+m)*.5;m=g+this.minimumRange*.5,h=g-this.minimumRange*.5}h=Math.max(h,this.absoluteMinimum),m=Math.min(m,this.absoluteMaximum),this.viewMinimum=h,this.viewMaximum=m,this.updateActualMaxMin();const u=this.actualMinimum-i,c=this.actualMaximum-r;this.onAxisChanged({changeType:Ce.Zoom,deltaMinimum:u,deltaMaximum:c})}zoomAtCenter(t){const e=(this.transform(this.clipMaximum)+this.transform(this.clipMinimum))*.5,i=this.inverseTransform(e);this.zoomAt(t,i)}include(t){this.isValidValue(t)&&(this.dataMinimum=j(this.dataMinimum)?t:Math.min(this.dataMinimum,t),this.dataMaximum=j(this.dataMaximum)?t:Math.max(this.dataMaximum,t))}resetDataMaxMin(){this.dataMaximum=this.dataMinimum=this.actualMaximum=this.actualMinimum=NaN}updateActualMaxMin(){j(this.viewMaximum)?j(this.maximum)?this.actualMaximum=this.calculateActualMaximum():this.actualMaximum=this.maximum:this.actualMaximum=this.viewMaximum,j(this.viewMinimum)?j(this.minimum)?this.actualMinimum=this.calculateActualMinimum():this.actualMinimum=this.minimum:this.actualMinimum=this.viewMinimum,this.coerceActualMaxMin()}updateIntervals(t){const e=this.intervalLength;let i=this.isHorizontal()?t.width:t.height;i*=Math.abs(this.endPosition-this.startPosition),this.actualMajorStep=j(this.majorStep)?this.calculateActualInterval(i,e,this.minimumMajorIntervalCount,this.maximumMajorIntervalCount):this.majorStep,this.actualMinorStep=j(this.minorStep)?this.calculateMinorInterval(this.actualMajorStep):this.minorStep,j(this.actualMinorStep)&&(this.actualMinorStep=2),j(this.actualMajorStep)&&(this.actualMajorStep=10),this.actualMinorStep=Math.max(this.actualMinorStep,this.minimumMinorStep),this.actualMajorStep=Math.max(this.actualMajorStep,this.minimumMajorStep),this.actualStringFormatter=this.stringFormatter||this.getDefaultStringFormatter()}updateTransform(t){const e=t.left,i=w.right(t),r=w.bottom(t),n=t.top;let a=this.isHorizontal()?e:r,h=this.isHorizontal()?i:n;const m=h-a;h=a+this.endPosition*m,a=a+this.startPosition*m;const u=this.isHorizontal()!=this.isReversed?1:-1;this.minimumMargin>0&&(a+=this.minimumMargin*u),this.maximumMargin>0&&(h-=this.maximumMargin*u),this.isHorizontal()?(this.screenMin=y(a,n),this.screenMax=y(h,r)):this.isVertical()&&(this.screenMin=y(e,h),this.screenMax=y(i,a)),this.minimumDataMargin>0&&(a+=this.minimumDataMargin*u),this.maximumDataMargin>0&&(h-=this.maximumDataMargin*u),this.actualMaximum-this.actualMinimum<=0&&(this.actualMaximum=this.actualMinimum+1);const c=this.preTransform(this.actualMaximum),g=this.preTransform(this.actualMinimum),f=a-h;let d,b;Math.abs(f)>Number.EPSILON?d=a/f*c-h/f*g:d=0;const x=c-g;Math.abs(x)>Number.EPSILON?b=(h-a)/x:b=1,this.setTransform(b,d),this.minimumDataMargin>0?this.clipMinimum=this.inverseTransform(a-this.minimumDataMargin*u):this.clipMinimum=this.actualMinimum,this.maximumDataMargin>0?this.clipMaximum=this.inverseTransform(h+this.maximumDataMargin*u):this.clipMaximum=this.actualMaximum,this.actualMaximumAndMinimumChangedOverride()}actualMaximumAndMinimumChangedOverride(){}getDefaultStringFormatter(){return t=>no(t,4)}postInverseTransform(t){return t}preTransform(t){return t}calculateMinorInterval(t){return si.calculateMinorInterval(t)}createTickValues(t,e,i,r=1e3){return si.createTickValues(t,e,i,r)}coerceActualMaxMin(){if(this.absoluteMaximum<=this.absoluteMinimum)throw new Error("AbsoluteMaximum must be larger than AbsoluteMinimum.");if(this.absoluteMaximum-this.absoluteMinimum<this.minimumRange)throw new Error("MinimumRange must not be larger than AbsoluteMaximum-AbsoluteMinimum.");if(this.maximumRange<this.minimumRange)throw new Error("MinimumRange must not be larger than MaximumRange.");if((j(this.actualMinimum)||xe(this.actualMinimum))&&(this.actualMinimum=0),(j(this.actualMaximum)||xe(this.actualMaximum))&&(this.actualMaximum=100),this.absoluteMinimum>W&&this.absoluteMinimum<B&&(this.actualMinimum=Math.max(this.actualMinimum,this.absoluteMinimum),this.maximumRange<B&&(this.actualMaximum=Math.min(this.actualMaximum,this.absoluteMinimum+this.maximumRange))),this.absoluteMaximum>W&&this.absoluteMaximum<B&&(this.actualMaximum=Math.min(this.actualMaximum,this.absoluteMaximum),this.maximumRange<B&&(this.actualMinimum=Math.max(this.actualMinimum,this.absoluteMaximum-this.maximumRange))),this.actualMaximum-this.actualMinimum<this.minimumRange)if(this.actualMinimum+this.minimumRange<this.absoluteMaximum){const t=(this.actualMaximum+this.actualMinimum)*.5,e=this.minimumRange/2;if(this.actualMinimum=t-e,this.actualMaximum=t+e,this.actualMinimum<this.absoluteMinimum){const i=this.absoluteMinimum-this.actualMinimum;this.actualMinimum=this.absoluteMinimum,this.actualMaximum+=i}if(this.actualMaximum>this.absoluteMaximum){const i=this.absoluteMaximum-this.actualMaximum;this.actualMaximum=this.absoluteMaximum,this.actualMinimum+=i}}else this.absoluteMaximum-this.minimumRange>this.absoluteMinimum?(this.actualMinimum=this.absoluteMaximum-this.minimumRange,this.actualMaximum=this.absoluteMaximum):(this.actualMaximum=this.absoluteMaximum,this.actualMinimum=this.absoluteMinimum);if(this.actualMaximum-this.actualMinimum>this.maximumRange)if(this.actualMinimum+this.maximumRange<this.absoluteMaximum){const t=(this.actualMaximum+this.actualMinimum)*.5,e=this.maximumRange/2;if(this.actualMinimum=t-e,this.actualMaximum=t+e,this.actualMinimum<this.absoluteMinimum){const i=this.absoluteMinimum-this.actualMinimum;this.actualMinimum=this.absoluteMinimum,this.actualMaximum+=i}if(this.actualMaximum>this.absoluteMaximum){const i=this.absoluteMaximum-this.actualMaximum;this.actualMaximum=this.absoluteMaximum,this.actualMinimum+=i}}else this.absoluteMaximum-this.maximumRange>this.absoluteMinimum?(this.actualMinimum=this.absoluteMaximum-this.maximumRange,this.actualMaximum=this.absoluteMaximum):(this.actualMaximum=this.absoluteMaximum,this.actualMinimum=this.absoluteMinimum);this.actualMaximum<=this.actualMinimum&&(this.actualMaximum=this.actualMinimum+100)}formatValueOverride(t){let e=this.stringFormatter;if(this.useSuperExponentialFormat&&t!==0){const i=pi.Exponent(t),r=pi.Mantissa(t);if(e){if(typeof e=="function")return`${e(t)}·10^{${i}}`}else return Math.abs(r-1)<1e-6?`10^{${i}}`:`${r}·10^{${i}}`;throw new Error("invalid stringFormat")}if(e=this.actualStringFormatter||this.stringFormatter,typeof e=="function")return e(t);if(!e)return t.toString();throw new Error("invalid stringFormat")}calculateActualMaximum(){let t=this.dataMaximum;if(this.dataMaximum-this.dataMinimum<=0){const e=this.dataMaximum>0?this.dataMaximum:1;t+=e*.5}if(!j(this.dataMinimum)&&!j(t)){const e=this.preTransform(t),i=this.preTransform(this.dataMinimum),r=this.maximumPadding*(e-i);return this.postInverseTransform(e+r)}return t}calculateActualMinimum(){let t=this.dataMinimum;if(this.dataMaximum-this.dataMinimum<=0){const e=this.dataMaximum>0?this.dataMaximum:1;t-=e*.5}if(!j(this.actualMaximum)){const e=this.preTransform(this.actualMaximum),i=this.preTransform(t),r=this.maximumPadding,n=this.minimumPadding*((e-i)/(1+r));return this.postInverseTransform(i-n)}return t}setTransform(t,e){this._scale=t,this._offset=e,this.onTransformChanged()}calculateActualInterval(t,e,i,r,n){if(J(n)&&(n=Math.abs(this.clipMinimum-this.clipMaximum)),t<=0)return e;if(Math.abs(e)<=0)throw new Error("Maximum interval size cannot be zero.");if(Math.abs(n)<=0)throw new Error("Range cannot be zero.");const a=g=>Math.ceil(Math.log10(g)),h=g=>g/Math.pow(10,a(g)-1);i=Math.max(i,0),r=Math.min(r,t/e),n=Math.abs(n);let m=Math.pow(10,a(n)),u=m;const c=g=>parseFloat(g.toPrecision(14));for(;h(u)===5?u=c(u/2.5):u=c(u/2),!(n/m>=i&&n/u>r||j(u)||xe(u));)m=u;return m}onAxisChanged(t){this.updateActualMaxMin();const e=this.axisChanged;e&&e(this,t)}onTransformChanged(){const t=this.transformChanged;t&&t(this)}getJsonIgnoreProperties(){return[...super.getJsonIgnoreProperties(),"viewMaximum","viewMinimum","positionTierMaxShift","positionTierMinShift","positionTierSize"]}};l(ie,"DefaultTitleFormatter",function(o,t){return`${o||""} [${t||""}]`}),l(ie,"Exponent",o=>Math.floor(ie.ThresholdRound(Math.log(Math.abs(o))/Math.LN10))),l(ie,"Mantissa",o=>ie.ThresholdRound(o/Math.pow(10,ie.Exponent(o)))),l(ie,"ThresholdRound",o=>Math.abs(Math.round(o)-o)<1e-6?Math.round(o):o);let dr=ie;const Mi={fractionUnit:1,formatAsFractions:!1,fractionUnitSymbol:void 0},me={...fr,...Mi};class le extends dr{constructor(t){super(t),l(this,"formatAsFractions",Mi.formatAsFractions),l(this,"fractionUnit",Mi.fractionUnit),l(this,"fractionUnitSymbol"),q(this,Mi,t)}getElementName(){return"LinearAxis"}isXyAxis(){return!0}isLogarithmic(){return!1}formatValueOverride(t){return this.formatAsFractions?In.convertToFractionString(t,this.fractionUnit,this.fractionUnitSymbol,1e-6,this.stringFormatter):super.formatValueOverride(t)}getElementDefaultValues(){return me}}const Ri={position:v.All,tickStyle:Yt.None,isPanEnabled:!1,isZoomEnabled:!1,majorGridlineStyle:_.Solid,minorGridlineStyle:_.Solid,startAngle:0,endAngle:360},Mo={...me,...Ri};class ii extends le{constructor(t){super(t),l(this,"startAngle",Ri.startAngle),l(this,"endAngle",Ri.endAngle),q(this,Ri,t)}getElementName(){return"AngleAxis"}getTickValues(){const t=this.startAngle/this.scale,e=this.endAngle/this.scale;let i=this.createTickValues(t,e,this.actualMinorStep);const r=this.createTickValues(t,e,this.actualMajorStep),n=this.createTickValues(this.minimum,this.maximum,this.actualMajorStep);return i=si.filterRedundantMinorTicks(r,i),{majorLabelValues:n,majorTickValues:r,minorTickValues:i}}inverseTransformPoint(t,e,i){throw new Error("Angle axis should always be the y-axis.")}isXyAxis(){return!1}async render(t,e){await new Ro(t,this.plotModel).render(this,e)}transformPoint(t,e,i){throw new Error("Angle axis should always be the y-axis.")}updateTransform(t){const e=t.left,i=w.right(t),r=w.bottom(t),n=t.top;this.screenMin=y(e,n),this.screenMax=y(i,r);const a=(this.endAngle-this.startAngle)/(this.actualMaximum-this.actualMinimum),h=this.actualMinimum-this.startAngle/a;this.setTransform(a,h),this.clipMinimum=this.actualMinimum,this.clipMaximum=this.actualMaximum}getElementDefaultValues(){return Mo}}class si{static calculateMinorInterval(t){return Math.abs((Math.log10(t)+1e3)%1-Math.log10(2))<1e-10?t/4:t/5}static calculateMinorInterval2(t){const e=Math.ceil(Math.log(t)/Math.LN10);return(t/Math.pow(10,e-1)|0)===2?t/4:t/5}static createTickValues(t,e,i,r=1e3){if(i<=0)throw new Error("Step cannot be zero or negative.");e<t&&(i=-i);const n=i*.001;t-=n,e+=n;let a=Math.ceil(t/i)*i;Math.abs(a)<Number.EPSILON&&(a=0);const h=[],m=Math.sign(i);let u=0,c=a;for(;(e-c)*m>=0&&u<r;)h.push(c),c=a+ ++u*i;return h}static filterRedundantMinorTicks(t,e){if(t.length===0||e.length===0)return e;const i=[];let r=0,n=1,a=t.length>1?t[n]:t[0];const h=(c,g)=>Math.abs(c-g)*.001;let m=e.length>1?h(e[0],e[1]):0,u=1;t.length>1&&t[0]>t[1]&&(u=-1);for(let c=0;c<e.length;c++){const g=e[c];for(c>0&&(m=h(g,r));(a-g)*u<0&&n<t.length-1;)a=t[++n];const f=t[n-1];Math.abs(g-a)>m&&Math.abs(g-f)>m&&i.push(g),r=g}return i}}const yi={isTickCentered:!1,tickStyle:Yt.Outside,position:v.Bottom,minimumPadding:0,maximumPadding:0,majorStep:1,gapWidth:1,itemsSource:void 0,labelField:void 0},br={...me,...yi};class Ke extends le{constructor(t){super(t),l(this,"_autoGeneratedLabels",[]),l(this,"_itemsSourceLabels",[]),l(this,"gapWidth",yi.gapWidth),l(this,"isTickCentered",yi.isTickCentered),l(this,"itemsSource"),l(this,"labelField"),l(this,"_labels",[]),t!=null&&t.labels&&(this._labels=t.labels,delete t.labels),q(this,yi,t)}getElementName(){return"CategoryAxis"}get actualLabels(){return this.itemsSource?this._itemsSourceLabels:this.labels.length>0?this.labels:this._autoGeneratedLabels}get labels(){return this._labels}getTickValues(){const{majorLabelValues:t,majorTickValues:e,minorTickValues:i}=super.getTickValues();if(i.length=0,!this.isTickCentered){let r=[];if(r=t.map(n=>n-.5).filter(n=>n>this.clipMinimum-.001),r.length>0){const n=r[r.length-1]+this.majorStep;n<this.clipMaximum+.001&&r.push(n)}e.length=0,e.push(...r)}return{majorLabelValues:t,majorTickValues:e,minorTickValues:i}}getValue(t){return this.formatValue(t)}updateActualMaxMin(){this.include(-.5);const t=this.actualLabels;t.length>0?this.include(t.length-1+.5):this.include(.5),super.updateActualMaxMin(),this.minorStep=1}updateLabels(t){if(this.itemsSource){this._itemsSourceLabels.length=0;const e=[];for(let i of this.itemsSource||[])i=this.labelField?i[this.labelField]:i,this.stringFormatter?e.push(this.stringFormatter(i)):e.push(i.toString());this._itemsSourceLabels.push(...e);return}if(this.labels.length===0){if(this._autoGeneratedLabels.length===t)return;this._autoGeneratedLabels.length=0,this._autoGeneratedLabels.push(...Array.from({length:t},(e,i)=>(i+1).toString()))}}formatValueOverride(t){const e=Math.floor(t),i=this.actualLabels;return e>=0&&e<i.length?i[e]:""}getElementDefaultValues(){return br}toJSON(t){const e=super.toJSON(t);return this._labels.length>0&&(e.labels=this._labels),e}}function Zi(o){return o&&typeof o.getColor=="function"&&typeof o.getPaletteIndex=="function"}const ms={midPoint:te,position:v.None,isPanEnabled:!1,isZoomEnabled:!1,majorGridlineStyle:_.Solid,minorGridlineStyle:_.Solid},xr={...me,...ms};class Ji extends le{constructor(t){super(t),l(this,"midPoint",ms.midPoint),q(this,ms,t)}getElementName(){return"MagnitudeAxis"}inverseTransformPoint(t,e,i){if(!(i instanceof ii))throw new Error("Polar angle axis not defined!");const r=i;t-=this.midPoint.x,e-=this.midPoint.y,e*=-1;const n=Math.atan2(e,t);return t=Math.sqrt(t*t+e*e)/this.scale+this.offset,e=n/r.scale+r.offset*Math.PI/180,$(t,e)}isXyAxis(){return!1}async render(t,e){await new Vi(t,this.plotModel).render(this,e)}transformPoint(t,e,i){if(!(i instanceof ii))throw new Error("Polar angle axis not defined!");const r=i,n=(t-this.offset)*this.scale,a=(e-r.offset)*r.scale;return y(this.midPoint.x+n*Math.cos(a/180*Math.PI),this.midPoint.y-n*Math.sin(a/180*Math.PI))}updateTransform(t){const e=t.left,i=w.right(t),r=w.bottom(t),n=t.top;this.screenMin=y(e,n),this.screenMax=y(i,r),this.midPoint=y((e+i)/2,(r+n)/2);const a=Math.min(Math.abs(i-e),Math.abs(n-r));let h=0,m=a*.5;const u=m-h;m=h+this.endPosition*u,h=h+this.startPosition*u;const c=this.isReversed?-1:1;this.minimumMargin>0&&(h+=this.minimumMargin*c),this.maximumMargin>0&&(m-=this.maximumMargin*c),this.minimumDataMargin>0&&(h+=this.minimumDataMargin*c),this.maximumDataMargin>0&&(m-=this.maximumDataMargin*c),this.actualMaximum-this.actualMinimum<=0&&(this.actualMaximum=this.actualMinimum+1);const g=this.preTransform(this.actualMaximum),f=this.preTransform(this.actualMinimum),d=h-m;let b,x;Math.abs(d)>Number.EPSILON?b=h/d*g-m/d*f:b=0;const R=g-f;Math.abs(R)>Number.EPSILON?x=(m-h)/R:x=1,this.setTransform(x,b),this.minimumDataMargin>0?this.clipMinimum=this.inverseTransform(0):this.clipMinimum=this.actualMinimum,this.maximumDataMargin>0?this.clipMaximum=this.inverseTransform(a*.5):this.clipMaximum=this.actualMaximum,this.actualMaximumAndMinimumChangedOverride()}getElementDefaultValues(){return xr}}class Bi{constructor(t,e){l(this,"_plot"),l(this,"rc"),l(this,"minorTickValues",[]),l(this,"axislinePen"),l(this,"extraPen"),l(this,"majorLabelValues",[]),l(this,"majorPen"),l(this,"majorTickPen"),l(this,"majorTickValues",[]),l(this,"minorPen"),l(this,"minorTickPen"),l(this,"zeroPen"),this._plot=e,this.rc=t}get plot(){return this._plot}get renderContext(){return this.rc}async render(t,e){if(!t)return;const{majorLabelValues:i,majorTickValues:r,minorTickValues:n}=t.getTickValues();this.majorLabelValues=i,this.majorTickValues=r,this.minorTickValues=n,this.createPens(t)}createPens(t){const e=F.isAutomatic(t.minorTicklineColor)?t.ticklineColor:t.minorTicklineColor;this.minorPen=Kt.create(t.minorGridlineColor,t.minorGridlineThickness,t.minorGridlineStyle),this.majorPen=Kt.create(t.majorGridlineColor,t.majorGridlineThickness,t.majorGridlineStyle),this.minorTickPen=Kt.create(e,t.minorGridlineThickness),this.majorTickPen=Kt.create(t.ticklineColor,t.majorGridlineThickness),this.zeroPen=Kt.create(t.ticklineColor,t.majorGridlineThickness),this.extraPen=Kt.create(t.extraGridlineColor,t.extraGridlineThickness,t.extraGridlineStyle),this.axislinePen=Kt.create(t.axislineColor,t.axislineThickness,t.axislineStyle)}getTickPositions(t,e,i,r){let n=0,a=0;const h=r===v.Top||r===v.Left?-1:1;switch(e){case Yt.Crossing:n=-i*h*.75,a=i*h*.75;break;case Yt.Inside:n=-i*h;break;case Yt.Outside:a=i*h;break}return[n,a]}isWithin(t,e,i){return t<e?!1:t<=i}}class de extends Bi{constructor(t,e){super(t,e)}async render(t,e){await super.render(t,e);let i=!0;const r=t.axisDistance+t.positionTierMinShift,n=t.positionTierSize-this.plot.axisTierDistance,a=this.plot.plotArea.left,h=w.right(this.plot.plotArea),m=this.plot.plotArea.top,u=w.bottom(this.plot.plotArea);let c=0,g=0;switch(t.position){case v.Left:c=a-r;break;case v.Right:c=h+r;break;case v.Top:c=m-r;break;case v.Bottom:c=u+r;break}if(t.positionAtZeroCrossing){const f=t.isHorizontal()?this.plot.defaultYAxis:this.plot.defaultXAxis;c=f.transform(0);const d=t.isHorizontal()?f.screenMin.y:f.screenMin.x,b=t.isHorizontal()?f.screenMax.y:f.screenMax.x;let x=Math.min(d,b),R=Math.max(d,b);const M=t.isHorizontal()?m:a,S=t.isHorizontal()?u:h;if(x=Math.max(x,M),R=Math.min(R,S),c<x){c=x;const T=t.isHorizontal()?this.plot.plotAreaBorderThickness.top:this.plot.plotAreaBorderThickness.left,A=t.isHorizontal()?this.plot.plotArea.top:this.plot.plotArea.left;c<=A&&T>0&&F.isVisible(this.plot.plotAreaBorderColor)&&(i=!1)}if(c>R){c=R;const T=t.isHorizontal()?this.plot.plotAreaBorderThickness.bottom:this.plot.plotAreaBorderThickness.right,A=t.isHorizontal()?u:h;c>=A&&T>0&&F.isVisible(this.plot.plotAreaBorderColor)&&(i=!1)}}switch(t.position){case v.Left:g=c-n;break;case v.Right:g=c+n;break;case v.Top:g=c-n;break;case v.Bottom:g=c+n;break}switch(t.position){case v.Left:case v.Top:g+=t.axisDistance;break;case v.Right:case v.Bottom:g-=t.axisDistance;break}e==0&&await this.renderMinorItems(t,c),e==1&&(await this.renderMajorItems(t,c,g,i),await this.renderAxisTitle(t,g))}static lerp(t,e,i){return t*(1-i)+e*i}static snapTo(t,e,i=.5){return e>t-i&&e<t+i?t:e}getAxisTitlePositionAndAlignment(t,e){let i=-90,r=N.Center,n=E.Top,a=t.isHorizontal()?de.lerp(t.screenMin.x,t.screenMax.x,t.titlePosition):de.lerp(t.screenMax.y,t.screenMin.y,t.titlePosition);t.positionAtZeroCrossing&&(a=de.lerp(t.transform(t.clipMaximum),t.transform(t.clipMinimum),t.titlePosition));let h=te;switch(t.position){case v.Left:h=y(e,a);break;case v.Right:n=E.Bottom,h=y(e,a);break;case v.Top:r=N.Center,n=E.Top,i=0,h=y(a,e);break;case v.Bottom:r=N.Center,n=E.Bottom,i=0,h=y(a,e);break;default:throw new Error("Invalid axis position")}return{point:h,angle:i,halign:r,valign:n}}async renderAxisTitle(t,e){if(!t.actualTitle)return;const i=t.isHorizontal();let r;if(t.clipTitle){const u=Math.abs(i?t.screenMax.x-t.screenMin.x:t.screenMax.y-t.screenMin.y);r=at(u*t.titleClippingLength,B)}const{point:n,angle:a,halign:h,valign:m}=this.getAxisTitlePositionAndAlignment(t,e);await pe.drawMathText(this.renderContext,n,t.actualTitle,t.actualTitleColor,t.actualTitleFont,t.actualTitleFontSize,t.actualTitleFontWeight,a,h,m,r)}async renderMajorItems(t,e,i,r){const n=t.actualMinorStep*.001,a=t.clipMinimum,h=t.clipMaximum,m=this.plot.plotArea.left,u=w.right(this.plot.plotArea),c=this.plot.plotArea.top,g=w.bottom(this.plot.plotArea),f=t.isHorizontal(),d=t.cropGridlines,b=[],x=[],[R,M]=this.getTickPositions(t,t.tickStyle,t.majorTickSize,t.position),S=t.isHorizontal()?this.plot.defaultYAxis:this.plot.defaultXAxis,T=t.positionAtZeroCrossing&&(S==null?void 0:S.positionAtZeroCrossing);let A=[];d&&(f?A=this.plot.axes.filter(D=>D.isXyAxis()&&D.isVertical()):A=this.plot.axes.filter(D=>D.isXyAxis()&&D.isHorizontal()));const P=de.snapTo;for(const D of this.majorTickValues){if(T&&Math.abs(D)<n)continue;let k=t.transform(D);f?(k=P(m,k),k=P(u,k)):(k=P(c,k),k=P(g,k)),this.majorPen&&this.addSegments(b,A,f,d,k,m,u,c,g),t.tickStyle!=Yt.None&&t.majorTickSize>0&&(f?(x.push(y(k,e+R)),x.push(y(k,e+M))):(x.push(y(e+R,k)),x.push(y(e+M,k))))}for(const D of this.majorLabelValues){if(D<a-n||D>h+n||T&&Math.abs(D)<n)continue;let k=t.transform(D);f?(k=P(m,k),k=P(u,k)):(k=P(c,k),k=P(g,k));let L=te,et=[N.Center,E.Middle];switch(t.position){case v.Left:L=y(e+M-t.axisTickToLabelDistance,k),et=this.getRotatedAlignments(t.angle,-90);break;case v.Right:L=y(e+M+t.axisTickToLabelDistance,k),et=this.getRotatedAlignments(t.angle,90);break;case v.Top:L=y(k,e+M-t.axisTickToLabelDistance),et=this.getRotatedAlignments(t.angle,0);break;case v.Bottom:L=y(k,e+M+t.axisTickToLabelDistance),et=this.getRotatedAlignments(t.angle,-180);break}const[ht,gt]=et,Rt=t.formatValue(D);await pe.drawMathText(this.renderContext,L,Rt,t.actualTextColor,t.actualFont,t.actualFontSize,t.actualFontWeight,t.angle,ht,gt)}const C=O.getActualEdgeRenderingMode(t.edgeRenderingMode,tt.PreferSharpness);if(t.extraGridlines&&this.extraPen){const D=[];for(const k of t.extraGridlines){if(!this.isWithin(k,a,h))continue;const L=t.transform(k);this.addSegments(D,A,f,d,L,m,u,c,g)}await O.drawLineSegments(this.renderContext,D,this.extraPen,C)}r&&(f?await O.drawLine(this.renderContext,t.transform(a),e,t.transform(h),e,this.axislinePen,C):await O.drawLine(this.renderContext,e,t.transform(a),e,t.transform(h),this.axislinePen,C)),this.majorPen&&await O.drawLineSegments(this.renderContext,b,this.majorPen,C),this.majorTickPen&&await O.drawLineSegments(this.renderContext,x,this.majorTickPen,C)}async renderMinorItems(t,e){const i=t.actualMinorStep*.001,r=this.plot.plotArea.left,n=w.right(this.plot.plotArea),a=this.plot.plotArea.top,h=w.bottom(this.plot.plotArea),m=t.cropGridlines,u=t.isHorizontal(),c=[],g=[];let f=[];m&&(u?f=this.plot.axes.filter(M=>M.isXyAxis()&&M.isVertical()):f=this.plot.axes.filter(M=>M.isXyAxis()&&M.isHorizontal()));const[d,b]=this.getTickPositions(t,t.tickStyle,t.minorTickSize,t.position),x=de.snapTo;for(const M of this.minorTickValues){if(t.positionAtZeroCrossing&&Math.abs(M)<i)continue;let S=t.transform(M);u?(S=x(r,S),S=x(n,S)):(S=x(a,S),S=x(h,S)),this.minorPen&&this.addSegments(c,f,u,m,S,r,n,a,h),t.tickStyle!=Yt.None&&t.minorTickSize>0&&(u?(g.push(y(S,e+d)),g.push(y(S,e+b))):(g.push(y(e+d,S)),g.push(y(e+b,S))))}const R=O.getActualEdgeRenderingMode(t.edgeRenderingMode,tt.PreferSharpness);this.minorPen&&await O.drawLineSegments(this.renderContext,c,this.minorPen,R),this.minorTickPen&&await O.drawLineSegments(this.renderContext,g,this.minorTickPen,R)}addSegments(t,e,i,r,n,a,h,m,u){if(i)if(!r)t.push(y(n,m)),t.push(y(n,u));else for(const c of e)t.push(y(n,c.transform(c.clipMinimum))),t.push(y(n,c.transform(c.clipMaximum)));else if(!r)t.push(y(a,n)),t.push(y(h,n));else for(const c of e)t.push(y(c.transform(c.clipMinimum),n)),t.push(y(c.transform(c.clipMaximum),n))}getRotatedAlignments(t,e){const i=(e+360)%360-180;let r=t>=Math.min(e,i)&&t<Math.max(e,i)?N.Left:N.Right,n=E.Middle;return e<0&&(r=r===N.Left?N.Right:N.Left),(Math.abs(t-i)<10||Math.abs(t-e)<10)&&(r=N.Center),Math.abs(t-e)<10&&(n=E.Bottom),Math.abs(t-i)<10&&(n=E.Top),[r,n]}}class Ro extends Bi{constructor(t,e){super(t,e)}async render(t,e){await super.render(t,e);const i=this.plot.defaultMagnitudeAxis;if(!i)throw new Error("Magnitude axis not defined.");const r=t.startAngle/t.scale,n=t.endAngle/t.scale,a=Math.abs(n-r);if(this.minorPen){const u=Math.abs(a/t.actualMinorStep|0),c=this.minorTickValues.slice(0,u+1).map(g=>i.transformPoint(i.clipMaximum,g,t));for(const g of c)await O.drawLine(this.renderContext,i.midPoint.x,i.midPoint.y,g.x,g.y,this.minorPen,t.edgeRenderingMode)}const h=Math.abs(Math.abs(Math.max(t.endAngle,t.startAngle)-Math.min(t.startAngle,t.endAngle))-360)<.001;let m=a/t.actualMajorStep|0;if(h||m++,this.majorPen){const u=this.majorTickValues.slice(0,m).map(c=>i.transformPoint(i.clipMaximum,c,t));for(const c of u)await O.drawLine(this.renderContext,i.midPoint.x,i.midPoint.y,c.x,c.y,this.majorPen,t.edgeRenderingMode)}for(const u of this.majorLabelValues.slice(0,m)){let c=i.transformPoint(i.clipMaximum,u,t);const g=Math.atan2(c.y-i.midPoint.y,c.x-i.midPoint.x);let{x:f,y:d}=c;f+=Math.cos(g)*t.axisTickToLabelDistance,d+=Math.sin(g)*t.axisTickToLabelDistance,c=y(f,d);let b=g*180/Math.PI;const x=t.formatValue(u);let R=N.Left,M=E.Middle;Math.abs(Math.abs(b)-90)<10?(R=N.Center,M=b>=90?E.Top:E.Bottom,b=0):(b>90||b<-90)&&(b-=180,R=N.Right),await pe.drawMathText(this.renderContext,c,x,t.actualTextColor,t.actualFont,t.actualFontSize,t.actualFontWeight,b,R,M)}}}class Vi extends Bi{constructor(t,e){super(t,e)}async render(t,e){await super.render(t,e);const i=this.plot.defaultAngleAxis;if(!i)throw new Error("Angle axis should not be null.");if(i.updateActualMaxMin(),e===0&&this.extraPen){const r=t.extraGridlines;if(r)for(let n=0;n<r.length;n++)await this.renderTick(t,i,r[n],this.extraPen)}if(e===0&&this.minorPen)for(const r of this.minorTickValues)await this.renderTick(t,i,r,this.minorPen);if(e===0&&this.majorPen)for(const r of this.majorTickValues)await this.renderTick(t,i,r,this.majorPen);if(e===1)for(const r of this.majorTickValues)await this.renderTickText(t,r,i)}static getActualAngle(t,e){const i=t.transformPoint(0,e.angle,e),r=t.transformPoint(1,e.angle,e);return Math.atan2(r.y-i.y,r.x-i.x)}static getTickTextAlignment(t){let e=N.Center,i=E.Bottom;return t>3*Math.PI/4||t<-3*Math.PI/4?(e=N.Center,i=E.Top):t<-Math.PI/4?(e=N.Right,i=E.Middle):t>Math.PI/4?(e=N.Left,i=E.Middle):(e=N.Center,i=E.Bottom),[e,i]}async renderTick(t,e,i,r){Math.abs(Math.abs(e.endAngle-e.startAngle)-360)<1e-6&&!r.actualDashArray?await this.renderTickCircle(t,e,i,r):await this.renderTickArc(t,e,i,r)}async renderTickCircle(t,e,i,r){const n=e.offset,a=t.transformPoint(t.clipMinimum,n,e),h=t.transformPoint(i,n,e).x,m=h-a.x,u=m*2,c=h-u,g=a.y-m,f=u;await this.renderContext.drawEllipse(Y(c,g,u,f),p.Undefined,r.color,r.thickness,t.edgeRenderingMode)}async renderTickArc(t,e,i,r){const n=e.clipMinimum,a=e.clipMaximum,h=Math.round(90*Math.abs(e.endAngle-e.startAngle)/360),m=(a-n)/(h-1),u=[];for(let c=0;c<h;c++){const g=n+c*m;u.push(t.transformPoint(i,g,e))}await this.renderContext.drawLine(u,r.color,r.thickness,t.edgeRenderingMode,r.actualDashArray)}async renderTickText(t,e,i){const r=Vi.getActualAngle(t,i),n=t.axisTickToLabelDistance*Math.sin(r),a=-t.axisTickToLabelDistance*Math.cos(r),[h,m]=Vi.getTickTextAlignment(r);let u=t.transformPoint(e,i.angle,i);u=y(u.x+n,u.y+a);const c=t.formatValue(e);await pe.drawMathText(this.renderContext,u,c,t.actualTextColor,t.actualFont,t.actualFontSize,t.actualFontWeight,t.angle,h,m)}}const ut=180/Math.PI,Ys=Math.PI/180,yo=class De extends Bi{constructor(t,e){super(t,e)}async render(t,e){await super.render(t,e);const i=this.plot.defaultAngleAxis,r=this.plot.defaultMagnitudeAxis;if(!i)throw new Error("Angle axis should not be undefined.");i.updateActualMaxMin();const n=w.bottom(t.plotModel.plotArea),a=w.right(t.plotModel.plotArea),h=Math.abs(t.plotModel.plotArea.top-r.midPoint.y),m=Math.abs(n-r.midPoint.y),u=Math.abs(t.plotModel.plotArea.left-r.midPoint.x),c=Math.abs(a-r.midPoint.x),g=oe.fromRect(w.offset(t.plotModel.plotArea,-r.midPoint.x,-r.midPoint.y)),f=-ut*Math.atan2(g.top,g.right);let d=-ut*Math.atan2(g.top,g.left),b=360-ut*Math.atan2(g.bottom,g.left);const x=360-ut*Math.atan2(g.bottom,g.right);d<0&&(d+=360),b>360&&(b-=360);const R=Math.sqrt(Math.pow(g.top,2)+Math.pow(g.right,2)),M=Math.sqrt(Math.pow(g.top,2)+Math.pow(g.left,2)),S=Math.sqrt(Math.pow(g.bottom,2)+Math.pow(g.left,2)),T=Math.sqrt(Math.pow(g.bottom,2)+Math.pow(g.right,2));if(e===0&&this.minorPen){const A=this.minorPen;for(const P of this.minorTickValues){const C=t.transform(P);let D=0,k=90,L=90,et=180,ht=180,gt=270,Rt=270,Tt=360;const ft=c/C,dt=h/C,H=u/C,G=m/C;C>c&&(Tt=360-ut*Math.acos(ft),D=ut*Math.acos(ft)),C>h&&(k=ut*Math.asin(dt),L=180-ut*Math.asin(dt)),C>u&&(et=180-ut*Math.acos(H),ht=180+ut*Math.acos(H)),C>m&&(gt=180+ut*Math.asin(G),Rt=360-ut*Math.asin(G)),C<=R&&(D<f&&await this.renderTickArc(t,i,P,A,D+i.offset,f+i.offset),f<k&&await this.renderTickArc(t,i,P,A,f+i.offset,k+i.offset)),C<=M&&(L<d&&await this.renderTickArc(t,i,P,A,L+i.offset,d+i.offset),d<et&&await this.renderTickArc(t,i,P,A,d+i.offset,et+i.offset)),C<=S&&(ht<b&&await this.renderTickArc(t,i,P,A,ht+i.offset,b+i.offset),b<gt&&await this.renderTickArc(t,i,P,A,b+i.offset,gt+i.offset)),C<=T&&(Rt<x&&await this.renderTickArc(t,i,P,A,Rt+i.offset,x+i.offset),x<Tt&&await this.renderTickArc(t,i,P,A,x+i.offset,Tt+i.offset))}}if(e===0&&this.majorPen){const A=this.majorPen;for(const P of this.majorTickValues){const C=t.transform(P);let D=0,k=90,L=90,et=180,ht=180,gt=270,Rt=270,Tt=360;const ft=c/C,dt=h/C,H=u/C,G=m/C;C>c&&(Tt=360-ut*Math.acos(ft),D=ut*Math.acos(ft)),C>h&&(k=ut*Math.asin(dt),L=180-ut*Math.asin(dt)),C>u&&(et=180-ut*Math.acos(H),ht=180+ut*Math.acos(H)),C>m&&(gt=180+ut*Math.asin(G),Rt=360-ut*Math.asin(G)),C<=R&&(D<f&&await this.renderTickArc(t,i,P,A,D+i.offset,f+i.offset),f<k&&await this.renderTickArc(t,i,P,A,f+i.offset,k+i.offset)),C<=M&&(L<d&&await this.renderTickArc(t,i,P,A,L+i.offset,d+i.offset),d<et&&await this.renderTickArc(t,i,P,A,d+i.offset,et+i.offset)),C<=S&&(ht<b&&await this.renderTickArc(t,i,P,A,ht+i.offset,b+i.offset),b<gt&&await this.renderTickArc(t,i,P,A,b+i.offset,gt+i.offset)),C<=T&&(Rt<x&&await this.renderTickArc(t,i,P,A,Rt+i.offset,x+i.offset),x<Tt&&await this.renderTickArc(t,i,P,A,x+i.offset,Tt+i.offset))}}if(e===1){const A=O.autoResetClip(this.renderContext,w.fromScreenPoints(t.screenMin,t.screenMax));for(const P of this.majorLabelValues)await this.renderTickText(t,P,i);A.dispose()}}static getActualAngle(t,e){const i=t.transformPoint(0,e.angle,e),r=t.transformPoint(1,e.angle,e);return Math.atan2(r.y-i.y,r.x-i.x)}static getTickTextAligment(t){let e=N.Center,i=E.Bottom;return t>3*Math.PI/4||t<-3*Math.PI/4?(e=N.Center,i=E.Top):t<-Math.PI/4?(e=N.Right,i=E.Middle):t>Math.PI/4?(e=N.Left,i=E.Middle):(e=N.Center,i=E.Bottom),[e,i]}async renderTickArc(t,e,i,r,n,a){let h=De.maxSegments*Math.abs(a-n)/360;(e.fractionUnit===Math.PI||e.actualMaximum===2*Math.PI)&&(h=De.maxSegments*Math.abs(a-n)/(2*Math.PI),n*=Ys,a*=Ys),h=Math.max(h,2),h=Math.min(h,De.maxSegments);const m=Math.abs(a-n)/(h-1),u=[];for(let c=0;c<h;c++){const g=n+c*m,f=t.transformPoint(i,g,e);u.push(f)}await this.renderContext.drawLine(u,r.color,r.thickness,t.edgeRenderingMode,r.actualDashArray)}async renderTickText(t,e,i){const r=De.getActualAngle(t,i),n=t.axisTickToLabelDistance*Math.sin(r),a=-t.axisTickToLabelDistance*Math.cos(r),[h,m]=De.getTickTextAligment(r);let u=t.transformPoint(e,i.angle,i);u=y(u.x+n,u.y+a);const c=t.formatValue(e);await pe.drawMathText(this.renderContext,u,c,t.actualTextColor,t.actualFont,t.actualFontSize,t.actualFontWeight,t.angle,h,m)}};l(yo,"maxSegments",180);const So={base:10,powerPadding:!0,filterMinValue:0},wo={...fr,...So};p.Undefined,p.Undefined,p.Gray,Xt.viridis(),v.None;({...wo});const Ze={firstDayOfWeek:sr.Monday,intervalType:z.Auto,minorIntervalType:z.Auto,position:v.Bottom,timeZone:void 0},ko={...me,...Ze},Ae=class kt extends le{constructor(t){super(t),l(this,"_actualIntervalType",z.Auto),l(this,"_actualMinorIntervalType",z.Auto),l(this,"_dateService"),l(this,"firstDayOfWeek",Ze.firstDayOfWeek),l(this,"intervalType",Ze.intervalType),l(this,"minorIntervalType",Ze.minorIntervalType),l(this,"timeZone"),this._dateService=Yi(),q(this,Ze,t)}getElementName(){return"DateTimeAxis"}static createDataPoint(t,e){return $(kt.toDouble(t),e)}static toDateTime(t){return isNaN(t)||t<kt.MinDayValue||t>kt.MaxDayValue?new Date:Yi().addTimespan(kt.TimeOrigin,Ft.fromDays(t-1))}static fromDotNetValue(t){return t=t-kt.TimeOriginDiffDaysToCSharp,kt.toDateTime(t)}static toDouble(t){return Yi().diff(t,kt.TimeOrigin).totalDays+1}itemToDouble(t){return t instanceof Date?kt.toDouble(t):super.itemToDouble(t)}getTickValues(){let t=this.createDateTimeTickValues(this.clipMinimum,this.clipMaximum,this.actualMinorStep,this._actualMinorIntervalType);const e=this.createDateTimeTickValues(this.clipMinimum,this.clipMaximum,this.actualMajorStep,this._actualIntervalType),i=e;return t=si.filterRedundantMinorTicks(e,t),{majorLabelValues:i,majorTickValues:e,minorTickValues:t}}getValue(t){const e=kt.toDateTime(t);return this.timeZone?this._dateService.convertTime(e,this.timeZone):e}updateIntervals(t){super.updateIntervals(t);const e=!J(this.stringFormatter);switch(this._actualIntervalType){case z.Years:this.actualMinorStep=31,this._actualMinorIntervalType=z.Years,e||(this.actualStringFormatter=i=>this._dateService.format(i,"YYYY"));break;case z.Months:this._actualMinorIntervalType=z.Months,e||(this.actualStringFormatter=i=>this._dateService.format(i,"YYYY-MM-DD"));break;case z.Weeks:this._actualMinorIntervalType=z.Days,this.actualMajorStep=7,this.actualMinorStep=1,e||(this.actualStringFormatter=i=>this._dateService.format(i,"YYYY/ww"));break;case z.Days:this.actualMinorStep=this.actualMajorStep,e||(this.actualStringFormatter=i=>this._dateService.format(i,"YYYY-MM-DD"));break;case z.Hours:this.actualMinorStep=this.actualMajorStep,e||(this.actualStringFormatter=i=>this._dateService.format(i,"HH:mm"));break;case z.Minutes:this.actualMinorStep=this.actualMajorStep,e||(this.actualStringFormatter=i=>this._dateService.format(i,"HH:mm"));break;case z.Seconds:this.actualMinorStep=this.actualMajorStep,e||(this.actualStringFormatter=i=>this._dateService.format(i,"HH:mm:ss"));break;case z.Milliseconds:this.actualMinorStep=this.actualMajorStep,e||(this.actualStringFormatter=i=>this._dateService.format(i,"HH:mm:ss.SSS"));break;case z.Manual:break;case z.Auto:break}}getDefaultStringFormatter(){return t=>this._dateService.format(t,"yyyy-MM-dd")}formatValueOverride(t){let e=kt.toDateTime(t);this.timeZone&&(e=this._dateService.convertTime(e,this.timeZone));const i=this.actualStringFormatter;return i?i(e):e.toLocaleDateString()}calculateActualInterval(t,e,i,r,n){const a=.041666666666666664,h=a/60,m=h/60,u=m/1e3;n=Math.abs(this.clipMinimum-this.clipMaximum);const c=[u,2*u,10*u,100*u,m,2*m,5*m,10*m,30*m,h,2*h,5*h,10*h,30*h,a,4*a,8*a,12*a,1,2*1,5*1,7,2*7,30.5,2*30.5,3*30.5,4*30.5,6*30.5,365.25];let g=c[0];for(i=Math.max(i,0),r=Math.min(r,Math.max(Math.floor(t/e),2));!(n/g<r);){let f=c.find(d=>d>g);if(ne(f))throw new Error(`cannot calculate interval,range=${n}`);if(Math.abs(f)<=0&&(f=g*2),n/f<i)break;g=f}if(this._actualIntervalType=this.intervalType,this._actualMinorIntervalType=this.minorIntervalType,this.intervalType===z.Auto&&(this._actualIntervalType=z.Milliseconds,g>=1/24/60/60&&(this._actualIntervalType=z.Seconds),g>=1/24/60&&(this._actualIntervalType=z.Minutes),g>=1/24&&(this._actualIntervalType=z.Hours),g>=1&&(this._actualIntervalType=z.Days),g>=30&&(this._actualIntervalType=z.Months),n>=365.25&&(this._actualIntervalType=z.Years)),this._actualIntervalType===z.Months){const f=n/30.5;g=super.calculateActualInterval(t,e,this.minimumMajorIntervalCount,this.maximumMajorIntervalCount,f)}if(this._actualIntervalType===z.Years){const f=n/365.25;g=super.calculateActualInterval(t,e,this.minimumMajorIntervalCount,this.maximumMajorIntervalCount,f)}if(this._actualMinorIntervalType===z.Auto)switch(this._actualIntervalType){case z.Years:this._actualMinorIntervalType=z.Months;break;case z.Months:this._actualMinorIntervalType=z.Days;break;case z.Weeks:this._actualMinorIntervalType=z.Days;break;case z.Days:this._actualMinorIntervalType=z.Hours;break;case z.Hours:this._actualMinorIntervalType=z.Minutes;break;default:this._actualMinorIntervalType=z.Days;break}return g}createDateTickValues(t,e,i,r){const n=[];let a=kt.toDateTime(t);if(!a)return n;let h=0;switch(r){case z.Weeks:h=this._dateService.dayOfWeek(a),a=this._dateService.addTimespan(a,Ft.fromDays(-h+this.firstDayOfWeek));break;case z.Months:a=new Date(a.getFullYear(),a.getMonth(),1);break;case z.Years:a=new Date(a.getFullYear(),0,1);break}const m=this._dateService.addTimespan(kt.toDateTime(e),Ft.fromMilliseconds(1));if(!m)return n;let u=a;const c=i*.001,g=kt.toDateTime(t-c),f=kt.toDateTime(e+c);if(!g||!f)return n;for(;u<m;)switch(u>g&&u<f&&n.push(kt.toDouble(u)),r){case z.Months:u=this._dateService.addMonths(u,Math.ceil(i));break;case z.Years:u=this._dateService.addYears(u,Math.ceil(i));break;default:u=this._dateService.addTimespan(u,Ft.fromDays(i));break}return n}createDateTimeTickValues(t,e,i,r){return r>z.Days?this.createDateTickValues(t,e,i,r):this.createTickValues(t,e,i)}getElementDefaultValues(){return ko}};l(Ae,"TimeOrigin",new Date(Date.UTC(1901,0,1,0,0,0))),l(Ae,"TimeOriginDiffDaysToCSharp",366),l(Ae,"MaxDayValue",Ft.fromMilliseconds(Gr.getTime()-Ae.TimeOrigin.getTime()).totalDays),l(Ae,"MinDayValue",Ft.fromMilliseconds(he.getTime()-Ae.TimeOrigin.getTime()).totalDays);({...me});p.Gray,p.Undefined,p.Undefined,Xt.viridis(),v.None;({...me});p.Undefined,p.Undefined,p.Gray,v.None;({...me});v.None,_.Solid,_.Solid;({...xr});class ze{static getColor(t,e){return t.getColor(t.getPaletteIndex(e))}static getHighValue(t,e){return this.getLowValue(t,e+1)}static getLowValue(t,e){return e/t.palette.colors.length*(t.clipMaximum-t.clipMinimum)+t.clipMinimum}static getColorByPaletteIndex(t,e){return e===W?t.invalidNumberColor:e===0?t.lowColor:e===t.palette.colors.length+1?t.highColor:t.palette.colors[e-1]}}p.Undefined,Zt();({...br});function Ao(o){return o.getDataPoint&&typeof o.getDataPoint=="function"}function ci(o){const t=[];return new Proxy(t,{deleteProperty:function(e,i){const r=e[i];return r&&r instanceof hs&&(r.parent=void 0),delete e[i],!0},set:function(e,i,r,n){return e[i]=r,i==="length"||r&&r instanceof hs&&(r.parent=o),!0}})}class us{constructor(t,e){l(this,"point"),l(this,"tolerance"),this.point=t,this.tolerance=e}}class To{constructor(t){l(this,"view"),this.view=t}completed(t){}delta(t){}started(t){}}const cs={selectionColor:p.Yellow},gs=class fs{constructor(t){l(this,"selectionColor",cs.selectionColor),l(this,"currentMouseEventElement"),l(this,"currentTouchEventElement"),l(this,"keyDown"),l(this,"mouseDown"),l(this,"mouseMove"),l(this,"mouseUp"),l(this,"mouseEnter"),l(this,"mouseLeave"),l(this,"touchStarted"),l(this,"touchDelta"),l(this,"touchCompleted"),this.selectionColor=p.Yellow,q(this,cs,t)}hitTest(t){const e=this.getHitTestElements(),i=[];for(const r of e){const n=r.hitTest(t);n&&i.push(n)}return i}handleMouseDown(t,e){const i=new us(e.position,fs.mouseHitTolerance);for(const r of this.hitTest(i)){e.hitTestResult=r;const n=r.element;if(n.onMouseDown(e),e.handled){this.currentMouseEventElement=n;return}}e.handled||this.onMouseDown(t,e)}handleMouseMove(t,e){this.currentMouseEventElement&&this.currentMouseEventElement.onMouseMove(e),e.handled||this.onMouseMove(t,e)}handleMouseUp(t,e){this.currentMouseEventElement&&(this.currentMouseEventElement.onMouseUp(e),this.currentMouseEventElement=void 0),e.handled||this.onMouseUp(t,e)}handleMouseEnter(t,e){e.handled||this.onMouseEnter(t,e)}handleMouseLeave(t,e){e.handled||this.onMouseLeave(t,e)}handleTouchStarted(t,e){const i=new us(e.position,fs.mouseHitTolerance);for(const r of this.hitTest(i)){const n=r.element;if(n.onTouchStarted(e),e.handled){this.currentTouchEventElement=n;return}}e.handled||this.onTouchStarted(t,e)}handleTouchDelta(t,e){this.currentTouchEventElement&&this.currentTouchEventElement.onTouchDelta(e),e.handled||this.onTouchDelta(t,e)}handleTouchCompleted(t,e){this.currentTouchEventElement&&(this.currentTouchEventElement.onTouchCompleted(e),this.currentTouchEventElement=void 0),e.handled||this.onTouchCompleted(t,e)}handleKeyDown(t,e){for(const i of this.getHitTestElements())if(i.onKeyDown(e),e.handled)break;e.handled||this.onKeyDown(t,e)}onKeyDown(t,e){const i=this.keyDown;i&&i(t,e)}onMouseDown(t,e){const i=this.mouseDown;i&&i(t,e)}onMouseMove(t,e){const i=this.mouseMove;i&&i(t,e)}onMouseUp(t,e){const i=this.mouseUp;i&&i(t,e)}onMouseEnter(t,e){const i=this.mouseEnter;i&&i(t,e)}onMouseLeave(t,e){const i=this.mouseLeave;i&&i(t,e)}onTouchStarted(t,e){const i=this.touchStarted;i&&i(t,e)}onTouchDelta(t,e){const i=this.touchDelta;i&&i(t,e)}onTouchCompleted(t,e){const i=this.touchCompleted;i&&i(t,e)}};l(gs,"DefaultSelectionColor",p.Yellow),l(gs,"mouseHitTolerance",10);let ds=gs;const bs=class xs{constructor(){l(this,"selection",new Map)}static get Everything(){return xs.EverythingSelection}isEverythingSelected(){return this===xs.EverythingSelection}getSelectedItems(){return Array.from(this.selection.keys()).map(t=>t.Index)}getSelectedItemsByFeature(t){return Array.from(this.selection.keys()).filter(e=>e.Feature===t).map(e=>e.Index)}clear(){this.selection.clear()}isItemSelected(t,e=null){if(this.isEverythingSelected())return!0;const i=new qi(t,e);return this.hasSelection(i)}select(t,e){const i=new qi(t,e);this.setSelection(i,!0)}unselect(t,e){const i=new qi(t,e);if(!this.hasSelection(i))throw new Error(`Item ${t} and feature ${e} is not selected. Cannot unselect.`);this.deleteSelection(i)}getSameKey(t){for(const e of this.selection.keys())if(e.equals(t))return e}hasSelection(t){return!!this.getSameKey(t)}deleteSelection(t){const e=this.getSameKey(t);e&&this.selection.delete(e)}setSelection(t,e){const i=this.getSameKey(t)||t;this.selection.set(i,e)}};l(bs,"EverythingSelection",new bs);let Xs=bs;class qi{constructor(t,e){l(this,"index"),l(this,"feature"),this.index=t,this.feature=e}get Index(){return this.index}get Feature(){return this.feature}equals(t){return t.index===this.index&&t.feature===this.feature}}class _i{constructor(t,e){l(this,"gesture"),l(this,"command"),this.gesture=t,this.command=e}static fromKeyGesture(t,e,i){return new _i(new We(t,e),i)}static fromMouseGesture(t,e,i){return new _i(new Ue(t,e),i)}getGesture(){return this.gesture}getCommand(){return this.command}}class vo{constructor(){l(this,"inputCommandBindings",[]),l(this,"mouseDownManipulators",[]),l(this,"mouseHoverManipulators",[]),l(this,"touchManipulators",[])}handleGesture(t,e,i){const r=this.getCommand(e);return this.handleCommand(r,t,i)}handleMouseDown(t,e){if(t.actualModel&&(t.actualModel.handleMouseDown(this,e),e.handled))return!0;const i=this.getCommand(new Ue(e.changedButton,e.modifierKeys,e.clickCount));return this.handleCommand(i,t,e)}handleMouseEnter(t,e){if(t.actualModel&&(t.actualModel.handleMouseEnter(this,e),e.handled))return!0;const i=this.getCommand(new oi(e.modifierKeys));return this.handleCommand(i,t,e)}handleMouseLeave(t,e){if(t.actualModel&&(t.actualModel.handleMouseLeave(this,e),e.handled))return!0;for(const i of[...this.mouseHoverManipulators])i.completed(e),hi(this.mouseHoverManipulators,i);return e.handled}handleMouseMove(t,e){if(t.actualModel&&(t.actualModel.handleMouseMove(this,e),e.handled))return!0;for(const i of this.mouseDownManipulators)i.delta(e);for(const i of this.mouseHoverManipulators)i.delta(e);return e.handled}handleMouseUp(t,e){if(t.actualModel&&(t.actualModel.handleMouseUp(this,e),e.handled))return!0;for(const i of[...this.mouseDownManipulators])i.completed(e),hi(this.mouseDownManipulators,i);return e.handled}handleMouseWheel(t,e){const i=this.getCommand(new ni(e.modifierKeys));return this.handleCommand(i,t,e)}handleTouchStarted(t,e){if(t.actualModel&&(t.actualModel.handleTouchStarted(this,e),e.handled))return!0;const i=this.getCommand(new ai);return this.handleCommand(i,t,e)}handleTouchDelta(t,e){if(t.actualModel&&(t.actualModel.handleTouchDelta(this,e),e.handled))return!0;for(const i of this.touchManipulators)i.delta(e);return e.handled}handleTouchCompleted(t,e){if(t.actualModel&&(t.actualModel.handleTouchCompleted(this,e),e.handled))return!0;for(const i of[...this.touchManipulators])i.completed(e),hi(this.touchManipulators,i);return e.handled}handleKeyDown(t,e){if(!t.actualModel)return!1;if(t.actualModel.handleKeyDown(this,e),e.handled)return!0;const i=this.getCommand(new We(e.key,e.modifierKeys));return this.handleCommand(i,t,e)}addMouseManipulator(t,e,i){this.mouseDownManipulators.push(e),e.started(i)}addHoverManipulator(t,e,i){this.mouseHoverManipulators.push(e),e.started(i)}addTouchManipulator(t,e,i){this.touchManipulators.push(e),e.started(i)}bindMouseDown(t,e){this.bindCore(t,e)}bindMouseEnter(t,e){this.bindCore(t,e)}bindMouseWheel(t,e){this.bindCore(t,e)}bindTouch(t,e){this.bindCore(t,e)}bindKey(t,e){this.bindCore(t,e)}unbindInput(t){Bs(this.inputCommandBindings,e=>e.getGesture().equals(t))}unbindViewCommand(t){Bs(this.inputCommandBindings,e=>e.getCommand()===t)}unbindAll(){this.inputCommandBindings.length=0}bindCore(t,e){const i=this.inputCommandBindings.find(r=>r.getGesture().equals(t));i&&hi(this.inputCommandBindings,i),e&&this.inputCommandBindings.push(new _i(t,e))}getCommand(t){const e=this.inputCommandBindings.find(i=>i.getGesture().equals(t));return e?e.getCommand():void 0}handleCommand(t,e,i){return t?(t.execute(e,this,i),i.handled):!1}}class K{static bindKeyDown(t,e,i,r=Z.None){t.bindKey(new We(e,r),i)}static bindMouseDown(t,e,i,r=Z.None,n=1){t.bindMouseDown(new Ue(e,r,n),i)}static bindTouchDown(t,e){t.bindTouch(new ai,e)}static bindMouseEnter(t,e){t.bindMouseEnter(new oi,e)}static bindMouseWheel(t,e,i=Z.None){t.bindMouseWheel(new ni(i),e)}static unbindMouseDown(t,e,i=Z.None,r=1){t.unbindInput(new Ue(e,i,r))}static unbindKeyDown(t,e,i=Z.None){t.unbindInput(new We(e,i))}static unbindMouseEnter(t){t.unbindInput(new oi)}static unbindTouchDown(t){t.unbindInput(new ai)}static unbindMouseWheel(t){t.unbindInput(new ni)}}class Co{constructor(t){l(this,"handler"),this.handler=t}execute(t,e,i){this.handler(t,e,i)}}var Ne=(o=>(o[o.Png=0]="Png",o[o.Bmp=1]="Bmp",o[o.Jpeg=2]="Jpeg",o[o.Unknown=3]="Unknown",o))(Ne||{});class Ei{constructor(t){l(this,"_image"),l(this,"_hashCode"),this._image=t}static from(t){return new Ei(t)}get uri(){return this._image.uri}get format(){return this._image.format}get width(){return this._image.width}get height(){return this._image.height}get bitsPerPixel(){return this._image.bitsPerPixel}get dpiX(){return this._image.dpiX}get dpiY(){return this._image.dpiY}get data(){return this._image.data}static async create(t,e,i,r){const n=to(),a=t.height,h=t.width,m={pixels:t,palette:r,imageInfo:{width:h,height:a,bitsPerPixel:0,dpiX:i==null?void 0:i.dpiX,dpiY:i==null?void 0:i.dpiY,format:e}},u=await n.encode(m),c={...await n.getImageInfo(u),data:Array.from(u)};return c.width=h,c.height=a,c}static getImageFormat(t){return t.length>=2&&t[0]===255&&t[1]===216?Ne.Jpeg:t.length>=2&&t[0]===66&&t[1]===77?Ne.Bmp:t.length>=4&&t[0]===137&&t[1]===80&&t[2]===78&&t[3]===71?Ne.Png:Ne.Unknown}getHashCode(){return this._hashCode===void 0&&(this._hashCode=hr([...this._image.data])),this._hashCode}}var xt=(o=>(o[o.Space=0]="Space",o[o.Enter=1]="Enter",o[o.Escape=2]="Escape",o[o.Tab=3]="Tab",o[o.Backspace=4]="Backspace",o[o.Insert=5]="Insert",o[o.Delete=6]="Delete",o[o.Home=7]="Home",o[o.End=8]="End",o[o.Up=9]="Up",o[o.Down=10]="Down",o[o.Left=11]="Left",o[o.Right=12]="Right",o[o.PageUp=13]="PageUp",o[o.PageDown=14]="PageDown",o[o.A=15]="A",o[o.B=16]="B",o[o.C=17]="C",o[o.D=18]="D",o[o.E=19]="E",o[o.F=20]="F",o[o.G=21]="G",o[o.H=22]="H",o[o.I=23]="I",o[o.J=24]="J",o[o.K=25]="K",o[o.L=26]="L",o[o.M=27]="M",o[o.N=28]="N",o[o.O=29]="O",o[o.P=30]="P",o[o.Q=31]="Q",o[o.R=32]="R",o[o.S=33]="S",o[o.T=34]="T",o[o.U=35]="U",o[o.V=36]="V",o[o.W=37]="W",o[o.X=38]="X",o[o.Y=39]="Y",o[o.Z=40]="Z",o[o.D0=41]="D0",o[o.D1=42]="D1",o[o.D2=43]="D2",o[o.D3=44]="D3",o[o.D4=45]="D4",o[o.D5=46]="D5",o[o.D6=47]="D6",o[o.D7=48]="D7",o[o.D8=49]="D8",o[o.D9=50]="D9",o[o.NumPad0=51]="NumPad0",o[o.NumPad1=52]="NumPad1",o[o.NumPad2=53]="NumPad2",o[o.NumPad3=54]="NumPad3",o[o.NumPad4=55]="NumPad4",o[o.NumPad5=56]="NumPad5",o[o.NumPad6=57]="NumPad6",o[o.NumPad7=58]="NumPad7",o[o.NumPad8=59]="NumPad8",o[o.NumPad9=60]="NumPad9",o[o.Add=61]="Add",o[o.Subtract=62]="Subtract",o[o.Multiply=63]="Multiply",o[o.Divide=64]="Divide",o[o.Decimal=65]="Decimal",o[o.F1=66]="F1",o[o.F2=67]="F2",o[o.F3=68]="F3",o[o.F4=69]="F4",o[o.F5=70]="F5",o[o.F6=71]="F6",o[o.F7=72]="F7",o[o.F8=73]="F8",o[o.F9=74]="F9",o[o.F10=75]="F10",o[o.F11=76]="F11",o[o.F12=77]="F12",o[o.Unknown=78]="Unknown",o))(xt||{}),Z=(o=>(o[o.None=0]="None",o[o.Control=1]="Control",o[o.Alt=2]="Alt",o[o.Shift=4]="Shift",o[o.Windows=8]="Windows",o))(Z||{}),Ct=(o=>(o[o.None=0]="None",o[o.Left=1]="Left",o[o.Middle=2]="Middle",o[o.Right=3]="Right",o[o.XButton1=4]="XButton1",o[o.XButton2=5]="XButton2",o))(Ct||{});class We{constructor(t,e=Z.None){this.key=t,this.modifiers=e}equals(t){if(!(t instanceof We))return!1;const e=t;return e.modifiers===this.modifiers&&e.key===this.key}}class Ue{constructor(t,e=Z.None,i=1){this.mouseButton=t,this.modifiers=e,this.clickCount=i}equals(t){if(!(t instanceof Ue))return!1;const e=t;return e.modifiers===this.modifiers&&e.mouseButton===this.mouseButton&&e.clickCount===this.clickCount}}class oi{constructor(t=Z.None){this.modifiers=t}equals(t){return t instanceof oi?t.modifiers===this.modifiers:!1}}class ni{constructor(t=Z.None){this.modifiers=t}equals(t){return t instanceof ni?t.modifiers===this.modifiers:!1}}class Ds{equals(t){return t instanceof Ds}}class ai{equals(t){return t instanceof ai}}var ri=(o=>(o[o.Inside=0]="Inside",o[o.Outside=1]="Outside",o))(ri||{}),pr=(o=>(o[o.TopLeft=0]="TopLeft",o[o.TopCenter=1]="TopCenter",o[o.TopRight=2]="TopRight",o[o.BottomLeft=3]="BottomLeft",o[o.BottomCenter=4]="BottomCenter",o[o.BottomRight=5]="BottomRight",o[o.LeftTop=6]="LeftTop",o[o.LeftMiddle=7]="LeftMiddle",o[o.LeftBottom=8]="LeftBottom",o[o.RightTop=9]="RightTop",o[o.RightMiddle=10]="RightMiddle",o[o.RightBottom=11]="RightBottom",o))(pr||{});const Po=o=>o===6||o===7||o===8,Fo=o=>o===9||o===10||o===11,Do=o=>o===0||o===1||o===2,Io=o=>o===3||o===4||o===5;var Mr=(o=>(o[o.Horizontal=0]="Horizontal",o[o.Vertical=1]="Vertical",o))(Mr||{}),Rr=(o=>(o[o.Normal=0]="Normal",o[o.Reverse=1]="Reverse",o))(Rr||{}),yr=(o=>(o[o.Left=0]="Left",o[o.Right=1]="Right",o))(yr||{});p.Undefined,p.Undefined,p.Undefined,N.Left;p.Undefined,p.Undefined,p.Automatic,p.Automatic,ri.Inside,pr.RightTop,Mr.Vertical,Rr.Normal,N.Left,yr.Left,F.fromAColor(64,p.Black),Ee.Single;class Ws{static isAltDown(t){return(t.modifierKeys&Z.Alt)===Z.Alt}static isControlDown(t){return(t.modifierKeys&Z.Control)===Z.Control}static isShiftDown(t){return(t.modifierKeys&Z.Shift)===Z.Shift}}class yt{constructor(t){l(this,"dataPoint"),l(this,"item"),l(this,"index",0),l(this,"lineExtents"),l(this,"plotModel"),l(this,"position"),l(this,"series"),l(this,"text"),t&&Object.assign(this,ae(t))}get xAxis(){return!this.series||!(this.series instanceof nt)?void 0:this.series.xAxis}get yAxis(){return!this.series||!(this.series instanceof nt)?void 0:this.series.yAxis}toString(){return this.text?this.text.trim():""}}var Je=(o=>(o[o.None=0]="None",o[o.X=1]="X",o[o.Y=2]="Y",o))(Je||{});class Sr extends To{constructor(t){super(t),l(this,"plotView"),l(this,"axisPreference",Je.None),l(this,"xAxis"),l(this,"yAxis"),this.plotView=t}inverseTransform(t,e){return this.xAxis?this.xAxis.inverseTransformPoint(t,e,this.yAxis):this.yAxis?$(0,this.yAxis.inverseTransform(e)):is}assignAxes(t){let e,i;this.plotView.actualModel?([e,i]=this.plotView.actualModel.getAxesFromPoint(t),this.axisPreference!==Je.None&&w.containsPoint(this.plotView.actualModel.plotArea,t)&&(this.axisPreference===Je.X?e&&(i=void 0):this.axisPreference===Je.Y&&i&&(e=void 0))):(e=void 0,i=void 0),this.xAxis=e,this.yAxis=i}}class zi extends Sr{constructor(t){super(t),l(this,"startPosition")}started(t){this.assignAxes(t.position),this.startPosition=t.position}}class Us extends zi{constructor(t,e,i){super(t),l(this,"fineControl"),l(this,"step"),this.step=e,this.fineControl=i}started(t){if(super.started(t),!(this.xAxis&&this.xAxis.isZoomEnabled||this.yAxis&&this.yAxis.isZoomEnabled))return;const e=this.inverseTransform(t.position.x,t.position.y);let i=this.step;this.fineControl&&(i*=3),i>0?i=1+i:i=1/(1-i),this.xAxis&&this.xAxis.zoomAt(i,e.x),this.yAxis&&this.yAxis.zoomAt(i,e.y),this.plotView.invalidatePlot(!1),t.handled=!0}}class Vo extends zi{constructor(t){super(t),l(this,"previousPosition",te),l(this,"isPanEnabled",!1)}completed(t){super.completed(t),this.isPanEnabled&&(this.view.setCursorType(be.Default),t.handled=!0)}delta(t){super.delta(t),this.isPanEnabled&&(this.xAxis&&this.xAxis.pan(this.previousPosition,t.position),this.yAxis&&this.yAxis.pan(this.previousPosition,t.position),this.plotView.invalidatePlot(!1),this.previousPosition=t.position,t.handled=!0)}started(t){super.started(t),this.previousPosition=t.position,this.isPanEnabled=!!(this.xAxis&&this.xAxis.isPanEnabled||this.yAxis&&this.yAxis.isPanEnabled),this.isPanEnabled&&(this.view.setCursorType(be.Pan),t.handled=!0)}}class _o extends zi{constructor(t){super(t),l(this,"zoomRectangle",Le),l(this,"isZoomEnabled",!1)}completed(t){if(super.completed(t),!!this.isZoomEnabled){if(this.plotView.setCursorType(be.Default),this.plotView.hideZoomRectangle(),this.zoomRectangle.width>10&&this.zoomRectangle.height>10){const e=this.inverseTransform(this.zoomRectangle.left,this.zoomRectangle.top),i=this.inverseTransform(w.right(this.zoomRectangle),w.bottom(this.zoomRectangle));this.xAxis&&this.xAxis.zoom(e.x,i.x),this.yAxis&&this.yAxis.zoom(e.y,i.y),this.plotView.invalidatePlot()}t.handled=!0}}delta(t){if(super.delta(t),!this.plotView.actualModel||!this.isZoomEnabled||!this.startPosition)return;const e=this.plotView.actualModel.plotArea;let i=Math.min(this.startPosition.x,t.position.x),r=Math.abs(this.startPosition.x-t.position.x),n=Math.min(this.startPosition.y,t.position.y),a=Math.abs(this.startPosition.y-t.position.y);(this.xAxis===void 0||!this.xAxis.isZoomEnabled)&&(i=e.left,r=e.width),(this.yAxis===void 0||!this.yAxis.isZoomEnabled)&&(n=e.top,a=e.height),this.zoomRectangle=Y(i,n,r,a),this.plotView.showZoomRectangle(this.zoomRectangle),t.handled=!0}started(t){super.started(t),this.isZoomEnabled=!!(this.xAxis&&this.xAxis.isZoomEnabled||this.yAxis&&this.yAxis.isZoomEnabled),this.isZoomEnabled&&this.startPosition&&(this.zoomRectangle=Y(this.startPosition.x,this.startPosition.y,0,0),this.plotView.showZoomRectangle(this.zoomRectangle),this.plotView.setCursorType(this.getCursorType()),t.handled=!0)}getCursorType(){return this.xAxis===void 0?be.ZoomVertical:this.yAxis===void 0?be.ZoomHorizontal:be.ZoomRectangle}}class wr extends Sr{constructor(t){super(t),l(this,"setHandledForPanOrZoom"),l(this,"isPanEnabled",!1),l(this,"isZoomEnabled",!1),this.setHandledForPanOrZoom=!0}completed(t){super.completed(t),this.setHandledForPanOrZoom&&(t.handled=t.handled||this.isPanEnabled||this.isZoomEnabled)}delta(t){if(super.delta(t),!this.isPanEnabled&&!this.isZoomEnabled)return;const e=t.position,i=_e(e,t.deltaTranslation);this.xAxis&&this.xAxis.pan(i,e),this.yAxis&&this.yAxis.pan(i,e);const r=this.inverseTransform(e.x,e.y);this.xAxis&&this.xAxis.zoomAt(t.deltaScale.x,r.x),this.yAxis&&this.yAxis.zoomAt(t.deltaScale.y,r.y),this.plotView.invalidatePlot(!1),t.handled=!0}started(t){this.assignAxes(t.position),super.started(t),this.setHandledForPanOrZoom&&(this.isPanEnabled=!!(this.xAxis&&this.xAxis.isPanEnabled||this.yAxis&&this.yAxis.isPanEnabled),this.isZoomEnabled=!!(this.xAxis&&this.xAxis.isZoomEnabled||this.yAxis&&this.yAxis.isZoomEnabled),t.handled=t.handled||this.isPanEnabled||this.isZoomEnabled)}}class Te extends zi{constructor(t,e){super(t),l(this,"currentSeries"),l(this,"pointsOnly"),l(this,"snap"),l(this,"lockToInitialSeries"),l(this,"firesDistance"),l(this,"checkDistanceBetweenPoints"),l(this,"isTrackAnnotations",!0),this.snap=!0,this.pointsOnly=!1,this.lockToInitialSeries=!0,this.firesDistance=20,this.checkDistanceBetweenPoints=!1,this.isTrackAnnotations=!0,e&&Object.assign(this,ae(e))}completed(t){super.completed(t),t.handled=!0,this.currentSeries=void 0,this.plotView.hideTracker(),this.plotView.actualModel&&this.plotView.actualModel.raiseTrackerChanged(void 0)}delta(t){var e;if(super.delta(t),t.handled=!0,(!this.currentSeries||!this.lockToInitialSeries)&&(this.currentSeries=(e=this.plotView.actualModel)==null?void 0:e.getSeriesFromPoint(t.position,this.firesDistance)),!this.currentSeries){this.lockToInitialSeries||this.plotView.hideTracker(),this.isTrackAnnotations&&this.trackAnnotations(t.position);return}const i=this.plotView.actualModel;if(!i||!w.contains(i.plotArea,t.position.x,t.position.y))return;const r=Br.getNearestHit(this.currentSeries,t.position,this.snap,this.pointsOnly,this.firesDistance,this.checkDistanceBetweenPoints);r&&(r.plotModel=this.plotView.actualModel,this.plotView.showTracker(r),this.plotView.actualModel.raiseTrackerChanged(r))}started(t){var e;super.started(t),this.currentSeries=(e=this.plotView.actualModel)==null?void 0:e.getSeriesFromPoint(t.position,this.firesDistance),this.delta(t)}trackAnnotations(t){const e=this.plotView.actualModel;for(const i of e.annotations.filter(r=>r.toolTip).reverse()){if(!i.toolTip)continue;const r=new us(t,this.firesDistance);if(!i.hitTest(r))continue;const n=i.inverseTransform(t),a=new yt({position:t,dataPoint:n,text:i.toolTip,plotModel:this.plotView.actualModel});this.plotView.showTracker(a),e.raiseTrackerChanged(a);break}}}class Hs extends wr{constructor(t,e){super(t),l(this,"currentSeries"),l(this,"pointsOnly"),l(this,"snap"),l(this,"lockToInitialSeries"),l(this,"firesDistance"),l(this,"checkDistanceBetweenPoints"),this.snap=!0,this.pointsOnly=!1,this.lockToInitialSeries=!0,this.firesDistance=20,this.checkDistanceBetweenPoints=!1,this.setHandledForPanOrZoom=!1,e&&Object.assign(this,ae(e))}completed(t){super.completed(t),this.currentSeries=void 0,this.plotView.hideTracker(),this.plotView.actualModel&&this.plotView.actualModel.raiseTrackerChanged(void 0)}delta(t){super.delta(t),this.plotView.hideTracker()}started(t){var e;super.started(t),this.currentSeries=(e=this.plotView.actualModel)==null?void 0:e.getSeriesFromPoint(t.position,this.firesDistance),this.updateTracker(t.position)}updateTracker(t){var e;if((!this.currentSeries||!this.lockToInitialSeries)&&(this.currentSeries=(e=this.plotView.actualModel)==null?void 0:e.getSeriesFromPoint(t,this.firesDistance)),!this.currentSeries){this.lockToInitialSeries||this.plotView.hideTracker();return}const i=this.plotView.actualModel;if(!i||!w.contains(i.plotArea,t.x,t.y))return;const r=Br.getNearestHit(this.currentSeries,t,this.snap,this.pointsOnly,this.firesDistance,this.checkDistanceBetweenPoints);r&&(r.plotModel=this.plotView.actualModel,this.plotView.showTracker(r),this.plotView.actualModel.raiseTrackerChanged(r))}}class Q extends Co{constructor(t){super((e,i,r)=>t(e,i,r))}}class V{static init(){this.reset=new Q((t,e,i)=>this.handleReset(t,i)),this.resetAt=new Q((t,e,i)=>this.handleReset(t,i)),this.panAt=new Q((t,e,i)=>e.addMouseManipulator(t,new Vo(t),i)),this.zoomRectangle=new Q((t,e,i)=>e.addMouseManipulator(t,new _o(t),i)),this.track=new Q((t,e,i)=>e.addMouseManipulator(t,new Te(t,{snap:!1,pointsOnly:!1}),i)),this.snapTrack=new Q((t,e,i)=>e.addMouseManipulator(t,new Te(t,{snap:!0,pointsOnly:!1}),i)),this.pointsOnlyTrack=new Q((t,e,i)=>e.addMouseManipulator(t,new Te(t,{snap:!1,pointsOnly:!0}),i)),this.zoomWheel=new Q((t,e,i)=>this.handleZoomByWheel(t,i)),this.zoomWheelFine=new Q((t,e,i)=>this.handleZoomByWheel(t,i,.1)),this.zoomInAt=new Q((t,e,i)=>this.handleZoomAt(t,i,.05)),this.zoomOutAt=new Q((t,e,i)=>this.handleZoomAt(t,i,-.05)),this.hoverTrack=new Q((t,e,i)=>e.addHoverManipulator(t,new Te(t,{lockToInitialSeries:!1,snap:!1,pointsOnly:!1}),i)),this.hoverSnapTrack=new Q((t,e,i)=>e.addHoverManipulator(t,new Te(t,{lockToInitialSeries:!1,snap:!0,pointsOnly:!1}),i)),this.hoverPointsOnlyTrack=new Q((t,e,i)=>e.addHoverManipulator(t,new Te(t,{lockToInitialSeries:!1,snap:!1,pointsOnly:!0}),i)),this.snapTrackTouch=new Q((t,e,i)=>e.addTouchManipulator(t,new Hs(t,{snap:!0,pointsOnly:!1}),i)),this.pointsOnlyTrackTouch=new Q((t,e,i)=>e.addTouchManipulator(t,new Hs(t,{snap:!0,pointsOnly:!0}),i)),this.panZoomByTouch=new Q((t,e,i)=>e.addTouchManipulator(t,new wr(t),i)),this.panLeft=new Q((t,e,i)=>this.handlePan(t,i,-.1,0)),this.panRight=new Q((t,e,i)=>this.handlePan(t,i,.1,0)),this.panUp=new Q((t,e,i)=>this.handlePan(t,i,0,-.1)),this.panDown=new Q((t,e,i)=>this.handlePan(t,i,0,.1)),this.panLeftFine=new Q((t,e,i)=>this.handlePan(t,i,-.01,0)),this.panRightFine=new Q((t,e,i)=>this.handlePan(t,i,.01,0)),this.panUpFine=new Q((t,e,i)=>this.handlePan(t,i,0,-.01)),this.panDownFine=new Q((t,e,i)=>this.handlePan(t,i,0,.01)),this.zoomIn=new Q((t,e,i)=>this.handleZoomCenter(t,i,1)),this.zoomOut=new Q((t,e,i)=>this.handleZoomCenter(t,i,-1)),this.zoomInFine=new Q((t,e,i)=>this.handleZoomCenter(t,i,.1)),this.zoomOutFine=new Q((t,e,i)=>this.handleZoomCenter(t,i,-.1))}static handleReset(t,e){t.actualModel&&(e.handled=!0,t.actualModel.resetAllAxes(),t.invalidatePlot(!1))}static handleZoomAt(t,e,i){const r=Ws.isControlDown(e);new Us(t,i,r).started(e)}static handleZoomByWheel(t,e,i=1){const r=Ws.isControlDown(e);new Us(t,e.delta*.001*i,r).started(e)}static handleZoomCenter(t,e,i){t.actualModel&&(e.handled=!0,t.actualModel.zoomAllAxes(1+i*.12),t.invalidatePlot(!1))}static handlePan(t,e,i,r){t.actualModel&&(e.handled=!0,i*=t.actualModel.plotArea.width,r*=t.actualModel.plotArea.height,t.actualModel.panAllAxes(i,r),t.invalidatePlot(!1))}}l(V,"reset"),l(V,"resetAt"),l(V,"panZoomByTouch"),l(V,"panAt"),l(V,"zoomRectangle"),l(V,"zoomWheel"),l(V,"zoomWheelFine"),l(V,"track"),l(V,"snapTrack"),l(V,"snapTrackTouch"),l(V,"pointsOnlyTrack"),l(V,"pointsOnlyTrackTouch"),l(V,"hoverTrack"),l(V,"hoverSnapTrack"),l(V,"hoverPointsOnlyTrack"),l(V,"panLeft"),l(V,"panRight"),l(V,"panUp"),l(V,"panDown"),l(V,"panLeftFine"),l(V,"panRightFine"),l(V,"panUpFine"),l(V,"panDownFine"),l(V,"zoomInAt"),l(V,"zoomOutAt"),l(V,"zoomIn"),l(V,"zoomOut"),l(V,"zoomInFine"),l(V,"zoomOutFine");V.init();class En extends vo{constructor(){super(),K.bindMouseDown(this,Ct.Middle,V.zoomRectangle),K.bindMouseDown(this,Ct.Right,V.zoomRectangle,Z.Control),K.bindMouseDown(this,Ct.Left,V.zoomRectangle,Z.Control|Z.Alt),K.bindMouseDown(this,Ct.Middle,V.resetAt,Z.None,2),K.bindMouseDown(this,Ct.Right,V.resetAt,Z.Control,2),K.bindMouseDown(this,Ct.Left,V.resetAt,Z.Control|Z.Alt,2),K.bindKeyDown(this,xt.A,V.reset),K.bindKeyDown(this,xt.Home,V.reset),this.bindCore(new Ds,V.reset),K.bindMouseDown(this,Ct.Right,V.panAt),K.bindMouseDown(this,Ct.Left,V.panAt,Z.Alt),K.bindKeyDown(this,xt.Left,V.panLeft),K.bindKeyDown(this,xt.Right,V.panRight),K.bindKeyDown(this,xt.Up,V.panUp),K.bindKeyDown(this,xt.Down,V.panDown),K.bindKeyDown(this,xt.Left,V.panLeftFine,Z.Control),K.bindKeyDown(this,xt.Right,V.panRightFine,Z.Control),K.bindKeyDown(this,xt.Up,V.panUpFine,Z.Control),K.bindKeyDown(this,xt.Down,V.panDownFine,Z.Control),K.bindTouchDown(this,V.panZoomByTouch),K.bindMouseDown(this,Ct.Left,V.snapTrack),K.bindMouseDown(this,Ct.Left,V.track,Z.Control),K.bindMouseDown(this,Ct.Left,V.pointsOnlyTrack,Z.Shift),K.bindTouchDown(this,V.snapTrackTouch),K.bindMouseDown(this,Ct.XButton1,V.zoomInAt),K.bindMouseDown(this,Ct.XButton2,V.zoomOutAt),K.bindMouseWheel(this,V.zoomWheel),K.bindMouseWheel(this,V.zoomWheelFine,Z.Control),K.bindKeyDown(this,xt.Add,V.zoomIn),K.bindKeyDown(this,xt.Subtract,V.zoomOut),K.bindKeyDown(this,xt.PageUp,V.zoomIn),K.bindKeyDown(this,xt.PageDown,V.zoomOut),K.bindKeyDown(this,xt.Add,V.zoomInFine,Z.Control),K.bindKeyDown(this,xt.Subtract,V.zoomOutFine,Z.Control),K.bindKeyDown(this,xt.PageUp,V.zoomInFine,Z.Control),K.bindKeyDown(this,xt.PageDown,V.zoomOutFine,Z.Control)}}function js(o){return o instanceof Object&&"__isTransposable"in o}function Lo(o){o.__isTransposable=!0}class U{static inverseTransform(t,e,i){return t.inverseTransform(y(e,i))}static isTransposed(t){return t.xAxis.isVertical()}static orientate(t,e){return U.isTransposed(t)?y(e.y,e.x):e}static orientateVector(t,e){return e=ot(t.xAxis.isReversed?-e.x:e.x,t.yAxis.isReversed?-e.y:e.y),U.isTransposed(t)?ot(-e.y,-e.x):e}static orientateAlignment(t,e,i){if(t.xAxis.isReversed&&(e=-e),t.yAxis.isReversed&&(i=-i),U.isTransposed(t)){const r=-i;i=-e,e=r}return[e,i]}static transform(t,e,i){return t.transform($(e,i))}}class Qi{static getClippingRect(t){const e=w.fromScreenPoints(t.xAxis.screenMin,t.xAxis.screenMax),i=w.fromScreenPoints(t.yAxis.screenMin,t.yAxis.screenMax);return w.intersect(e,i)}static inverseTransform(t,e){return t.xAxis.inverseTransformPoint(e.x,e.y,t.yAxis)}static inverseTransformOrientated(t,e){return this.inverseTransform(t,U.orientate(t,e))}static transform(t,e){return t.xAxis.transformPoint(e.x,e.y,t.yAxis)}static transformOrientated(t,e){return U.orientate(t,this.transform(t,e))}}const rt={plotType:0,plotMargins:Dt(NaN),padding:Dt(8),background:p.Undefined,plotAreaBackground:p.Undefined,textColor:p.Black,titleColor:p.Automatic,subtitleColor:p.Automatic,defaultFont:"Segoe UI",defaultFontSize:12,titleToolTip:void 0,titleFont:void 0,titleFontSize:18,titleFontWeight:$e.Bold,subtitleFont:void 0,subtitleFontSize:14,subtitleFontWeight:$e.Normal,titlePadding:6,clipTitle:!0,titleClippingLength:.9,plotAreaBorderColor:p.Black,plotAreaBorderThickness:Dt(1),edgeRenderingMode:tt.Automatic,assignColorsToInvisibleSeries:!0,isLegendVisible:!0,axisTierDistance:4,title:void 0,subtitle:void 0,titleHorizontalAlignment:0,defaultColors:[F.fromRgb(78,154,6),F.fromRgb(200,141,0),F.fromRgb(204,0,0),F.fromRgb(32,74,135),p.Red,p.Orange,p.Yellow,p.Green,p.Blue,p.Indigo,p.Violet]},No={...cs,...rt};class zn extends ds{constructor(t){super(t),l(this,"_barSeriesManagers",[]),l(this,"_plotViewReference"),l(this,"_currentColorIndex",0),l(this,"_isDataUpdated",!1),l(this,"_lastPlotException"),l(this,"trackerChanged"),l(this,"updated"),l(this,"updating"),l(this,"defaultFont",rt.defaultFont),l(this,"defaultFontSize",rt.defaultFontSize),l(this,"_actualPlotMargins",Fi),l(this,"_annotations"),l(this,"_axes"),l(this,"_legends"),l(this,"background",p.Undefined),l(this,"defaultColors",rt.defaultColors),l(this,"edgeRenderingMode",rt.edgeRenderingMode),l(this,"assignColorsToInvisibleSeries",rt.assignColorsToInvisibleSeries),l(this,"isLegendVisible",rt.isLegendVisible),l(this,"padding",rt.padding),l(this,"_plotBounds",Le),l(this,"_plotAndAxisArea",Le),l(this,"_plotArea",Le),l(this,"axisTierDistance",rt.axisTierDistance),l(this,"plotAreaBackground",rt.plotAreaBackground),l(this,"plotAreaBorderColor",rt.plotAreaBorderColor),l(this,"plotAreaBorderThickness",rt.plotAreaBorderThickness),l(this,"plotMargins",rt.plotMargins),l(this,"plotType",rt.plotType),l(this,"_series"),l(this,"renderingDecorator"),l(this,"subtitle"),l(this,"subtitleFont"),l(this,"subtitleFontSize",rt.subtitleFontSize),l(this,"subtitleFontWeight",rt.subtitleFontWeight),l(this,"textColor",p.Black),l(this,"title"),l(this,"titleToolTip"),l(this,"titleColor",p.Automatic),l(this,"clipTitle",rt.clipTitle),l(this,"titleClippingLength",rt.titleClippingLength),l(this,"subtitleColor",p.Automatic),l(this,"titleHorizontalAlignment",rt.titleHorizontalAlignment),l(this,"_titleArea",Le),l(this,"titleFont"),l(this,"titleFontSize",rt.titleFontSize),l(this,"titleFontWeight",rt.titleFontWeight),l(this,"titlePadding",rt.titlePadding),l(this,"_defaultAngleAxis"),l(this,"_defaultMagnitudeAxis"),l(this,"_defaultXAxis"),l(this,"_defaultYAxis"),l(this,"_defaultColorAxis"),this._axes=ci(this),this._series=ci(this),this._annotations=ci(this),this._legends=ci(this),t&&this.applyOptions(t),q(this,rt,t)}applyOptions(t){Es(t,"_axes","_series","_annotations","_legends"),t.axes&&t.axes.length>0&&this._axes.push(...t.axes),t.series&&t.series.length>0&&this._series.push(...t.series),t.annotations&&t.annotations.length>0&&this._annotations.push(...t.annotations),t.legends&&t.legends.length>0&&this._legends.push(...t.legends),Es(t,"axes","series","annotations","legends")}get actualPlotMargins(){return this._actualPlotMargins}get plotView(){return this._plotViewReference}get annotations(){return this._annotations}get axes(){return this._axes}get legends(){return this._legends}get plotBounds(){return this._plotBounds}get width(){return this.plotBounds.width}get height(){return this.plotBounds.height}get plotAndAxisArea(){return this._plotAndAxisArea}get plotArea(){return this._plotArea}get series(){return this._series}get titleArea(){return this._titleArea}get defaultAngleAxis(){return this._defaultAngleAxis}get defaultMagnitudeAxis(){return this._defaultMagnitudeAxis}get defaultXAxis(){return this._defaultXAxis}get defaultYAxis(){return this._defaultYAxis}get defaultColorAxis(){return this._defaultColorAxis}get actualTitleFont(){return this.titleFont||this.defaultFont}get actualSubtitleFont(){return this.subtitleFont||this.defaultFont}attachPlotView(t){const e=this.plotView;if(e&&t&&e!==t)throw new Error("This PlotModel is already in use by some other PlotView control.");this._plotViewReference=t}invalidatePlot(t){var e;(e=this.plotView)==null||e.invalidatePlot(t)}getAxesFromPoint(t){let e,i,r,n=0;const a=w.right(this.plotArea),h=w.bottom(this.plotArea);t.x<this.plotArea.left&&(r=v.Left,n=this.plotArea.left),t.x>a&&(r=v.Right,n=a),t.y<this.plotArea.top&&(r=v.Top,n=this.plotArea.top),t.y>h&&(r=v.Bottom,n=h);for(const m of this.axes){if(!m.isAxisVisible||Zi(m))continue;if(m instanceof Ji){e=m;continue}if(m instanceof ii){i=m;continue}let u=NaN;if(m.isHorizontal()&&(u=m.inverseTransform(t.x)),m.isVertical()&&(u=m.inverseTransform(t.y)),u>=m.clipMinimum&&u<=m.clipMaximum){if(!r)m.isHorizontal()?e||(e=m):m.isVertical()&&(i||(i=m));else if(r===m.position){const c=m.positionTierMinShift,g=m.positionTierMaxShift,f=m.isHorizontal()?t.y:t.x,d=r===v.Top||r===v.Left;(f>=n+c&&f<n+g&&!d||f<=n-c&&f>n-g&&d)&&(m.isHorizontal()?J(e)&&(e=m):m.isVertical()&&J(i)&&(i=m))}}}return[e,i]}getDefaultColor(){return this.defaultColors[this._currentColorIndex++%this.defaultColors.length]}getDefaultLineStyle(){return this._currentColorIndex/this.defaultColors.length%Number(_.None)}getSeriesFromPoint(t,e=100){let i=B,r;const n=Ge(this.series);for(const a of n.filter(h=>h.isVisible)){const h=a.getNearestPoint(t,!0)||a.getNearestPoint(t,!1);if(!(h!=null&&h.position))continue;const m=Cs(t,h.position);m<i&&(r=a,i=m)}if(i<e)return r}toString(){return this.title||""}getLastPlotException(){return this._lastPlotException}update(t){try{this._lastPlotException=null,this.onUpdating(),this.ensureDefaultAxes();const e=this.series.filter(r=>r.isVisible);if(t||!this._isDataUpdated){for(const r of e)r.updateData();this._isDataUpdated=!0}this.updateBarSeriesManagers(),this.updateMaxMin(t),this.updateUnmanagedCategoryAxes();const i=this.assignColorsToInvisibleSeries?this.series:e;this.resetDefaultColor();for(const r of i)r.setDefaultValues();this.onUpdated()}catch(e){console.log(e),this._lastPlotException=e}}getAxis(t){if(!t)throw new Error("Axis key cannot be null.");const e=this.axes.find(i=>i.key===t);if(!e)throw new Error(`Cannot find axis with Key = "${t}"`);return e}getAxisOrDefault(t,e){return t?e:this.axes.find(i=>i.key===t)||e}resetAllAxes(){for(const t of this.axes)t.reset()}panAllAxes(t,e){for(const i of this.axes)i.pan(i.isHorizontal()?t:e)}zoomAllAxes(t){for(const e of this.axes)e.zoomAtCenter(t)}raiseTrackerChanged(t){const e=this.trackerChanged;e&&e(this,{hitResult:t})}onTrackerChanged(t){this.raiseTrackerChanged(t)}getHitTestElements(){const t=[],e=Ge(this.axes);for(const n of e.filter(a=>a.isAxisVisible&&a.layer===Ve.AboveSeries))t.push(n);const i=Ge(this.annotations);for(const n of i.filter(a=>a.layer===se.AboveSeries))t.push(n);const r=Ge(this.series);for(const n of r.filter(a=>a.isVisible))t.push(n);for(const n of i.filter(a=>a.layer===se.BelowSeries))t.push(n);for(const n of e.filter(a=>a.isAxisVisible&&a.layer===Ve.BelowSeries))t.push(n);for(const n of i.filter(a=>a.layer===se.BelowAxes))t.push(n);for(const n of this.legends)t.push(n);return t}onUpdated(){const t=this.updated;t&&t(this)}onUpdating(){const t=this.updating;t&&t(this)}updateAxisTransforms(){for(const t of this.axes)t.updateTransform(this.plotArea)}enforceCartesianTransforms(){const t=this.axes.filter(i=>!Zi(i));let e=Math.min(...t.map(i=>Math.abs(i.scale)));for(const i of t)i.zoomScale(e);e=Math.max(...t.map(i=>Math.abs(i.scale)));for(const i of t)i.zoomScale(e);for(const i of t)i.updateTransform(this.plotArea)}updateIntervals(){for(const t of this.axes)t.updateIntervals(this.plotArea)}ensureDefaultAxes(){const t=this.axes,e=this.series;if(this._defaultXAxis=t.find(i=>i.isHorizontal()&&i.isXyAxis()),this._defaultYAxis=t.find(i=>i.isVertical()&&i.isXyAxis()),this._defaultMagnitudeAxis=t.find(i=>i instanceof Ji),this._defaultAngleAxis=t.find(i=>i instanceof ii),this._defaultColorAxis=t.find(i=>Zi(i)),J(this.defaultXAxis)&&(this._defaultXAxis=this.defaultMagnitudeAxis),J(this.defaultYAxis)&&(this._defaultYAxis=this.defaultAngleAxis),this.plotType===2)J(this.defaultXAxis)&&(this._defaultXAxis=this._defaultMagnitudeAxis=new Ji),J(this.defaultYAxis)&&(this._defaultYAxis=this._defaultAngleAxis=new ii);else{let i=!1,r=!1;J(this.defaultXAxis)&&(this._defaultXAxis=new le({position:v.Bottom}),i=!0),J(this.defaultYAxis)&&(e.some(n=>n.isVisible&&n instanceof Pr)?this._defaultYAxis=new Ke({position:v.Left}):(this._defaultYAxis=new le({position:v.Left}),r=!0)),i&&this.defaultXAxis&&this.defaultYAxis instanceof Ke&&(this.defaultXAxis.minimumPadding=0),r&&this.defaultYAxis&&this.defaultXAxis instanceof Ke&&(this.defaultYAxis.minimumPadding=0)}e.some(i=>i.isVisible&&i.areAxesRequired())&&(t.includes(this.defaultXAxis)||(console.assert(this.defaultXAxis,"Default x-axis not created."),this.defaultXAxis&&this.axes.push(this.defaultXAxis)),t.includes(this.defaultYAxis)||(console.assert(this.defaultYAxis,"Default y-axis not created."),this.defaultYAxis&&this.axes.push(this.defaultYAxis)));for(const i of this.series)i.isVisible&&i.areAxesRequired()&&i.ensureAxes();for(const i of this.annotations)i.ensureAxes()}resetDefaultColor(){this._currentColorIndex=0}updateMaxMin(t){if(t){for(const e of this.axes)e.resetDataMaxMin();for(const e of this.series.filter(i=>i.isVisible))e.updateMaxMin()}for(const e of this.series.filter(i=>i.isVisible))e.updateAxisMaxMin();for(const e of this.axes)e.updateActualMaxMin()}updateBarSeriesManagers(){this._barSeriesManagers=[];const t=this.series.filter(i=>i.isVisible&&jo(i)).map(i=>i),e=new Map;for(const i of t){const r=[...e.keys()].find(n=>n.ca===i.categoryAxis&&n.va===i.valueAxis);if(r){e.get(r).push(i);continue}e.set({ca:i.categoryAxis,va:i.valueAxis},[i])}e.forEach((i,r)=>{const n=new Li(r.ca,r.va,i);n.update(),this._barSeriesManagers.push(n)})}updateUnmanagedCategoryAxes(){const t=this._barSeriesManagers.map(i=>i.categoryAxis),e=this.axes.filter(i=>i instanceof Ke).map(i=>i).filter(i=>!t.includes(i));for(const i of e){let r=0;!xe(i.dataMaximum)&&!j(i.dataMaximum)&&i.dataMaximum>0&&(r=Math.floor(i.dataMaximum)+1),i.updateLabels(r)}}render(t,e){return this.renderOverride(t,e)}async renderOverride(t,e){var i;const r=t.clipCount;let n;try{if(n=O.autoResetClip(t,e),this._lastPlotException){const a=`An exception of type ${this._lastPlotException.constructor.name} was thrown when updating the plot model.\r
${this._lastPlotException.stack}`;await this.renderErrorMessage(t,`OxyPlot exception: ${this._lastPlotException.message}`,a);return}this.renderingDecorator&&(t=this.renderingDecorator(t)),this._plotBounds=e,this._actualPlotMargins=Dt(j(this.plotMargins.left)?0:this.plotMargins.left,j(this.plotMargins.top)?0:this.plotMargins.top,j(this.plotMargins.right)?0:this.plotMargins.right,j(this.plotMargins.bottom)?0:this.plotMargins.bottom);for(const a of this.legends)a.ensureLegendProperties();for(let a=0;a<10&&(await this.updatePlotArea(t),this.updateAxisTransforms(),this.updateIntervals(),!!this.adjustPlotMargins(t));a++);if(this.plotType===1&&(this.enforceCartesianTransforms(),this.updateIntervals()),await this.renderBackgrounds(t),await this.renderAnnotations(t,se.BelowAxes),await this.renderAxes(t,Ve.BelowSeries),await this.renderAnnotations(t,se.BelowSeries),await this.renderSeries(t),await this.renderAnnotations(t,se.AboveSeries),await this.renderTitle(t),await this.renderBox(t),await this.renderAxes(t,Ve.AboveSeries),this.isLegendVisible&&await this.renderLegends(t),t.clipCount!==r+1)throw new Error("Unbalanced calls to IRenderContext.pushClip were made during rendering.")}catch(a){try{n==null||n.dispose()}catch(m){a=m}finally{n=void 0}debugger;for(console.log(a);t.clipCount>r;)t.popClip();const h=`An exception of type ${(i=a.constructor)==null?void 0:i.name} was thrown when rendering the plot model.\r
${a.stack}`;this._lastPlotException=a,await this.renderErrorMessage(t,`OxyPlot exception: ${a.message}`,h)}finally{n==null||n.dispose(),t.cleanUp()}}async renderErrorMessage(t,e,i,r=12){const n=y(10,10);await t.drawText(n,e,this.textColor,void 0,r,$e.Bold),await O.drawMultilineText(t,It(n,ot(0,r*1.5)),i,this.textColor,void 0,r,r*1.25)}adjustPlotMargins(t){const e=this.axes.filter(a=>a.isAxisVisible);e.forEach(a=>{a.measure(t)});let i=Fi;const r=(a,h)=>{switch(h){case v.Bottom:i=Dt(i.left,i.top,i.right,Math.max(i.bottom,a));break;case v.Left:i=Dt(Math.max(i.left,a),i.top,i.right,i.bottom);break;case v.Right:i=Dt(i.left,i.top,Math.max(i.right,a),i.bottom);break;case v.Top:i=Dt(i.left,Math.max(i.top,a),i.right,i.bottom);break}};for(let a=v.Left;a<=v.Bottom;a++){const h=e.filter(u=>u.position===a),m=this.adjustAxesPositions(h);r(m,a)}e.forEach(a=>{i=Di.include(i,a.desiredMargin)});let n=this.plotMargins;return n=Dt(j(n.left)?i.left:n.left,j(n.top)?i.top:n.top,j(n.right)?i.right:n.right,j(n.bottom)?i.bottom:n.bottom),Di.equals(n,this.actualPlotMargins)?!1:(this._actualPlotMargins=n,!0)}adjustAxesPositions(t){let e=0;const i=r=>{switch(r.position){case v.Left:return r.desiredMargin.left;case v.Right:return r.desiredMargin.right;case v.Top:return r.desiredMargin.top;case v.Bottom:return r.desiredMargin.bottom;default:throw new Error("We don't do this for polar axes")}};return t.reduce((r,n)=>{const a=n.positionTier,h=r.get(a);return h?h.push(n):r.set(a,[n]),r},new Map).forEach((r,n)=>{const a=Math.max(...r.map(i)),h=e;Math.abs(e)>1e-5&&(e+=this.axisTierDistance),e+=a,r.forEach(m=>{m.positionTierSize=a,m.positionTierMinShift=h,m.positionTierMaxShift=e})}),e}measureTitles(t){const e=t.measureText(this.title||"",this.actualTitleFont,this.titleFontSize,this.titleFontWeight),i=t.measureText(this.subtitle||"",this.subtitleFont||this.actualSubtitleFont,this.subtitleFontSize,this.subtitleFontWeight),r=e.height+i.height,n=Math.max(e.width,i.width);return at(n,r)}renderAnnotations(t,e){return this.renderPlotElements(this.annotations.filter(i=>i.layer===e),t,async i=>i.render(t))}async renderAxes(t,e){for(const i of this.axes.filter(r=>r.isAxisVisible&&r.layer===e))t.setToolTip(i.toolTip),await i.render(t,0);for(const i of this.axes.filter(r=>r.isAxisVisible&&r.layer===e))t.setToolTip(i.toolTip),await i.render(t,1);t.setToolTip(void 0)}async renderLegends(t){if(this.isLegendVisible)for(const e of this.legends.filter(i=>i.isLegendVisible))t.setToolTip(e.toolTip),await e.renderLegends(t)}async renderBackgrounds(t){this.axes.length>0&&F.isVisible(this.plotAreaBackground)&&await t.drawRectangle(this.plotArea,this.plotAreaBackground,p.Undefined,0,this.edgeRenderingMode);const e=this.series.filter(i=>i instanceof nt).map(i=>i).filter(i=>i.isVisible&&F.isVisible(i.background));for(const i of e)await t.drawRectangle(i.getScreenRectangle(),i.background,p.Undefined,0,this.edgeRenderingMode)}async renderBox(t){if(this.axes.length>0){const e=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness);await O.drawRectangle(t,this.plotArea,this.plotAreaBorderColor,this.plotAreaBorderThickness,e)}}async renderSeries(t){return this._barSeriesManagers.forEach(e=>{e.initializeRender()}),this.renderPlotElements(this.series.filter(e=>e.isVisible),t,async e=>e.render(t))}async renderPlotElements(t,e,i){let r=Pe;function n(a,h){return w.equals(a,h)}for(const a of t){const h=a.getClippingRect();n(h,r)||(n(r,Pe)||(e.popClip(),r=Pe),n(h,Pe)||(e.pushClip(h),r=h)),e.setToolTip(a.toolTip),await i(a)}n(r,Pe)||e.popClip(),e.setToolTip(void 0)}async renderTitle(t){let e;this.clipTitle&&(e=at(this.titleArea.width*this.titleClippingLength,B));const i=t.measureText(this.title||"",this.actualTitleFont,this.titleFontSize,this.titleFontWeight),r=(this.titleArea.left+w.right(this.titleArea))*.5;let n=this.titleArea.top;this.title&&(t.setToolTip(this.titleToolTip),await pe.drawMathText(t,y(r,n),this.title,F.getActualColor(this.titleColor,this.textColor),this.actualTitleFont,this.titleFontSize,this.titleFontWeight,0,N.Center,E.Top,e),n+=i.height,t.setToolTip(void 0)),this.subtitle&&await pe.drawMathText(t,y(r,n),this.subtitle,F.getActualColor(this.subtitleColor,this.textColor),this.actualSubtitleFont,this.subtitleFontSize,this.subtitleFontWeight,0,N.Center,E.Top,e)}async updatePlotArea(t){let e=Y(this.plotBounds.left+this.padding.left,this.plotBounds.top+this.padding.top,Math.max(0,this.width-this.padding.left-this.padding.right),Math.max(0,this.height-this.padding.top-this.padding.bottom));const i=this.measureTitles(t);if(i.height>0){const n=i.height+this.titlePadding;e=Y(e.left,e.top+n,e.width,Math.max(0,e.height-n))}let r=w.deflate(e,this.actualPlotMargins);if(this.isLegendVisible){let n=at(0,0),a=0;const h=this.legends.filter(m=>m.legendPlacement===ri.Outside&&m.isLegendVisible);for(const m of h.filter(u=>Po(u.legendPosition))){const u=m.allowUseFullExtent?e.width:r.width;let c=m.allowUseFullExtent?e.height:r.height;c=isNaN(m.legendMaxHeight)?c:Math.min(c,m.legendMaxHeight);const g=await m.getLegendSize(t,at(u,c));m.legendSize=g,n=at(Math.max(n.width,g.width),Math.max(n.height,g.height)),m.legendMargin>a&&(a=m.legendMargin)}(n.width>0||n.height>0)&&(r=Y(r.left+n.width+a,r.top,Math.max(0,r.width-(n.width+a)),r.height)),n=at(0,0),a=0;for(const m of h.filter(u=>Fo(u.legendPosition))){const u=m.allowUseFullExtent?e.width:r.width;let c=m.allowUseFullExtent?e.height:r.height;c=isNaN(m.legendMaxHeight)?c:Math.min(c,m.legendMaxHeight);const g=await m.getLegendSize(t,at(u,c));m.legendSize=g,n=at(Math.max(n.width,g.width),Math.max(n.height,g.height)),m.legendMargin>a&&(a=m.legendMargin)}(n.width>0||n.height>0)&&(r=Y(r.left,r.top,Math.max(0,r.width-(n.width+a)),r.height)),n=at(0,0),a=0;for(const m of h.filter(u=>Do(u.legendPosition))){const u=m.allowUseFullExtent?e.width:r.width;let c=m.allowUseFullExtent?e.height:r.height;c=isNaN(m.legendMaxHeight)?c:Math.min(c,m.legendMaxHeight);const g=await m.getLegendSize(t,at(u,c));m.legendSize=g,n=at(Math.max(n.width,g.width),Math.max(n.height,g.height)),m.legendMargin>a&&(a=m.legendMargin)}(n.width>0||n.height>0)&&(r=Y(r.left,r.top+n.height+a,r.width,Math.max(0,r.height-(n.height+a)))),n=at(0,0),a=0;for(const m of h.filter(u=>Io(u.legendPosition))){const u=m.allowUseFullExtent?e.width:r.width;let c=m.allowUseFullExtent?e.height:r.height;c=isNaN(m.legendMaxHeight)?c:Math.min(c,m.legendMaxHeight);const g=await m.getLegendSize(t,at(u,c));m.legendSize=g,n=at(Math.max(n.width,g.width),Math.max(n.height,g.height)),m.legendMargin>a&&(a=m.legendMargin)}(n.width>0||n.height>0)&&(r=Y(r.left,r.top,r.width,Math.max(0,r.height-(n.height+a))));for(const m of this.legends.filter(u=>u.legendPlacement===ri.Inside&&u.isLegendVisible)){let u=r.width,c=isNaN(m.legendMaxHeight)?r.height:Math.min(r.height,m.legendMaxHeight);m.legendPlacement===ri.Inside&&(u-=m.legendMargin*2,c-=m.legendMargin*2),m.legendSize=await m.getLegendSize(t,at(u,c))}}switch(r.height<0&&(r=Y(r.left,r.top,r.width,1)),r.width<0&&(r=Y(r.left,r.top,1,r.height)),this._plotArea=r,this._plotAndAxisArea=w.inflateAll(r,this.actualPlotMargins),this.titleHorizontalAlignment){case 1:this._titleArea=Y(this.plotBounds.left,this.plotBounds.top+this.padding.top,this.width,i.height+this.titlePadding*2);break;default:this._titleArea=Y(this.plotArea.left,this.plotBounds.top+this.padding.top,this.plotArea.width,i.height+this.titlePadding*2);break}for(const n of this.legends)n.legendArea=n.getLegendRectangle(n.legendSize)}toJSON(t){const e=mr(this,No,{excludeDefault:t==null?void 0:t.excludeDefault});return this._axes.length>0&&(e.axes=this.arrayToJson(this._axes,t)),this._legends.length>0&&(e.legends=this.arrayToJson(this._legends,t)),this._series.length>0&&(e.series=this.arrayToJson(this._series,t)),this._annotations.length>0&&(e.annotations=this.arrayToJson(this._annotations,t)),e}arrayToJson(t,e){const i=[];for(const r of t){if(!r.toJSON){console.warn(`'${r.getElementName()}' does not have a toJSON method`);continue}i.push(r.toJSON(e))}return i}}class Vt{static getDashArray(t){switch(t){case _.Solid:return;case _.Dash:return[4,1];case _.Dot:return[1,1];case _.DashDot:return[4,1,1,1];case _.DashDashDot:return[4,1,4,1,1,1];case _.DashDotDot:return[4,1,1,1,1,1];case _.DashDashDotDot:return[4,1,4,1,1,1,1,1];case _.LongDash:return[10,1];case _.LongDashDot:return[10,1,1,1];case _.LongDashDotDot:return[10,1,1,1,1,1];default:return}}}class Kt{constructor(t,e=1,i=_.Solid,r=X.Miter){l(this,"dashArray"),this.color=t,this.thickness=e,this.lineStyle=i,this.lineJoin=r,this.dashArray=Vt.getDashArray(i)}get actualDashArray(){return this.dashArray||Vt.getDashArray(this.lineStyle)}static create(t,e,i=_.Solid,r=X.Miter){if(!(F.isInvisible(t)||i===_.None||Math.abs(e)<=0))return new Kt(t,e,i,r)}}class ee{static findNearestPointOnPolyline(t,e){if(!e)throw new Error("points is null");let i=B,r=te;for(let n=0;n+1<e.length;n++){const a=e[n],h=e[n+1];if(bi(a)||bi(h))continue;const m=ee.findPointOnLine(t,a,h);if(bi(m))continue;const u=Jt(t,m).lengthSquared;u<i&&(r=m,i=u)}return r}static findPointOnLine(t,e,i){const r=i.x-e.x,n=i.y-e.y;let a=ee.findPositionOnLine(t,e,i);return isNaN(a)&&(a=0),a<0&&(a=0),a>1&&(a=1),y(e.x+a*r,e.y+a*n)}static findPositionOnLine(t,e,i){const r=i.x-e.x,n=i.y-e.y,a=(t.x-e.x)*r+(t.y-e.y)*n,h=r*r+n*n;return h<1e-6?NaN:a/h}static isPointInPolygon(t,e){if(!e)return!1;const i=e.length;let r=!1;for(let n=0,a=i-1;n<i;a=n++)e[n].y>t.y!=e[a].y>t.y&&t.x<(e[a].x-e[n].x)*((t.y-e[n].y)/(e[a].y-e[n].y))+e[n].x&&(r=!r);return r}static resamplePoints(t,e){const i=e*e,r=t.length,n=[];if(r>0){n.push(t[0]);let a=0;for(let h=1;h<r;h++)Ye(t[a],t[h])<i&&h!==r-1||(a=h,n.push(t[h]))}return n}static getCentroid(t){let e=0,i=0,r=0;for(let n=0;n<t.length;n++){const a=(n+1)%t.length,h=t[n].x*t[a].y-t[a].x*t[n].y;e+=(t[n].x+t[a].x)*h,i+=(t[n].y+t[a].y)*h,r+=h}return r*=.5,e/=6*r,i/=6*r,y(e,i)}}const Bo=.6,Eo=.62,zo=0,Oo=.62;class pe{static async drawMathText(t,e,i,r,n,a,h,m,u,c,g,f=!1){if(!i)return Wi;if(i.includes("^{")||i.includes("_{")){const d=e.x,b=e.y,x=await this.internalDrawMathText(t,d,b,0,0,i,r,n,a,h,!0,m);let R=0,M=0;switch(u){case N.Right:R=-x.width;break;case N.Center:R=-x.width*.5;break}switch(c){case E.Bottom:M=-x.height;break;case E.Middle:M=-x.height*.5;break}return await this.internalDrawMathText(t,d,b,R,M,i,r,n,a,h,!1,m),f?x:Wi}return await t.drawText(e,i,r,n,a,h,m,u,c,g),f?t.measureText(i,n,a,h):Wi}static async measureMathText(t,e,i,r,n){return e.includes("^{")||e.includes("_{")?this.internalDrawMathText(t,0,0,0,0,e,p.Black,i,r,n,!0,0):t.measureText(e,i,r,n)}static async internalDrawMathText(t,e,i,r,n,a,h,m,u,c,g,f){let d=0;const b=f*Math.PI/180,x=Et(Math.cos(b),5),R=Et(Math.sin(b),5);let M=e,S=e,T=e;const A=i;let P=i,C=i;const D=u*zo,k=u*Bo,L=u*Oo,et=u*Eo,ht=async(gt,Rt,Tt,ft)=>{if(!g){const H=e+(gt-e+r)*x-(Rt-i+n)*R,G=i+(gt-e+r)*R+(Rt-i+n)*x;await t.drawText(y(H,G),Tt,h,m,ft,c,f)}const dt=t.measureText(Tt,m,ft,c);return at(dt.width,dt.height)};for(;d<a.length;){if(d+1<a.length&&a[d]==="^"&&a[d+1]==="{"){const ft=a.indexOf("}",d);if(ft!==-1){const dt=mi(a,d+2,ft-d-2);d=ft+1;const H=M,G=A+D,st=await ht(H,G,dt,L);S=Math.max(H+st.width,S),P=Math.max(G+st.height,P),T=Math.min(H,T),C=Math.min(G,C);continue}}if(d+1<a.length&&a[d]==="_"&&a[d+1]==="{"){const ft=a.indexOf("}",d);if(ft!==-1){const dt=mi(a,d+2,ft-d-2);d=ft+1;const H=M,G=A+k,st=await ht(H,G,dt,et);S=Math.max(H+st.width,S),P=Math.max(G+st.height,P),T=Math.min(H,T),C=Math.min(G,C);continue}}const gt=jr(a.split(""),["^","_"],d+1);let Rt;gt===-1?(Rt=mi(a,d),d=a.length):(Rt=mi(a,d,gt-d),d=gt),M=S+2;const Tt=await ht(M,A,Rt,u);S=Math.max(M+Tt.width,S),P=Math.max(A+Tt.height,P),T=Math.min(M,T),C=Math.min(A,C),M=S}return at(S-T,P-C)}}class Be{constructor(){l(this,"rendersToScreen"),this.rendersToScreen=!0}static isStraightLine(t,e){return Math.abs(t.x-e.x)<1e-5||Math.abs(t.y-e.y)<1e-5}static isStraightLine2(t){for(let e=1;e<t.length;e++)if(!this.isStraightLine(t[e-1],t[e]))return!1;return!0}async drawEllipse(t,e,i,r,n){const a=Be.createEllipse(t);await this.drawPolygon(a,e,i,r,n,void 0,X.Miter)}async drawEllipses(t,e,i,r,n){for(const a of t)await this.drawEllipse(a,e,i,r,n)}async drawLineSegments(t,e,i,r,n,a){for(let h=0;h+1<t.length;h+=2)await this.drawLine([t[h],t[h+1]],e,i,r,n,a)}async drawPolygons(t,e,i,r,n,a,h){for(const m of t)await this.drawPolygon(m,e,i,r,n,a,h)}async drawRectangle(t,e,i,r,n){const a=Be.createRectangle(t);await this.drawPolygon(a,e,i,r,n,void 0,X.Miter)}async drawRectangles(t,e,i,r,n){for(const a of t)await this.drawRectangle(a,e,i,r,n)}setToolTip(t){}cleanUp(){}static createEllipse(t,e=40){const i=w.center(t),r=i.x,n=i.y,a=t.width/2,h=t.height/2,m=new Array(e);for(let u=0;u<e;u++){const c=Math.PI*2*u/e;m[u]=y(r+Math.cos(c)*a,n+Math.sin(c)*h)}return m}static createRectangle(t){const e=oe.fromRect(t);return[y(e.left,e.top),y(e.left,e.bottom),y(e.right,e.bottom),y(e.right,e.top)]}shouldUseAntiAliasingForRect(t){switch(t){case tt.PreferGeometricAccuracy:return!0;default:return!1}}shouldUseAntiAliasingForEllipse(t){switch(t){case tt.PreferSpeed:return!1;default:return!0}}shouldUseAntiAliasingForLine(t,e){switch(t){case tt.PreferSpeed:case tt.PreferSharpness:return!1;case tt.Automatic:if(Be.isStraightLine2(e))return!1;break;case tt.Adaptive:if(Be.isStraightLine2(e))return!1;break;default:return!0}return!0}}const Ie=class{static getActualEdgeRenderingMode(t,e){return t===tt.Automatic?e:t}static async drawReducedLine(t,e,i,r,n,a,h,m,u,c){e.length!==0&&(u?u.length=0:u=[],this.reducePoints(e,i,u),await t.drawLine(u,r,n,a,h,m),u.length=0,Xe(u,e),c&&c(u))}static async drawReducedPolygon(t,e,i,r,n,a,h,m=_.Solid,u=X.Miter){if(e.length===0||m===_.None)return;const c=[];this.reducePoints(e,i,c),await t.drawPolygon(c,r,n,a,h,Vt.getDashArray(m),u)}static async drawImage(t,e,i,r,n,a,h,m){await t.drawImage(e,0,0,e.width,e.height,i,r,n,a,h,m)}static async drawMultilineText(t,e,i,r,n,a=10,h=$e.Normal,m=12){const u=Vn.splitLines(i);for(let c=0;c<u.length;c++)await t.drawText(y(e.x,e.y+c*m),u[c],r,void 0,a,h)}static async drawLine(t,e,i,r,n,a,h){a&&await t.drawLine([y(e,i),y(r,n)],a.color,a.thickness,h,a.actualDashArray,a.lineJoin)}static async drawLineSegments(t,e,i,r){i&&await t.drawLineSegments(e,i.color,i.thickness,r,i.actualDashArray,i.lineJoin)}static async drawMarker(t,e,i,r,n,a,h,m,u){await this.drawMarkers(t,[e],i,r,[n],a,h,m,u)}static async drawMarkers(t,e,i,r,n,a,h,m,u,c=0,g=te){if(i===ct.None)return;const f=[],d=[],b=[],x=[],R=new Set;let M=0;for(const S of e){if(c>1){const A=Math.floor((S.x-g.x)/c),P=Math.floor((S.y-g.y)/c),C=fe(A<<16)+fe(P);if(R.has(C)){M++;continue}R.add(C)}const T=M<n.length?M:0;this.addMarkerGeometry(S,i,r,n[T],f,d,b,x),M++}u===tt.Automatic&&(u=tt.PreferGeometricAccuracy),f.length>0&&await t.drawEllipses(f,a,h,m,u),d.length>0&&await t.drawRectangles(d,a,h,m,u),b.length>0&&await t.drawPolygons(b,a,h,m,u),x.length>0&&await t.drawLineSegments(x,h,m,u)}static async drawCircle(t,e,i,r,n,a,h,m){await t.drawEllipse(Y(e-r,i-r,r*2,r*2),n,a,h,m)}static async drawCircle2(t,e,i,r,n,a,h){await this.drawCircle(t,e.x,e.y,i,r,n,a,h)}static async fillCircle(t,e,i,r,n){await this.drawCircle(t,e.x,e.y,i,r,p.Undefined,0,n)}static async fillRectangle(t,e,i,r){await t.drawRectangle(e,i,p.Undefined,0,r)}static async drawRectangle(t,e,i,r,n){if(r.left===r.right&&r.left===r.top&&r.left===r.bottom){await t.drawRectangle(e,p.Undefined,i,r.left,n);return}const a=w.right(e),h=w.bottom(e),m=e.left-r.left/2+.5,u=a+r.right/2-.5,c=e.top-r.top/2+.5,g=h+r.bottom/2-.5,f=[y(m,e.top),y(u,e.top)],d=[y(a,c),y(a,g)],b=[y(m,h),y(u,h)],x=[y(e.left,c),y(e.left,g)];await t.drawLine(f,i,r.top,n,void 0,X.Miter),await t.drawLine(d,i,r.right,n,void 0,X.Miter),await t.drawLine(b,i,r.bottom,n,void 0,X.Miter),await t.drawLine(x,i,r.left,n,void 0,X.Miter)}static measureText(t,e,i,r,n,a){const h=t.measureText(e,i,r,n);return this.measureRotatedRectangleBound(h,a)}static autoResetClip(t,e){return new $o(t,e)}static addMarkerGeometry(t,e,i,r,n,a,h,m){if(e===ct.Custom){if(!i)throw new Error("The outline should be set when MarkerType is 'Custom'.");const c=i.map(g=>y(t.x+g.x*r,t.y+g.y*r));h.push(c);return}switch(e){case ct.Circle:n.push(Y(t.x-r,t.y-r,r*2,r*2));break;case ct.Square:a.push(Y(t.x-r,t.y-r,r*2,r*2));break;case ct.Diamond:h.push([y(t.x,t.y-this.M2*r),y(t.x+this.M2*r,t.y),y(t.x,t.y+this.M2*r),y(t.x-this.M2*r,t.y)]);break;case ct.Triangle:h.push([y(t.x-r,t.y+this.M1*r),y(t.x+r,t.y+this.M1*r),y(t.x,t.y-this.M2*r)]);break;case ct.Plus:case ct.Star:m.push(y(t.x-r,t.y)),m.push(y(t.x+r,t.y)),m.push(y(t.x,t.y-r)),m.push(y(t.x,t.y+r));break}const u=this.M3;switch(e){case ct.Cross:case ct.Star:m.push(y(t.x-r*u,t.y-r*u)),m.push(y(t.x+r*u,t.y+r*u)),m.push(y(t.x-r*u,t.y+r*u)),m.push(y(t.x+r*u,t.y-r*u));break}}static measureRotatedRectangleBound(t,e){const i=Ni.getBounds(t,e,N.Center,E.Middle);return at(i.width,i.height)}static reducePoints(t,e,i){const r=t.length;if(r===0)return;i.push(t[0]);let n=0;for(let a=1;a<r;a++){const h=t[a],m=h.x-t[n].x,u=h.y-t[n].y;(m*m+u*u>e||a===r-1)&&(i.push(y(h.x,h.y)),n=a)}}static transformAndInterpolateLines(t,e,i,r){const n=t.xAxis,a=t.yAxis;if(n.isLogarithmic()||a.isLogarithmic()){let h=!1,m=!0,u=vs;for(const c of e)if(ss(c)||n.isLogarithmic()&&c.x<=0||a.isLogarithmic()&&c.y<=0)m=!0;else{if(m)i.length>0&&i.push(Ci),m=!1,h=!0;else if(h){const g=Yr(c,u);this.interpolatePoints(f=>t.transform(di(u,g.times(f))),i,r,h)}u=c}}else{let h=!0;for(const m of e)ss(m)?h=!0:(h&&i.length>0&&i.push(Ci),i.push(t.transform(m)),h=!1)}}static interpolatePoints(t,e,i,r){const n=i*i,a=[],h=[];a.push(1),h.push(t(1));let m=0,u=t(0);for(r&&e.push(u);a.length>0;){let c=a[a.length-1],g=h[h.length-1];Ye(g,u)<n?(m=c,u=g,e.push(g),a.pop(),h.pop()):(c=m+(c-m)/2,g=t(c),a.push(c),h.push(g))}}};l(Ie,"M1",Math.tan(Math.PI/6)),l(Ie,"M2",Math.sqrt(1+Ie.M1*Ie.M1)),l(Ie,"M3",Math.tan(Math.PI/4));let O=Ie;class $o{constructor(t,e){l(this,"renderContext"),l(this,"_disposed",!1),this.renderContext=t,t.pushClip(e)}dispose(){this._disposed||(this._disposed=!0,this.renderContext.popClip())}}class $n extends Be{constructor(){super(...arguments),l(this,"clipStack",[])}popClip(){if(this.clipStack.length===0)throw new Error("Unbalanced call to popClip.");const t=this.clipStack.pop();if(this.clipStack.length>0){const e=this.clipStack[this.clipStack.length-1];w.equals(t,e)||(this.resetClip(),this.setClip(e))}else this.resetClip()}pushClip(t){if(this.clipStack.length>0){const e=this.clipStack[this.clipStack.length-1],i=w.intersect(t,e);w.equals(e,i)||(this.resetClip(),this.setClip(i)),this.clipStack.push(i)}else this.setClip(t),this.clipStack.push(t)}get clipCount(){return this.clipStack.length}}class Nt{constructor(t){l(this,"tension"),this.tension=t}createSplineDp(t,e,i){return Nt.createSplineForDp(t,this.tension,void 0,e,i)}createSplineSp(t,e,i){return Nt.createSpline(t,this.tension,void 0,e,i)}static createSplineForDp(t,e,i,r,n){const a=t.map(u=>y(u.x,u.y)),h=Nt.createSpline(a,e,i,r,n),m=[];for(const u of h)m.push($(u.x,u.y));return m}static createSpline(t,e,i,r,n){const a=[];if(!t)return a;const h=t.length;if(h<1)return a;if(h<2)return a.push(...t),a;if(h===2)r?(Nt.segment(a,t[1],t[0],t[1],t[0],e,e,n),Nt.segment(a,t[0],t[1],t[0],t[1],e,e,n)):Nt.segment(a,t[0],t[0],t[1],t[1],e,e,n);else{const m=i&&i.length>0;for(let u=0;u<h;u++){const c=m?i[u%i.length]:e,g=m?i[(u+1)%i.length]:e;u===0?Nt.segment(a,r?t[h-1]:t[0],t[0],t[1],t[2],c,g,n):u===h-2?Nt.segment(a,t[u-1],t[u],t[u+1],r?t[0]:t[u+1],c,g,n):u===h-1?r&&Nt.segment(a,t[u-1],t[u],t[0],t[1],c,g,n):Nt.segment(a,t[u-1],t[u],t[u+1],t[u+2],c,g,n)}}return a}static segment(t,e,i,r,n,a,h,m,u=1e3){const c=a*(r.x-e.x),g=a*(r.y-e.y),f=h*(n.x-i.x),d=h*(n.y-i.y),b=c+f+2*i.x-2*r.x,x=g+d+2*i.y-2*r.y,R=-2*c-f-3*i.x+3*r.x,M=-2*g-d-3*i.y+3*r.y,S=c,T=g,A=i.x,P=i.y,C=Math.min(u,Math.round((Math.abs(i.x-r.x)+Math.abs(i.y-r.y))/m));for(let D=1;D<C;D++){const k=D/(C-1),L=y(b*k*k*k+R*k*k+S*k+A,x*k*k*k+M*k*k+T*k+P);t.push(L)}}}class Oe{constructor(t){l(this,"alpha"),l(this,"maxSegments"),this.alpha=t,this.maxSegments=100}createSplineDp(t,e,i){return Oe.createSplineForDp(t,this.alpha,e,i,this.maxSegments)}createSplineSp(t,e,i){return Oe.createSpline(t,this.alpha,e,i,this.maxSegments)}static createSplineForDp(t,e,i,r,n){const a=t.map(u=>y(u.x,u.y)),h=this.createSpline(a,e,i,r,n),m=[];for(const u of h)m.push($(u.x,u.y));return m}static createSpline(t,e,i,r,n){const a=[];if(t===void 0)return a;const h=t.length;if(h<1)return a;if(h<2)return a.push(...t),a;if(h===2)i?(this.segment(a,t[1],t[0],t[1],t[0],e,r,n),this.segment(a,t[0],t[1],t[0],t[1],e,r,n)):this.segment(a,t[0],t[0],t[1],t[1],e,r,n);else for(let m=0;m<h;m++)m===0?this.segment(a,i?t[h-1]:t[0],t[0],t[1],t[2],e,r,n):m===h-2?this.segment(a,t[m-1],t[m],t[m+1],i?t[0]:t[m+1],e,r,n):m===h-1?i&&this.segment(a,t[m-1],t[m],t[0],t[1],e,r,n):this.segment(a,t[m-1],t[m],t[m+1],t[m+2],e,r,n);return a}static segment(t,e,i,r,n,a,h,m){if($i(i,r)){t.push(i);return}$i(e,i)&&(e=this.prev(i,r)),$i(r,n)&&(n=this.prev(r,i));const u=0,c=this.getT(u,e,i,a),g=this.getT(c,i,r,a),f=this.getT(g,r,n,a);let d=Math.round((Math.abs(i.x-r.x)+Math.abs(i.y-r.y))/h);d=Math.max(0,d),d=Math.min(m,d);for(let b=c;b<g;b+=(g-c)/d){const x=this.sum(this.mult((c-b)/(c-u),e),this.mult((b-u)/(c-u),i)),R=this.sum(this.mult((g-b)/(g-c),i),this.mult((b-c)/(g-c),r)),M=this.sum(this.mult((f-b)/(f-g),r),this.mult((b-g)/(f-g),n)),S=this.sum(this.mult((g-b)/(g-u),x),this.mult((b-u)/(g-u),R)),T=this.sum(this.mult((f-b)/(f-c),R),this.mult((b-c)/(f-c),M)),A=this.sum(this.mult((g-b)/(g-c),S),this.mult((b-c)/(g-c),T));t.push(A)}}static getT(t,e,i,r){const n=Math.pow(i.x-e.x,2)+Math.pow(i.y-e.y,2),a=Math.sqrt(n);return Math.pow(a,r)+t}static mult(t,e){return y(e.x*t,e.y*t)}static equals(t,e){return t.x===e.x&&t.y===e.y}static prev(t,e){return y(t.x-1e-4*(e.x-t.x),t.y-1e-4*(e.y-t.y))}static sum(t,e){return y(t.x+e.x,t.y+e.y)}}class gi{}l(gi,"CanonicalSpline",new Nt(.5)),l(gi,"CatmullRomSpline",new Oe(.5)),l(gi,"UniformCatmullRomSpline",new Oe(0)),l(gi,"ChordalCatmullRomSpline",new Oe(1));const qe={background:p.Undefined,isVisible:!0,renderInLegend:!0,title:void 0,legendKey:void 0,seriesGroupName:void 0,trackerKey:void 0},Yo={...Ps,...qe};class Xo extends cr{constructor(t){super(t),l(this,"background",qe.background),l(this,"isVisible",qe.isVisible),l(this,"title"),l(this,"legendKey"),l(this,"seriesGroupName"),l(this,"renderInLegend",qe.renderInLegend),l(this,"trackerStringFormatter"),l(this,"trackerKey"),it(this,"trackerStringFormatter",t),q(this,qe,t,{exclude:["trackerStringFormatter"]})}getNearestPoint(t,e){}hitTestOverride(t){const e=this.getNearestPoint(t.point,!0)||this.getNearestPoint(t.point,!1);if(e!=null&&e.position)return Cs(e.position,t.point)>t.tolerance?void 0:{element:this,nearestHitPoint:e.position,item:e.item,index:e.index}}}const kr={itemsSource:void 0},Is={...Yo,...kr};class Oi extends Xo{constructor(t){super(t),l(this,"itemsSource"),q(this,kr,t)}static getItem(t,e){if(!(!t||e<0)&&e<t.length&&e>=0)return t[e]}getItem(t){if(this.itemsSource)return Oi.getItem(this.itemsSource,t)}getElementDefaultValues(){return Is}}const Ar={trackerStringFormatter:void 0,xAxisKey:void 0,yAxisKey:void 0},_t={...Is,DefaultXYAxisSeriesOptions:Ar},Si=class wi extends Oi{constructor(t){super(t),l(this,"trackerStringFormatter"),l(this,"_maxX",0),l(this,"_maxY",0),l(this,"_minX",0),l(this,"_minY",0),l(this,"_xAxis"),l(this,"xAxisKey"),l(this,"_yAxis"),l(this,"yAxisKey"),l(this,"isXMonotonic",!1),l(this,"windowStartIndex",0),this.trackerStringFormatter=wi.DefaultTrackerFormatter,it(this,"trackerStringFormatter",t),Lo(this),q(this,Ar,t,{exclude:["trackerStringFormatter"]})}get maxX(){return this._maxX}set maxX(t){this._maxX=t}get maxY(){return this._maxY}set maxY(t){this._maxY=t}get minX(){return this._minX}set minX(t){this._minX=t}get minY(){return this._minY}set minY(t){this._minY=t}get xAxis(){return this._xAxis}get yAxis(){return this._yAxis}getClippingRect(){return Qi.getClippingRect(this)}getScreenRectangle(){return this.getClippingRect()}inverseTransform(t){return Qi.inverseTransformOrientated(this,t)}async renderLegend(t,e){}transform(t){return Qi.transformOrientated(this,t)}areAxesRequired(){return!0}ensureAxes(){this._xAxis=this.xAxisKey?this.plotModel.getAxis(this.xAxisKey):this.plotModel.defaultXAxis,this._yAxis=this.yAxisKey?this.plotModel.getAxis(this.yAxisKey):this.plotModel.defaultYAxis}isUsing(t){return!1}setDefaultValues(){}updateAxisMaxMin(){this.xAxis.include(this.minX),this.xAxis.include(this.maxX),this.yAxis.include(this.minY),this.yAxis.include(this.maxY)}updateData(){this.windowStartIndex=0}updateMaxMin(){this.minX=this.minY=this.maxX=this.maxY=Number.NaN}getNearestInterpolatedPointInternal(t,e,i){if(!this.xAxis||!this.yAxis||!t)return;let r=te,n=is,a=-1,h=B;for(let m=e;m+1<t.length;m++){const u=t[m],c=t[m+1];if(!this.isValidPoint(u)||!this.isValidPoint(c))continue;const g=this.transform(u),f=this.transform(c),d=ee.findPointOnLine(i,g,f);if(bi(d))continue;const b=Jt(i,d).lengthSquared;if(b<h){const x=Jt(f,g).length,R=x>0?Jt(d,g).length/x:0;n=this.inverseTransform(d),r=d,h=b,a=m+R}}if(h<B){const m=this.getItem(Math.round(a));return new yt({series:this,dataPoint:n,position:r,item:m,index:a})}}getNearestPointInternal(t,e,i){let r=te,n=is,a=-1,h=B,m=e;for(const u of t.slice(e)){if(!this.isValidPoint(u)){m++;continue}const c=U.transform(this,u.x,u.y),g=Jt(c,i).lengthSquared;g<h&&(n=u,r=c,h=g,a=m),m++}if(h<B){const u=this.getItem(Math.round(a));return new yt({series:this,dataPoint:n,position:r,item:u,index:a})}}isValidPoint(t){return this.isValidPoint2(t.x,t.y)}isValidPoint2(t,e){return!!(this.xAxis&&this.xAxis.isValidValue(t)&&this.yAxis&&this.yAxis.isValidValue(e))}internalUpdateMaxMin(t){if(!t)throw new Error("points is null");if(this.isXMonotonic=!0,t.length===0)return;let e=this.minX,i=this.minY,r=this.maxX,n=this.maxY;isNaN(e)&&(e=B),isNaN(i)&&(i=B),isNaN(r)&&(r=W),isNaN(n)&&(n=W);let a=W;for(const h of t){const m=h.x,u=h.y;this.isValidPoint2(m,u)&&(m<a&&(this.isXMonotonic=!1),m<e&&(e=m),m>r&&(r=m),u<i&&(i=u),u>n&&(n=u),a=m)}e<B&&(this.minX=e),i<B&&(this.minY=i),r>W&&(this.maxX=r),n>W&&(this.maxY=n)}internalUpdateMaxMin2(t,e,i,r,n){if(!t)throw new Error("items is null");if(this.isXMonotonic=!0,t.length===0)return;let a=this.minX,h=this.minY,m=this.maxX,u=this.maxY;isNaN(a)&&(a=B),isNaN(h)&&(h=B),isNaN(m)&&(m=W),isNaN(u)&&(u=W);let c=W,g=W;for(const f of t){const d=e(f),b=i(f),x=r(f),R=n(f);!this.isValidPoint2(d,x)||!this.isValidPoint2(b,R)||((d<c||b<g)&&(this.isXMonotonic=!1),d<a&&(a=d),b>m&&(m=b),x<h&&(h=x),R>u&&(u=R),c=d,g=b)}a<B&&(this.minX=a),h<B&&(this.minY=h),m>W&&(this.maxX=m),u>W&&(this.maxY=u)}verifyAxes(){if(!this.xAxis)throw new Error("XAxis not defined.");if(!this.yAxis)throw new Error("YAxis not defined.")}updateWindowStartIndex(t,e,i,r){return r=this.findWindowStartIndex(t,e,i,r),r>0&&r--,r}findWindowStartIndex(t,e,i,r){let n=0,a=t.length-1;for(;a>0&&isNaN(e(t[a]));)a-=1;let h=a,m=Math.max(0,Math.min(h,r));const u=c=>{for(;c<=a;){const g=e(t[c]);if(isNaN(g))c+=1;else return g}return e(t[a])};for(;n<h;){const c=u(m);if(c===i){n=m;break}else c>i?h=m-1:n=m;if(n>=h)break;const g=u(h),f=u(n),d=(h-n+1)/(g-f);m=n+Math.round((i-f)*d),m=Math.max(n+1,Math.min(m,h))}for(;n>0&&e(t[n])>i;)n-=1;return n}formatDefaultTrackerString(t,e,i){var r,n,a,h;if(!this.trackerStringFormatter)return;const m={item:t,title:this.title||""};return e&&(m.xTitle=((r=this.xAxis)==null?void 0:r.title)??wi.defaultXAxisTitle,m.xValue=(n=this.xAxis)==null?void 0:n.getValue(e.x),m.yTitle=((a=this.yAxis)==null?void 0:a.title)??wi.defaultYAxisTitle,m.yValue=(h=this.yAxis)==null?void 0:h.getValue(e.y)),i&&i(m),this.trackerStringFormatter(m)}getJsonIgnoreProperties(){return[...super.getJsonIgnoreProperties(),"isXMonotonic","windowStartIndex"]}getElementDefaultValues(){return _t}};l(Si,"DefaultTrackerFormatter",function(o){return`${o.title||""}
${o.xTitle}: ${o.xValue}
${o.yTitle}: ${o.yValue}`}),l(Si,"defaultXAxisTitle","X"),l(Si,"defaultYAxisTitle","Y");let nt=Si;const ps={canTrackerInterpolatePoints:!1,points:void 0,dataFieldX:void 0,dataFieldY:void 0,mapping:void 0},Vs={..._t,...ps};class Wo extends nt{constructor(t){super(t),l(this,"_points",[]),l(this,"_itemsSourcePoints",[]),l(this,"canTrackerInterpolatePoints",ps.canTrackerInterpolatePoints),l(this,"dataFieldX"),l(this,"dataFieldY"),l(this,"mapping"),t!=null&&t.points&&(t.points.forEach(e=>this._points.push(e)),delete t.points),q(this,ps,t)}get points(){return this._points}get actualPoints(){return this.itemsSource?this._itemsSourcePoints:this._points}getNearestPoint(t,e){if(e&&!this.canTrackerInterpolatePoints)return;let i;return e&&(i=this.getNearestInterpolatedPointInternal(this.actualPoints,0,t)),i||(i=this.getNearestPointInternal(this.actualPoints,0,t)),i&&this.trackerStringFormatter&&(i.text=this.formatDefaultTrackerString(i.item,i.dataPoint)),i}updateData(){this.itemsSource&&this.updateItemsSourcePoints()}updateMaxMin(){super.updateMaxMin(),this.internalUpdateMaxMin(this.actualPoints)}getItem(t){const e=this.actualPoints;return!this.itemsSource&&e&&t<e.length?e[t]:super.getItem(t)}clearItemsSourcePoints(){this._itemsSourcePoints&&(this._itemsSourcePoints.length=0)}updateItemsSourcePoints(){if(!this.itemsSource)return;const t=this.itemsSource;if(this.mapping){this.clearItemsSourcePoints();for(const e of t)this._itemsSourcePoints.push(this.mapping(e));return}this.clearItemsSourcePoints();for(const e of t){const i=this.convertToDataPoint(e);i&&this._itemsSourcePoints.push(i)}}convertToDataPoint(t){if(t){if($r(t))return t;if(this.dataFieldX&&this.dataFieldY){const e=this.xAxis?this.xAxis.itemToDouble(t[this.dataFieldX]):Number(t[this.dataFieldX]),i=this.yAxis?this.yAxis.itemToDouble(t[this.dataFieldY]):Number(t[this.dataFieldY]);return $(e,i)}if(Ao(t))return t.getDataPoint();throw new Error(`Cannot convert item ${t} to DataPoint`)}}getElementDefaultValues(){return Vs}}const pt={color:p.Automatic,brokenLineColor:p.Undefined,brokenLineStyle:_.Solid,brokenLineThickness:0,labelMargin:6,lineJoin:X.Bevel,lineStyle:_.Automatic,lineLegendPosition:0,markerFill:p.Automatic,markerResolution:0,markerSize:3,markerStroke:p.Automatic,markerStrokeThickness:1,markerType:ct.None,minimumSegmentLength:2,strokeThickness:2,canTrackerInterpolatePoints:!0,dashes:void 0,decimator:void 0,labelStringFormatter:void 0,markerOutline:void 0,interpolationAlgorithm:void 0},ue={...Vs,...pt},Tr=class vr extends Wo{constructor(t){super(t),l(this,"_outputBuffer"),l(this,"_contiguousScreenPointsBuffer"),l(this,"_decimatorBuffer",[]),l(this,"_defaultColor",p.Undefined),l(this,"_defaultMarkerFill",p.Undefined),l(this,"_defaultLineStyle",_.Solid),l(this,"_smoothedPoints",[]),l(this,"color",pt.color),l(this,"brokenLineColor",pt.brokenLineColor),l(this,"brokenLineStyle",pt.brokenLineStyle),l(this,"brokenLineThickness",pt.brokenLineThickness),l(this,"dashes"),l(this,"decimator"),l(this,"labelStringFormatter"),l(this,"labelMargin",pt.labelMargin),l(this,"lineJoin",pt.lineJoin),l(this,"lineStyle",pt.lineStyle),l(this,"lineLegendPosition",pt.lineLegendPosition),l(this,"markerFill",pt.markerFill),l(this,"markerOutline"),l(this,"markerResolution",pt.markerResolution),l(this,"markerSize",pt.markerSize),l(this,"markerStroke",pt.markerStroke),l(this,"markerStrokeThickness",pt.markerStrokeThickness),l(this,"markerType",pt.markerType),l(this,"minimumSegmentLength",pt.minimumSegmentLength),l(this,"interpolationAlgorithm"),l(this,"strokeThickness",pt.strokeThickness),it(this,"labelStringFormatter",t),q(this,pt,t,{exclude:["labelStringFormatter"]})}getElementName(){return"LineSeries"}get actualColor(){return F.getActualColor(this.color,this._defaultColor)}get actualMarkerFill(){return F.getActualColor(this.markerFill,this._defaultMarkerFill)}get actualLineStyle(){return this.lineStyle!=_.Automatic?this.lineStyle:this._defaultLineStyle}get actualDashArray(){return this.dashes??Vt.getDashArray(this.actualLineStyle)}get smoothedPoints(){return this._smoothedPoints}getNearestPoint(t,e){if(e&&(F.isInvisible(this.actualColor)||this.strokeThickness===0||!this.canTrackerInterpolatePoints))return;const i=this.trackerStringFormatter;if(e&&this.interpolationAlgorithm){const r=this.getNearestInterpolatedPointInternal(this.smoothedPoints,0,t);return r&&i&&(r.text=i({item:r.item,title:this.title,xTitle:this.xAxis.title??nt.defaultXAxisTitle,xValue:this.xAxis.getValue(r.dataPoint.x),yTitle:this.yAxis.title??nt.defaultYAxisTitle,yValue:this.yAxis.getValue(r.dataPoint.y)})),r}return super.getNearestPoint(t,e)}async render(t){const e=this.actualPoints;!e||e.length===0||(this.verifyAxes(),await this.renderPoints(t,e),this.labelStringFormatter&&await this.renderPointLabels(t),this.lineLegendPosition!==0&&this.title&&await this.renderLegendOnLine(t))}async renderLegend(t,e){const i=w.right(e),r=w.bottom(e),n=(e.left+i)/2,a=(e.top+r)/2,h=[y(e.left,a),y(i,a)];await t.drawLine(h,this.getSelectableColor(this.actualColor),this.strokeThickness,this.edgeRenderingMode,this.actualDashArray);const m=y(n,a);await O.drawMarker(t,m,this.markerType,this.markerOutline,this.markerSize,this.actualMarkerFill,this.markerStroke,this.markerStrokeThickness,this.edgeRenderingMode)}setDefaultValues(){this.lineStyle===_.Automatic&&(this._defaultLineStyle=this.plotModel.getDefaultLineStyle()),F.isAutomatic(this.color)&&(this._defaultColor=this.plotModel.getDefaultColor()),F.isAutomatic(this.markerFill)&&(this._defaultMarkerFill=F.isAutomatic(this.color)?this._defaultColor:this.color)}updateMaxMin(){if(this.interpolationAlgorithm){if(super.updateMaxMin(),this.resetSmoothedPoints(),this.smoothedPoints.every(i=>isNaN(i.x)))return;const t=this.smoothedPoints.filter(i=>!isNaN(i.x)).map(i=>i.x),e=this.smoothedPoints.filter(i=>!isNaN(i.y)).map(i=>i.y);this.minX=mt(t),this.minY=mt(e),this.maxX=Mt(t),this.maxY=Mt(e)}else super.updateMaxMin()}async renderPoints(t,e){let i;const r=this.brokenLineThickness>0&&this.brokenLineStyle!==_.None,n=r?Vt.getDashArray(this.brokenLineStyle):void 0,a=r?[]:void 0;this._contiguousScreenPointsBuffer||(this._contiguousScreenPointsBuffer=[]);let h=0,m=B;if(this.isXMonotonic){const u=this.xAxis.clipMinimum;m=this.xAxis.clipMaximum,this.windowStartIndex=this.updateWindowStartIndex(e,c=>c.x,u,this.windowStartIndex),h=this.windowStartIndex}for(let u=h;u<e.length;u++){const{result:c,pointIdx:g,previousContiguousLineSegmentEndPoint:f}=this.extractNextContiguousLineSegment(e,u,i,m,a,this._contiguousScreenPointsBuffer);if(u=g,i=f,!c)break;if(r){if(a&&a.length>0){const d=F.isAutomatic(this.brokenLineColor)?this.actualColor:this.brokenLineColor;await t.drawLineSegments(a,d,this.brokenLineThickness,this.edgeRenderingMode,n,this.lineJoin),a.length=0}}else i=void 0;this.decimator?(this._decimatorBuffer?this._decimatorBuffer.length=0:this._decimatorBuffer=[],this.decimator(this._contiguousScreenPointsBuffer,this._decimatorBuffer),await this.renderLineAndMarkers(t,this._decimatorBuffer)):await this.renderLineAndMarkers(t,this._contiguousScreenPointsBuffer),this._contiguousScreenPointsBuffer.length=0}}extractNextContiguousLineSegment(t,e,i,r,n,a){let h=$(0,0),m=!1;for(;e<t.length;e++){if(h=t[e],h.x>r)return{result:!1,pointIdx:e,previousContiguousLineSegmentEndPoint:i};if(m=this.isValidPoint(h),m)break}if(!m)return{result:!1,pointIdx:e,previousContiguousLineSegmentEndPoint:i};let u=this.transform(h);i&&(n.push(i),n.push(u)),a.push(u);let c=0;for(e++;e<t.length&&(h=t[e],c+=h.x>r?1:0,!(c>1||!this.isValidPoint(h)));e++)u=this.transform(h),a.push(u);return i=u,{result:!0,pointIdx:e,previousContiguousLineSegmentEndPoint:i}}async renderPointLabels(t){if(!this.labelStringFormatter)return;let e=-1;for(const i of this.actualPoints){if(e++,!this.isValidPoint(i))continue;const r=It(this.transform(i),ot(0,-this.labelMargin)),n=this.getItem(e),a=this.labelStringFormatter(n,[i.x,i.y]);await t.drawText(r,a,this.actualTextColor,this.actualFont,this.actualFontSize,this.actualFontWeight,0,N.Center,E.Bottom)}}async renderLegendOnLine(t){if(!this.title)return;let e,i,r=E.Middle,n=4;switch(this.lineLegendPosition){case 1:e=this.actualPoints[0],i=N.Right,n=-n;break;case 2:e=this.actualPoints[this.actualPoints.length-1],i=N.Left;break;case 0:return;default:throw new Error("Invalid LineLegendPosition")}const a=U.orientateAlignment(this,i,r);i=a[0],r=a[1];const h=U.orientateVector(this,ot(n,0)),m=It(this.transform(e),h);await t.drawText(m,this.title,this.actualTextColor,this.actualFont,this.actualFontSize,this.actualFontWeight,0,i,r)}async renderLineAndMarkers(t,e){let i=e;if(this.interpolationAlgorithm){const r=ee.resamplePoints(e,this.minimumSegmentLength);i=this.interpolationAlgorithm.createSplineSp(r,!1,.25)}if(this.strokeThickness>0&&this.actualLineStyle!==_.None&&await this.renderLine(t,i),this.markerType!==ct.None){const r=this.markerResolution>0?U.transform(this,this.minX,this.minY):te;await O.drawMarkers(t,e,this.markerType,this.markerOutline,[this.markerSize],this.actualMarkerFill,this.markerStroke,this.markerStrokeThickness,this.edgeRenderingMode,this.markerResolution,r)}}async renderLine(t,e){const i=this.actualDashArray;this._outputBuffer||(this._outputBuffer=[]),await O.drawReducedLine(t,e,this.minimumSegmentLength*this.minimumSegmentLength,this.getSelectableColor(this.actualColor),this.strokeThickness,this.edgeRenderingMode,i,this.lineJoin,this._outputBuffer)}resetSmoothedPoints(){const t=Math.abs(Math.max(this.maxX-this.minX,this.maxY-this.minY)/vr.ToleranceDivisor);this._smoothedPoints=this.interpolationAlgorithm.createSplineDp(this.actualPoints,!1,t)}getElementDefaultValues(){return ue}toJSON(t){var e;const i=super.toJSON(t);return(e=this.points)!=null&&e.length&&(i.points=this.points),i}};l(Tr,"ToleranceDivisor",200);let Yn=Tr;function Uo(o,t,e){const i={categoryIndex:-1,value:0,color:p.Automatic};return J(o)?i:Object.assign({},i,ae(o))}function qt(o,t){return o.categoryIndex<0?t:o.categoryIndex}const Ht={barWidth:1,strokeColor:p.Black,strokeThickness:0,labelColor:p.Undefined,labelMargin:0,labelAngle:0,labelPlacement:Bt.Outside,labelStringFormatter:void 0,items:[]},_s={..._t,...Ht};class Qt extends nt{constructor(t){super(t),l(this,"barWidth",Ht.barWidth),l(this,"itemsSourceItems"),l(this,"strokeColor",Ht.strokeColor),l(this,"strokeThickness",Ht.strokeThickness),l(this,"_manager"),l(this,"validItems",[]),l(this,"validItemsIndexInversion",new Map),l(this,"labelColor",Ht.labelColor),l(this,"labelMargin",Ht.labelMargin),l(this,"labelAngle",Ht.labelAngle),l(this,"labelPlacement",Ht.labelPlacement),l(this,"items",[]),q(this,Ht,t)}get manager(){return this._manager}set manager(t){this._manager=t}get actualItems(){return this.itemsSource?this.itemsSourceItems:this.items}getActualBarWidth(){if(!this.manager)return 0;const t=this.getCategoryAxis();return this.barWidth/(1+t.gapWidth)/this.manager.getMaxWidth()}get categoryAxis(){return this.getCategoryAxis()}getCategoryAxis(){if(!(this.yAxis instanceof Ke))throw new Error("BarSeries requires a CategoryAxis on the Y Axis.");return this.yAxis}get valueAxis(){return this.xAxis}getItem(t){return this.itemsSource||!this.actualItems||this.actualItems.length===0?super.getItem(t):this.actualItems[t]}clearItemsSourceItems(){this.itemsSourceItems&&(this.itemsSourceItems.length=0)}isUsing(t){return this.xAxis===t||this.yAxis===t}async renderLabel(t,e,i,r,n,a,h,...m){const u=[];if(m.length)u.push(...m);else if("value"in e)u.push(e.value);else if("start"in e&&"end"in e)u.push(e.start),u.push(e.end);else throw new Error(`RenderLabel automatic value determination not implemented for ${this.constructor.name}. Please populate the labelValues parameter.`);const c=h?h(e,u):"";let g;const f=(a+n)/2,d=Math.sign(r-i);let b=os(this.labelMargin,0).times(d),x=ot(0,0);const R=O.measureText(t,c,this.actualFont,this.actualFontSize,this.actualFontWeight,this.labelAngle),M=(U.isTransposed(this)?R.height:R.width)/2,S=U.transform;switch(this.labelPlacement){case Bt.Inside:g=S(this,r,f),b=b.negate(),x=ot(-d*M,0);break;case Bt.Outside:g=S(this,r,f),x=ot(d*M,0);break;case Bt.Middle:g=S(this,(r+i)/2,f),b=os(0,0);break;case Bt.Base:g=S(this,i,f),x=ot(d*M,0);break;default:throw new Error("Invalid label placement")}const T=U.orientateVector;g=It(It(g,T(this,b)),T(this,x)),await t.drawText(g,c,this.actualTextColor,this.actualFont,this.actualFontSize,this.actualFontWeight,this.labelAngle,N.Center,E.Middle)}updateAxisMaxMin(){this.xAxis.include(this.minX),this.xAxis.include(this.maxX)}updateData(){this.clearItemsSourceItems(),!(!this.itemsSource||this.itemsSource.length==0)&&(this.updateFromDataFields()||(this.itemsSourceItems||(this.itemsSourceItems=[]),this.itemsSourceItems.push(...this.itemsSource)))}updateValidData(){this.validItems.length=0,this.validItemsIndexInversion.clear();const t=this.manager.categories.length;for(let e=0;e<this.actualItems.length;e++){const i=this.actualItems[e];i&&qt(i,e)<t&&this.isValid(i)&&(this.validItemsIndexInversion.set(this.validItems.length,e),this.validItems.push(i))}}getJsonIgnoreProperties(){return[...super.getJsonIgnoreProperties(),"itemsSourceItems","validItems","validItemsIndexInversion"]}}l(Qt,"DefaultCategoryAxisTitle","Category"),l(Qt,"DefaultValueAxisTitle","Value");const Ho=function(o){return`${o.title||""}
${o.category}: ${o.value}`},jt={fillColor:p.Automatic,negativeFillColor:p.Undefined,labelMargin:2,labelAngle:0,stackGroup:"",strokeThickness:0,baseValue:0,baseLine:NaN,isStacked:!1,overlapsStack:!1,trackerStringFormatter:Ho,colorField:void 0,labelStringFormatter:void 0,valueField:void 0},Cr={..._s,...jt};class Pr extends Qt{constructor(t){super(t),l(this,"_defaultFillColor",p.Undefined),l(this,"trackerStringFormatter"),l(this,"baseValue",jt.baseValue),l(this,"baseLine",jt.baseLine),l(this,"_actualBaseLine",NaN),l(this,"colorField"),l(this,"fillColor",jt.fillColor),l(this,"isStacked",jt.isStacked),l(this,"overlapsStack",jt.overlapsStack),l(this,"labelStringFormatter"),l(this,"negativeFillColor",jt.negativeFillColor),l(this,"stackGroup",jt.stackGroup),l(this,"valueField"),l(this,"actualBarRectangles"),it(this,"labelStringFormatter",t),q(this,jt,t,{exclude:["labelStringFormatter"]})}getElementName(){return"BarSeries"}get actualBaseLine(){return this._actualBaseLine}set actualBaseLine(t){this._actualBaseLine=t}get actualFillColor(){return F.getActualColor(this.fillColor,this._defaultFillColor)}getNearestPoint(t,e){if(!this.actualBarRectangles||this.validItems.length===0)return;let i=0;for(const r of this.actualBarRectangles){if(w.containsPoint(r,t)){const n=this.validItems[i],a=qt(n,i),h=$(a,this.validItems[i].value),m=this.getItem(this.validItemsIndexInversion.get(i));return new yt({series:this,dataPoint:h,position:t,item:m,index:i,text:this.getTrackerText(n,m,a)})}i++}}renderLegend(t,e){const i=w.right(e),r=w.bottom(e),n=(e.left+i)/2,a=(e.top+r)/2,h=(r-e.top)*.8,m=h;return t.drawRectangle(Y(n-.5*m,a-.5*h,m,h),this.getSelectableColor(this.actualFillColor),this.strokeColor,this.strokeThickness,this.edgeRenderingMode)}setDefaultValues(){F.isAutomatic(this.fillColor)&&(this._defaultFillColor=this.plotModel.getDefaultColor())}updateAxisMaxMin(){super.updateAxisMaxMin(),this.computeActualBaseLine(),this.xAxis.include(this.actualBaseLine)}computeActualBaseLine(){if(j(this.baseLine))if(this.xAxis.isLogarithmic()){const t=(this.actualItems||[]).map(i=>i.value),e=mt(t.filter(i=>i>0),1);this.actualBaseLine=Math.max(e/10,this.baseValue)}else this.actualBaseLine=0;else this.actualBaseLine=this.baseLine}updateMaxMin(){if(super.updateMaxMin(),this.validItems.length===0)return;const t=this.getCategoryAxis();let e=B,i=W;const r=this.manager;if(this.isStacked){const n=t.actualLabels;for(let a=0;a<n.length;a++){let h=0;const m=this.validItems.filter(b=>qt(b,h++)===a).map(b=>b.value).concat([0]);let u=m.filter(b=>b<=0).reduce((b,x)=>b+x,0),c=m.filter(b=>b>=0).reduce((b,x)=>b+x,0);const g=r.getStackIndex(this.stackGroup),f=r.getCurrentMinValue(g,a);isNaN(f)||(u+=f),r.setCurrentMinValue(g,a,u);const d=r.getCurrentMaxValue(g,a);!this.overlapsStack&&!isNaN(d)&&(c+=d),r.setCurrentMaxValue(g,a,c),e=Math.min(e,u+this.baseValue),i=Math.max(i,c+this.baseValue)}}else{const n=this.validItems.map(a=>a.value).concat([0]);e=mt(n),i=Mt(n),this.baseValue<e&&(e=this.baseValue),this.baseValue>i&&(i=this.baseValue)}this.minX=e,this.maxX=i}getTrackerText(t,e,i){if(!this.trackerStringFormatter)return;const r=this.getCategoryAxis(),n=this.xAxis;return this.trackerStringFormatter({item:e,title:this.title,category:r.formatValue(i),value:n==null?void 0:n.getValue(t.value)})}isValid(t){return this.xAxis.isValidValue(t.value)}async renderItem(t,e,i,r,n,a){let h=n.color;F.isAutomatic(h)&&(h=this.actualFillColor,n.value<0&&!F.isUndefined(this.negativeFillColor)&&(h=this.negativeFillColor));const m=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness);await t.drawRectangle(a,this.getSelectableFillColor(h),this.strokeColor,this.strokeThickness,m)}async render(t){if(this.actualBarRectangles=[],this.validItems.length===0)return;const e=this.manager,i=this.yAxis,r=this.xAxis,n=U.transform,a=this.getActualBarWidth(),h=this.isStacked?e.getStackIndex(this.stackGroup):0;for(let m=0;m<this.validItems.length;m++){const u=this.validItems[m],c=qt(u,m),g=u.value;let f=NaN;this.isStacked&&!this.overlapsStack&&(f=e.getCurrentBaseValue(h,c,g<0)),j(f)&&(f=this.baseValue);const d=this.isStacked?f+g:g;if(i.isLogarithmic()&&!i.isValidValue(d))continue;let b;this.isStacked?b=e.getCategoryValue(c,h,a):b=c-.5+e.getCurrentBarOffset(c),this.isStacked&&e.setCurrentBaseValue(h,c,g<0,d);const x=r.isLogarithmic()&&!r.isValidValue(f),R=n(this,x?r.clipMinimum:f,b),M=n(this,d,b+a),S=w.fromScreenPoints(R,M);this.actualBarRectangles.push(S),await this.renderItem(t,d,b,a,u,S),this.labelStringFormatter&&await this.renderLabel(t,u,f,d,b,b+a,this.labelStringFormatter),this.isStacked||e.increaseCurrentBarOffset(c,a)}}updateFromDataFields(){if(!this.valueField)return!1;if(!this.itemsSource||this.itemsSource.length==0)return!0;this.itemsSourceItems=this.itemsSourceItems||[];for(const t of this.itemsSource){if(J(t))continue;const e=t[this.valueField],i=Uo();i.value=J(e)?NaN:e;let r=p.Automatic;this.colorField&&t[this.colorField]&&F.isOxyColor(t[this.colorField])&&(r=t[this.colorField]),i.color=r,this.itemsSourceItems.push(i)}return!0}getElementDefaultValues(){return Cr}}class Li{constructor(t,e,i){if(l(this,"currentBarOffset"),l(this,"currentMaxValue"),l(this,"currentMinValue"),l(this,"currentNegativeBaseValues"),l(this,"currentPositiveBaseValues"),l(this,"maxWidth",NaN),l(this,"_categoryAxis"),l(this,"_series"),l(this,"_valueAxis"),l(this,"_barOffset"),l(this,"_stackedBarOffset"),l(this,"_stackIndexMapping",new Map),!t.plotModel)throw new Error("The category axis must be part of a plot model.");this._categoryAxis=t,this._valueAxis=e,this._series=i;for(const r of this._series)r.manager=this}get categoryAxis(){return this._categoryAxis}get managedSeries(){return this._series}get plotModel(){return this.categoryAxis.plotModel}get valueAxis(){return this._valueAxis}get categories(){return this._categoryAxis.actualLabels}get stackIndexMapping(){return this._stackIndexMapping}getCategoryValue(t,e,i){const r=this._stackedBarOffset[e][t],n=this._stackedBarOffset[e+1][t];return t-.5+(n+r-i)*.5}getCurrentBarOffset(t){return this.currentBarOffset?this.currentBarOffset[t]:0}getCurrentBaseValue(t,e,i){return i?this.currentNegativeBaseValues[t][e]:this.currentPositiveBaseValues[t][e]}getCurrentMaxValue(t,e){return this.currentMaxValue?this.currentMaxValue[t][e]:0}getCurrentMinValue(t,e){return this.currentMinValue?this.currentMinValue[t][e]:0}getMaxWidth(){return this.maxWidth}getStackIndex(t){const e=this._stackIndexMapping.get(t);return ne(e)?-1:e}increaseCurrentBarOffset(t,e){this.currentBarOffset&&(this.currentBarOffset[t]+=e)}initializeRender(){this.resetCurrentValues()}setCurrentBaseValue(t,e,i,r){i?this.currentNegativeBaseValues[t][e]=r:this.currentPositiveBaseValues[t][e]=r}setCurrentMaxValue(t,e,i){this.currentMaxValue[t][e]=i}setCurrentMinValue(t,e,i){this.currentMinValue[t][e]=i}update(){this.categoryAxis.updateLabels(Math.max(...this.managedSeries.map(t=>t.actualItems.length))),this.updateBarOffsets(),this.updateValidData(),this.resetCurrentValues()}static hasCategory(t,e){return t.actualItems.length>e&&t.actualItems[e].categoryIndex<0?!0:t.actualItems.some(i=>i.categoryIndex===e)}resetCurrentValues(){this.currentBarOffset=[...this._barOffset||[]];const t=this.categoryAxis.actualLabels,e=this._stackIndexMapping.size;e>0?(this.currentPositiveBaseValues=re(e,t.length,Number.NaN),this.currentNegativeBaseValues=re(e,t.length,Number.NaN),this.currentMaxValue=re(e,t.length,Number.NaN),this.currentMinValue=re(e,t.length,Number.NaN)):(this.currentPositiveBaseValues=void 0,this.currentNegativeBaseValues=void 0,this.currentMaxValue=void 0,this.currentMinValue=void 0)}updateBarOffsets(){if(this.categories.length===0){this.maxWidth=Number.NaN,this._stackedBarOffset=void 0,this._stackIndexMapping.clear();return}const t=new Array(this.categories.length).fill(0),e=new Map;this._barOffset=new Array(this.categories.length).fill(0);const i=this.managedSeries.filter(h=>Gs(h)).map(h=>h),r=Array.from(i.filter(h=>h.isStacked).reduce((h,m)=>h.set(m.stackGroup,(h.get(m.stackGroup)||[]).concat(m)),new Map).values());for(const h of r){const m=Math.max(...h.map(u=>u.barWidth));e.set(h[0].stackGroup,m);for(let u=0;u<this.categories.length;u++)h.some(c=>Li.hasCategory(c,u))&&(t[u]+=m)}for(const h of this.managedSeries.filter(m=>!Gs(m)||!m.isStacked))for(let m=0;m<this.categories.length;m++){let u=h.actualItems.filter(c=>c.categoryIndex===m).length;h.actualItems.length>m&&h.actualItems[m].categoryIndex<0&&u++,t[m]+=h.barWidth*u}this.maxWidth=Math.max(...t),this._stackedBarOffset=re(r.length+1,this.categories.length,0);const n=1/(1+this.categoryAxis.gapWidth)/this.maxWidth;for(let h=0;h<this.categories.length;h++)this._barOffset[h]=.5-t[h]*n*.5;for(let h=0;h<r.length;h++){const m=r[h];for(let u=0;u<this.categories.length;u++)this._stackedBarOffset[h][u]=this._barOffset[u],m.some(c=>Li.hasCategory(c,u))&&(this._barOffset[u]+=e.get(m[0].stackGroup)*n)}for(let h=0;h<this.categories.length;h++)this._stackedBarOffset[r.length][h]=this._barOffset[h];this._stackIndexMapping.clear();let a=0;for(const h of r.map(m=>m[0].stackGroup).sort())this._stackIndexMapping.set(h,a++)}updateValidData(){for(const t of this.managedSeries)t.updateValidData()}}function jo(o){return o&&!J(o.barWidth)&&o.categoryAxis}const Go={categoryIndex:-1,color:p.Automatic,end:0,start:0};function Ko(o){return Object.assign({},Go,ae(o))}const Ms={fillColor:p.Automatic,strokeThickness:1,labelMargin:4,labelPlacement:Bt.Middle,colorField:void 0,endField:void 0,startField:void 0},Zo={..._s,...Ms},Jo=class Fr extends Qt{constructor(t){super(t),l(this,"_defaultFillColor",p.Undefined),l(this,"trackerStringFormatter"),l(this,"colorField"),l(this,"endField"),l(this,"fillColor",Ms.fillColor),l(this,"isStacked",!0),l(this,"overlapsStack",!0),l(this,"labelStringFormatter",function(e,i){return`${i[0]} - ${i[1]}`}),l(this,"stackGroup",""),l(this,"startField"),l(this,"actualBarRectangles",[]),this.trackerStringFormatter=Fr.DefaultTrackerStringFormatter,it(this,"trackerStringFormatter",t),q(this,Ms,t,{exclude:["trackerStringFormatter"]})}getElementName(){return"IntervalBarSeries"}get actualFillColor(){return F.getActualColor(this.fillColor,this._defaultFillColor)}getNearestPoint(t,e){for(let i=0;i<this.actualBarRectangles.length;i++){const r=this.actualBarRectangles[i];if(!w.containsPoint(r,t))continue;const n=this.getItem(this.validItemsIndexInversion.get(i)),a=qt(n,i),h=(this.validItems[i].start+this.validItems[i].end)/2,m=$(a,h),u=this.getCategoryAxis(),c=this.xAxis,g=this.trackerStringFormatter({item:n,title:this.title,categoryTitle:u.title??Qt.DefaultCategoryAxisTitle,categoryValue:u.formatValue(a),valueTitle:c.title??Qt.DefaultValueAxisTitle});return new yt({series:this,dataPoint:m,position:t,item:n,index:i,text:g})}}async renderLegend(t,e){const i=w.right(e),r=w.bottom(e),n=(e.left+i)/2,a=(e.top+r)/2,h=(r-e.top)*.8,m=h;await t.drawRectangle(Y(n-.5*m,a-.5*h,m,h),this.getSelectableFillColor(this.actualFillColor),this.strokeColor,this.strokeThickness,this.edgeRenderingMode)}setDefaultValues(){F.isAutomatic(this.fillColor)&&(this._defaultFillColor=this.plotModel.getDefaultColor())}updateMaxMin(){if(super.updateMaxMin(),this.validItems.length===0)return;let t=B,e=W;for(const i of this.validItems)t=Math.min(t,i.start),t=Math.min(t,i.end),e=Math.max(e,i.start),e=Math.max(e,i.end);this.minX=t,this.maxX=e}isValid(t){return this.xAxis.isValidValue(t.start)&&this.xAxis.isValidValue(t.end)}async render(t){if(this.actualBarRectangles=[],this.validItems.length===0)return;const e=this.getActualBarWidth(),i=this.manager.getStackIndex(this.stackGroup),r=U.transform,n=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness);for(let a=0;a<this.validItems.length;a++){const h=this.validItems[a],m=qt(h,a),u=this.manager.getCategoryValue(m,i,e),c=r(this,h.start,u),g=r(this,h.end,u+e),f=w.fromScreenPoints(c,g);this.actualBarRectangles.push(f),await t.drawRectangle(f,this.getSelectableFillColor(F.getActualColor(h.color,this.actualFillColor)),this.strokeColor,this.strokeThickness,n),this.labelStringFormatter&&await this.renderLabel(t,this.getItem(a),h.start,h.end,u,u+e,this.labelStringFormatter)}}updateFromDataFields(){var t;if(!this.startField||!this.endField||!this.itemsSource)return!1;for(const e of this.itemsSource){const i=lt(e,this.startField,NaN),r=lt(e,this.endField,NaN),n=lt(e,this.colorField,p.Automatic);(t=this.itemsSourceItems)==null||t.push(Ko({start:i,end:r,color:n}))}return!0}getElementDefaultValues(){return Zo}};l(Jo,"DefaultTrackerStringFormatter",function(o){var t,e;return`${o.title}
${o.categoryTitle}: ${o.categoryValue}
${o.valueTitle}: ${(t=o.item)==null?void 0:t.start} - ${(e=o.item)==null?void 0:e.end}`});function Gs(o){return o&&!ne(o.isStacked)&&typeof o.isStacked=="boolean"&&!ne(o.stackGroup)&&typeof o.stackGroup=="string"}const ki={errorStrokeThickness:1,errorWidth:.4},qo={...Cr,...ki},Qo=class Dr extends Pr{constructor(t){super(t),l(this,"errorStrokeThickness",ki.errorStrokeThickness),l(this,"errorWidth",ki.errorWidth),this.trackerStringFormatter=Dr.DefaultTrackerStringFormatter,q(this,ki,t)}getElementName(){return"ErrorBarSeries"}updateMaxMin(){if(super.updateMaxMin(),this.validItems.length===0)return;let t=B,e=W;if(this.isStacked){const i=this.getCategoryAxis().actualLabels,r=this.manager;for(let n=0;n<i.length;n++){let a=0;const h=this.validItems.filter(b=>qt(b,a++)===n),m=h.map(b=>b.value).concat([0]);let u=m.filter(b=>b<=0).reduce((b,x)=>b+x,0),c=m.filter(b=>b>=0).reduce((b,x)=>b+x,0)+h[h.length-1].error;const g=r.getStackIndex(this.stackGroup),f=r.getCurrentMinValue(g,n);isNaN(f)||(u+=f),r.setCurrentMinValue(g,n,u);const d=r.getCurrentMaxValue(g,n);!this.overlapsStack&&!isNaN(d)&&(c+=d),r.setCurrentMaxValue(g,n,c),t=Math.min(t,u+this.baseValue),e=Math.max(e,c+this.baseValue)}}else{const i=this.validItems.map(n=>n.value-n.error).concat([0]),r=this.validItems.map(n=>n.value+n.error).concat([0]);t=mt(i),e=Mt(r),this.baseValue<t&&(t=this.baseValue),this.baseValue>e&&(e=this.baseValue)}this.minX=t,this.maxX=e}async renderItem(t,e,i,r,n,a){await super.renderItem(t,e,i,r,n,a);const h=e-n.error,m=e+n.error,u=.5-this.errorWidth/2,c=.5+this.errorWidth/2,g=i+u*r,f=i+.5*r,d=i+c*r,b=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness),x=U.transform,R=x(this,h,f),M=x(this,m,f);if(await t.drawLine([R,M],this.strokeColor,this.errorStrokeThickness,b,void 0,X.Miter),this.errorWidth>0){const S=x(this,h,g),T=x(this,h,d);await t.drawLine([S,T],this.strokeColor,this.errorStrokeThickness,b,void 0,X.Miter);const A=x(this,m,g),P=x(this,m,d);await t.drawLine([A,P],this.strokeColor,this.errorStrokeThickness,b,void 0,X.Miter)}}getElementDefaultValues(){return qo}};l(Qo,"DefaultTrackerStringFormatter",function(o){return`${o.title||""}
${o.category}: ${o.value}, Error: ${Et(o.item.error,3)}`});p.Automatic,p.Black,p.Undefined,p.Undefined;({...Vs});const tn={categoryIndex:-1,baseValue:NaN,maximum:NaN,maximumColor:p.Automatic,minimum:NaN,minimumColor:p.Automatic};function en(o){return Object.assign({},tn,ae(o))}function sn(o){return o?"categoryIndex"in o&&"baseValue"in o&&"maximum"in o&&"minimum"in o:!1}const Ai={maximumFillColor:F.fromRgb(216,82,85),minimumFillColor:F.fromRgb(84,138,209),strokeColor:p.Black,strokeThickness:1,labelMargin:4,baseField:void 0,baseValue:void 0,maximumColorField:void 0,maximumField:void 0,maximumLabelStringFormatter:void 0,minimumColorField:void 0,minimumField:void 0,minimumLabelStringFormatter:void 0,actualMaximumBarRectangles:void 0,actualMinimumBarRectangles:void 0},rn={..._s,...Ai},ts=class Ti extends Qt{constructor(t){super(t),l(this,"_defaultMaximumFillColor",p.Undefined),l(this,"_defaultMinimumFillColor",p.Undefined),l(this,"baseField"),l(this,"baseValue",NaN),l(this,"maximumColorField"),l(this,"maximumField"),l(this,"maximumFillColor",Ai.maximumFillColor),l(this,"maximumLabelStringFormatter"),l(this,"minimumColorField"),l(this,"minimumField"),l(this,"minimumFillColor",Ai.minimumFillColor),l(this,"minimumLabelStringFormatter"),l(this,"actualMaximumBarRectangles",[]),l(this,"actualMinimumBarRectangles",[]),this.trackerStringFormatter=Ti.defaultTrackerStringFormatter,it(this,"trackerStringFormatter",t),this.minimumLabelStringFormatter=Ti.defaultMinimumLabelStringFormatter,it(this,"minimumLabelStringFormatter",t),this.maximumLabelStringFormatter=Ti.defaultMaximumLabelStringFormatter,it(this,"maximumLabelStringFormatter",t),q(this,Ai,t,{exclude:["trackerStringFormatter","minimumLabelStringFormatter","maximumLabelStringFormatter"]})}getElementName(){return"TornadoBarSeries"}get actualMaximumFillColor(){return F.getActualColor(this.maximumFillColor,this._defaultMaximumFillColor)}get actualMinimumFillColor(){return F.getActualColor(this.minimumFillColor,this._defaultMinimumFillColor)}getNearestPoint(t,e){for(let i=0;i<this.actualMinimumBarRectangles.length;i++){const r=w.containsPoint(this.actualMinimumBarRectangles[i],t),n=w.containsPoint(this.actualMaximumBarRectangles[i],t);if(r||n){const a=this.getItem(this.validItemsIndexInversion.get(i)),h=qt(a,i),m=n?this.validItems[i].maximum:this.validItems[i].minimum,u=$(h,m),c=this.getCategoryAxis(),g=this.trackerStringFormatter({item:a,title:this.title,yTitle:c.title??Qt.DefaultCategoryAxisTitle,yValue:c.formatValue(h),xTitle:this.xAxis.title??Qt.DefaultValueAxisTitle,xValue:this.xAxis.getValue(m)});return new yt({series:this,dataPoint:u,position:t,item:a,index:i,text:g})}}}async render(t){if(this.actualMinimumBarRectangles=[],this.actualMaximumBarRectangles=[],this.validItems.length===0)return;const e=this.getActualBarWidth();for(let i=0;i<this.validItems.length;i++){const r=this.validItems[i],n=qt(r,i),a=j(r.baseValue)?this.baseValue:r.baseValue,h=this.manager.getCurrentBarOffset(n),m=n-.5+h,u=m+e,c=U.transform,g=c(this,r.minimum,m),f=c(this,r.maximum,m),d=c(this,a,m+e),b=w.fromScreenPoints(g,d),x=w.fromScreenPoints(f,d);this.actualMinimumBarRectangles.push(b),this.actualMaximumBarRectangles.push(x);const R=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness);await t.drawRectangle(b,F.getActualColor(r.minimumColor,this.actualMinimumFillColor),this.strokeColor,this.strokeThickness,R),await t.drawRectangle(x,F.getActualColor(r.maximumColor,this.actualMaximumFillColor),this.strokeColor,this.strokeThickness,R),this.minimumLabelStringFormatter&&await this.renderLabel(t,r,a,r.minimum,m,u,this.minimumLabelStringFormatter,r.minimum),this.maximumLabelStringFormatter&&await this.renderLabel(t,r,a,r.maximum,m,u,this.maximumLabelStringFormatter,r.maximum)}}async renderLegend(t,e){const i=w.right(e),r=w.bottom(e),n=(e.left+i)/2,a=(e.top+r)/2,h=(r-e.top)*.8,m=h,u=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness);await t.drawRectangle(Y(n-.5*m,a-.5*h,.5*m,h),this.actualMinimumFillColor,this.strokeColor,this.strokeThickness,u),await t.drawRectangle(Y(n,a-.5*h,.5*m,h),this.actualMaximumFillColor,this.strokeColor,this.strokeThickness,u)}setDefaultValues(){F.isAutomatic(this.maximumFillColor)&&(this._defaultMaximumFillColor=this.plotModel.getDefaultColor()),F.isAutomatic(this.minimumFillColor)&&(this._defaultMinimumFillColor=this.plotModel.getDefaultColor())}updateMaxMin(){if(super.updateMaxMin(),this.validItems.length===0)return;let t=B,e=W;for(const i of this.validItems)t=Math.min(t,i.minimum),e=Math.max(e,i.maximum);this.minX=t,this.maxX=e}isValid(t){return this.xAxis.isValidValue(t.minimum)&&this.xAxis.isValidValue(t.maximum)}updateFromDataFields(){if(!this.minimumField||!this.maximumField||!this.itemsSource)return!1;this.itemsSourceItems?this.itemsSourceItems.length=0:this.itemsSourceItems=[];for(const t of this.itemsSource){if(!t)continue;if(sn(t)){this.itemsSourceItems.push(t);continue}const e=lt(t,this.minimumField,Number.NaN),i=lt(t,this.maximumField,Number.NaN),r=lt(t,this.baseField,Number.NaN),n=lt(t,this.minimumColorField,p.Automatic),a=lt(t,this.maximumColorField,p.Automatic);this.itemsSourceItems.push(en({minimum:e,maximum:i,baseValue:r,minimumColor:n,maximumColor:a}))}return!0}getElementDefaultValues(){return rn}};l(ts,"defaultTrackerStringFormatter",function(o){return`${o.title||""}
${o.yTitle}: ${o.yValue}
${o.xTitle}: ${o.xValue}`}),l(ts,"defaultMinimumLabelStringFormatter",function(o,t){return t[0].toString()}),l(ts,"defaultMaximumLabelStringFormatter",function(o,t){return t[0].toString()});const Qe={fillColor:p.Automatic,strokeColor:p.Black,strokeThickness:1,labelStringFormatter:void 0,items:void 0},on={..._t,...Qe},Ks=class Rs extends nt{constructor(t){super(t),l(this,"_defaultFillColor",p.Undefined),l(this,"fillColor",Qe.fillColor),l(this,"_items",[]),l(this,"labelStringFormatter"),l(this,"strokeColor",Qe.strokeColor),l(this,"strokeThickness",Qe.strokeThickness),l(this,"actualBarRectangles",[]),l(this,"actualItems",[]),t!=null&&t.items&&(this._items=t.items,delete t.items),this.trackerStringFormatter=Rs.defaultTrackerStringFormatter,it(this,"trackerStringFormatter",t),this.labelStringFormatter=Rs.defaultLabelStringFormatter,it(this,"labelStringFormatter",t),q(this,Qe,t,{exclude:["trackerStringFormatter","labelStringFormatter"]})}getElementName(){return"RectangleBarSeries"}get actualFillColor(){return F.getActualColor(this.fillColor,this._defaultFillColor)}get items(){return this._items}getNearestPoint(t,e){if(!(!this.actualBarRectangles||!this.actualItems))for(let i=0;i<this.actualBarRectangles.length;i++){const r=this.actualBarRectangles[i];if(w.containsPoint(r,t)){const n=(this.actualItems[i].y0+this.actualItems[i].y1)/2,a=t,h=$(i,n),m=this.actualItems[i],u=this.formatDefaultTrackerString(m,$(this.actualItems[i].x0,this.actualItems[i].y0),c=>{c.x1Value=this.xAxis.getValue(this.actualItems[i].x1),c.y1Value=this.yAxis.getValue(this.actualItems[i].y1)});return new yt({series:this,dataPoint:h,position:a,item:m,index:i,text:u})}}}async render(t){if(this.items.length===0)return;let e=0,i=B;if(this.actualBarRectangles=[],this.actualItems=[],this.isXMonotonic){const a=this.xAxis.clipMinimum;i=this.xAxis.clipMaximum,this.windowStartIndex=this.updateWindowStartIndex(this.items,h=>h.x0,a,this.windowStartIndex),e=this.windowStartIndex}const r=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness);let n=0;for(let a=e;a<this.items.length;a++){const h=this.items[a];if(!this.isValid(h.x0)||!this.isValid(h.x1)||!this.isValid(h.y0)||!this.isValid(h.y1))continue;const m=U.transform,u=m(this,h.x0,h.y0),c=m(this,h.x1,h.y1),g=w.create(u.x,u.y,c.x,c.y);this.actualBarRectangles.push(g),this.actualItems.push(h);const f=h.color??p.Automatic;if(await t.drawRectangle(g,this.getSelectableFillColor(F.getActualColor(f,this.actualFillColor)),this.strokeColor,this.strokeThickness,r),this.labelStringFormatter){const d=this.labelStringFormatter(this.getItem(a),[h.x0,h.x1,h.y0,h.y1,h.title]),b=w.right(g),x=w.bottom(g),R=y((g.left+b)/2,(g.top+x)/2);await t.drawText(R,d,this.actualTextColor,this.actualFont,this.actualFontSize,this.actualFontWeight,0,N.Center,E.Middle)}if(n+=h.x0>i?1:0,n>1)break}}async renderLegend(t,e){const i=w.right(e),r=w.bottom(e),n=(e.left+i)/2,a=(e.top+r)/2,h=(r-e.top)*.8,m=h;await t.drawRectangle(Y(n-.5*m,a-.5*h,m,h),this.getSelectableFillColor(this.actualFillColor),this.strokeColor,this.strokeThickness,this.edgeRenderingMode)}setDefaultValues(){F.isAutomatic(this.fillColor)&&(this._defaultFillColor=this.plotModel.getDefaultColor())}updateData(){}updateMaxMin(){if(super.updateMaxMin(),this.isXMonotonic=!0,J(this.items)||this.items.length===0)return;let t=B,e=W,i=B,r=W,n=W,a=W;for(const h of this.items)(h.x0<n||h.x1<a)&&(this.isXMonotonic=!1),t=Math.min(t,Math.min(h.x0,h.x1)),e=Math.max(e,Math.max(h.x1,h.x0)),i=Math.min(i,Math.min(h.y0,h.y1)),r=Math.max(r,Math.max(h.y0,h.y1)),n=h.x0,a=h.x1;this.minX=t,this.maxX=e,this.minY=i,this.maxY=r}isValid(t){return!j(t)&&isFinite(t)}getElementDefaultValues(){return on}toJSON(t){var e;const i=super.toJSON(t);return(e=this._items)!=null&&e.length&&(i.items=this._items),i}};l(Ks,"defaultTrackerStringFormatter",function(o){return`${o.title}
${o.xTitle}: ${o.xValue} ${o.x1Value}  
${o.yTitle}: ${o.yValue} ${o.y1Value}`}),l(Ks,"defaultLabelStringFormatter",function(o,t){return`${t[4]||""}`});const ge={color:p.Automatic,lineJoin:X.Miter,lineStyle:_.Solid,strokeThickness:1,tickLength:4,dataFieldClose:void 0,dataFieldHigh:void 0,dataFieldLow:void 0,dataFieldOpen:void 0,dataFieldX:void 0,items:void 0},Ir={..._t,...ge},nn=class Vr extends nt{constructor(t){super(t),l(this,"_items",[]),l(this,"_defaultColor",p.Undefined),l(this,"trackerStringFormatter"),l(this,"color",ge.color),l(this,"dashes"),l(this,"dataFieldClose"),l(this,"dataFieldHigh"),l(this,"dataFieldLow"),l(this,"dataFieldOpen"),l(this,"dataFieldX"),l(this,"lineJoin",ge.lineJoin),l(this,"lineStyle",ge.lineStyle),l(this,"mapping"),l(this,"strokeThickness",ge.strokeThickness),l(this,"tickLength",ge.tickLength),this.trackerStringFormatter=Vr.DefaultTrackerStringFormatter,t!=null&&t.items&&(this._items=t.items,delete t.items),q(this,ge,t)}getElementName(){return"HighLowSeries"}get actualColor(){return F.getActualColor(this.color,this._defaultColor)}get items(){return this._items}getNearestPoint(t,e){if(!this.xAxis||!this.yAxis||e)return;let i=B,r;const n=(a,h,m)=>{const u=this.transform(a),c=u.x-t.x,g=u.y-t.y,f=c*c+g*g;if(f<i){const d=this.formatHighLowItemTrackerString(h);r=new yt({series:this,dataPoint:a,position:u,item:h,index:m,text:d}),i=f}};for(let a=0;a<this.items.length;a++){const h=this.items[a];n($(h.x,h.high),h,a),n($(h.x,h.low),h,a),n($(h.x,h.open),h,a),n($(h.x,h.close),h,a)}if(i<B)return r}formatHighLowItemTrackerString(t){return this.trackerStringFormatter&&this.trackerStringFormatter({item:t,title:this.title||"",xTitle:this.xAxis.title??nt.defaultXAxisTitle,xValue:this.xAxis.getValue(t.x),high:this.yAxis.getValue(t.high),low:this.yAxis.getValue(t.low),open:this.yAxis.getValue(t.open),close:this.yAxis.getValue(t.close)})||""}isValidItem(t,e,i){return!isNaN(t.x)&&isFinite(t.x)&&!isNaN(t.high)&&isFinite(t.high)&&!isNaN(t.low)&&isFinite(t.low)}async render(t){if(this.items.length===0)return;this.verifyAxes();const e=Vt.getDashArray(this.lineStyle),i=this.getSelectableColor(this.actualColor),r=U.transform;for(const n of this.items)if(this.isValidItem(n,this.xAxis,this.yAxis)&&this.strokeThickness>0&&this.lineStyle!==_.None){const a=r(this,n.x,n.high),h=r(this,n.x,n.low);await t.drawLine([h,a],i,this.strokeThickness,this.edgeRenderingMode,e,this.lineJoin);const m=U.orientateVector(this,ot(this.tickLength,0));if(!isNaN(n.open)){const u=r(this,n.x,n.open),c=_e(u,m);await t.drawLine([u,c],i,this.strokeThickness,this.edgeRenderingMode,e,this.lineJoin)}if(!isNaN(n.close)){const u=r(this,n.x,n.close),c=It(u,m);await t.drawLine([u,c],i,this.strokeThickness,this.edgeRenderingMode,e,this.lineJoin)}}}async renderLegend(t,e){const i=w.right(e),r=w.bottom(e),n=(e.left+i)/2,a=e.top+(r-e.top)*.7,h=e.top+(r-e.top)*.3,m=Vt.getDashArray(this.lineStyle),u=this.getSelectableColor(this.actualColor);this.strokeThickness>0&&this.lineStyle!==_.None&&(await t.drawLine([y(n,e.top),y(n,r)],u,this.strokeThickness,this.edgeRenderingMode,m,X.Miter),await t.drawLine([y(n-this.tickLength,a),y(n,a)],u,this.strokeThickness,this.edgeRenderingMode,m,X.Miter),await t.drawLine([y(n+this.tickLength,h),y(n,h)],u,this.strokeThickness,this.edgeRenderingMode,m,X.Miter))}setDefaultValues(){F.isAutomatic(this.color)&&(this.lineStyle=this.plotModel.getDefaultLineStyle(),this._defaultColor=this.plotModel.getDefaultColor())}updateData(){if(this.itemsSource){if(this._items.length=0,this.mapping){for(const t of this.itemsSource)this._items.push(this.mapping(t));return}for(const t of this.itemsSource){if(!t)continue;if("high"in t&&"low"in t&&"x"in t){this._items.push(t);continue}if(!this.dataFieldX||!this.dataFieldHigh||!this.dataFieldLow)throw new Error("HighLowSeries: dataFieldX, dataFieldHigh and dataFieldLow are required");const e=lt(t,this.dataFieldX,NaN),i=lt(t,this.dataFieldHigh,NaN),r=lt(t,this.dataFieldLow,NaN),n=lt(t,this.dataFieldOpen,NaN),a=lt(t,this.dataFieldClose,NaN);this._items.push({x:e,high:i,low:r,open:n,close:a})}}}updateMaxMin(){super.updateMaxMin(),this.internalUpdateMaxMin2(this.items,t=>t.x,t=>t.x,t=>t.low,t=>t.high)}getElementDefaultValues(){return Ir}toJSON(t){var e;const i=super.toJSON(t);return(e=this._items)!=null&&e.length&&(i.items=this._items),i}};l(nn,"DefaultTrackerStringFormatter",function(o){return`${o.title}
${o.xTitle}: ${o.xValue}
High: ${Et(o.high,3)}
Low: ${Et(o.low,3)}
Open: ${Et(o.open,3)}
Close: ${Et(o.close,3)}`});class fi{static findIndex(t,e,i){let r=0,n=0,a=t.length-1;for(;n<=a;){if(i<n)return r;if(i>a)return a;const h=t[i].x;if(h===e)return i;if(h>e){if(a=i-1,a<n)return r;if(a===n)return a}else n=i+1,r=i;if(n>=a)return r;const m=t[a].x,u=t[n].x,c=(a-n+1)/(m-u);i=n+Math.round((e-u)*c)}return r}static isValid(t){return!isNaN(t.x)&&!isNaN(t.buyVolume)&&!isNaN(t.sellVolume)}}const Lt={positiveColor:p.DarkGreen,negativeColor:p.Red,barWidth:0,strokeThickness:1,negativeHollow:!1,positiveHollow:!0,strokeIntensity:.8,volumeStyle:1,interceptColor:p.Gray,interceptLineStyle:_.Dash,interceptStrokeThickness:1,items:void 0},an={..._t,...Lt},ln=class _r extends nt{constructor(t){super(t),l(this,"_items",[]),l(this,"_minDx",0),l(this,"_winIndex",0),l(this,"volumeStyle",Lt.volumeStyle),l(this,"strokeThickness",Lt.strokeThickness),l(this,"strokeIntensity",Lt.strokeIntensity),l(this,"positiveColor",Lt.positiveColor),l(this,"negativeColor",Lt.negativeColor),l(this,"interceptColor",Lt.interceptColor),l(this,"interceptStrokeThickness",Lt.interceptStrokeThickness),l(this,"interceptLineStyle",Lt.interceptLineStyle),l(this,"positiveHollow",Lt.positiveHollow),l(this,"negativeHollow",Lt.negativeHollow),l(this,"barWidth",Lt.barWidth),l(this,"minimumVolume",0),l(this,"maximumVolume",0),l(this,"averageVolume",0),t!=null&&t.items&&(this.items=t.items,delete t.items),this.trackerStringFormatter=_r.DefaultTrackerStringFormatter,it(this,"trackerStringFormatter",t),q(this,Lt,t,{exclude:["trackerStringFormatter"]})}getElementName(){return"VolumeSeries"}get items(){return this._items}set items(t){this._items=t}append(t){if(J(this._items)&&(this._items=[]),this._items.length>0&&this._items[this._items.length-1].x>t.x)throw new Error("cannot append bar out of order, must be sequential in X");this._items.push(t)}async render(t){if(J(this._items)||this._items.length===0)return;const e=this._items,i=this._items.length;this.verifyAxes();const r=this.getClippingRect();this.barWidth>0?this.barWidth:this._minDx*.8;const n=this.getSelectableFillColor(this.positiveColor),a=this.getSelectableFillColor(this.negativeColor),h=this.positiveHollow?p.Transparent:n,m=this.negativeHollow?p.Transparent:a,u=F.changeIntensity(this.positiveColor,this.strokeIntensity),c=F.changeIntensity(this.negativeColor,this.strokeIntensity),g=this.getSelectableColor(u),f=this.getSelectableColor(c),d=this.xAxis.clipMinimum,b=this.xAxis.clipMaximum;this._winIndex=fi.findIndex(e,d,this._winIndex);const x=U.transform;for(let R=this._winIndex;R<i;R++){const M=e[R];if(M.x>b)break;if(!fi.isValid(M))continue;const S=this.getBuyBarRect(M),T=this.getSellBarRect(M);switch(this.volumeStyle){case 1:{const A=M.buyVolume>M.sellVolume?h:m,P=M.buyVolume>M.sellVolume?g:f;await t.drawRectangle(S,A,P,this.strokeThickness,this.edgeRenderingMode)}break;case 3:await t.drawRectangle(S,n,g,this.strokeThickness,this.edgeRenderingMode),await t.drawRectangle(T,a,f,this.strokeThickness,this.edgeRenderingMode);break;case 2:{await t.drawRectangle(S,n,g,this.strokeThickness,this.edgeRenderingMode),await t.drawRectangle(T,a,f,this.strokeThickness,this.edgeRenderingMode);break}case 0:break;default:throw new Error("Invalid VolumeStyle")}}if(this.interceptStrokeThickness>0&&this.interceptLineStyle!==_.None){const R=this.inverseTransform(w.bottomLeft(r)),M=this.inverseTransform(w.topRight(r)),S=x(this,R.x,0),T=x(this,M.x,0);await t.drawLine([S,T],this.interceptColor,this.interceptStrokeThickness,this.edgeRenderingMode,Vt.getDashArray(this.interceptLineStyle),X.Miter)}}getBuyBarRect(t){const e=U.transform,i=(this.barWidth>0?this.barWidth:this._minDx*.8)*.5,r=e(this,t.x-i,0);switch(this.volumeStyle){case 1:{const n=e(this,t.x+i,Math.abs(t.buyVolume-t.sellVolume));return w.fromScreenPoints(r,n)}case 3:{const n=e(this,t.x+i,t.buyVolume);return w.fromScreenPoints(r,n)}case 2:{const n=e(this,t.x+i,t.buyVolume),a=e(this,t.x+i,t.sellVolume),h=e(this,t.x-i,t.buyVolume+t.sellVolume);return t.buyVolume>t.sellVolume?w.fromScreenPoints(a,h):w.fromScreenPoints(r,n)}}throw new Error("Invalid VolumeStyle")}getSellBarRect(t){const e=U.transform,i=(this.barWidth>0?this.barWidth:this._minDx*.8)*.5,r=e(this,t.x-i,0);switch(this.volumeStyle){case 1:{const n=e(this,t.x+i,Math.abs(t.buyVolume-t.sellVolume));return w.fromScreenPoints(r,n)}case 3:{const n=e(this,t.x+i,-t.sellVolume);return w.fromScreenPoints(r,n)}case 2:{const n=e(this,t.x+i,t.buyVolume),a=e(this,t.x+i,t.sellVolume),h=e(this,t.x-i,t.buyVolume+t.sellVolume);return t.buyVolume>t.sellVolume?w.fromScreenPoints(r,a):w.fromScreenPoints(n,h)}}throw new Error("Invalid VolumeStyle")}async renderLegend(t,e){const i=w.right(e),r=w.bottom(e),n=(e.left+i)/2,a=e.top+(r-e.top)*.7,h=e.top+(r-e.top)*.3,m=Vt.getDashArray(_.Solid),u=this.getSelectableFillColor(this.positiveColor),c=this.getSelectableColor(F.changeIntensity(this.positiveColor,this.strokeIntensity)),g=e.width*.75;this.strokeThickness>0&&(await t.drawLine([y(n,e.top),y(n,r)],c,this.strokeThickness,this.edgeRenderingMode,m,X.Miter),await t.drawRectangle(Y(n-g*.5,h,g,a-h),u,c,this.strokeThickness,this.edgeRenderingMode))}getNearestPoint(t,e){if(!this.xAxis||!this.yAxis||e||!this._items||this._items.length===0)return;const i=this._items.length,r=this.inverseTransform(t),n=r.x;if(n>this._items[i-1].x+this._minDx||n<this._items[0].x-this._minDx)return;const a=fi.findIndex(this._items,n,this._winIndex),h=a+1<this._items.length?a+1:a,m=b=>{const x=b.x-r.x;return x*x},u=m(this._items[a])<=m(this._items[h])?a:h,c=this._items[u];let g=!1;const f=this.getBuyBarRect(c);if(w.containsPoint(f,t)&&(g=!0),!g){const b=this.getSellBarRect(c);w.containsPoint(b,t)&&(g=!0)}if(g)return;const d=this.formatDefaultTrackerString(c,$(c.x,0));return new yt({series:this,dataPoint:r,position:t,item:c,index:u,text:d})}updateData(){if(super.updateData(),this._winIndex=0,!this._items||this._items.length===0)return;const t=this._items,e=t.length;this._minDx=B;for(let i=1;i<e;i++)if(this._minDx=Math.min(this._minDx,t[i].x-t[i-1].x),this._minDx<0)throw new Error("bars are out of order, must be sequential in x");e<=1&&(this._minDx=1)}updateAxisMaxMin(){this.xAxis.include(this.minX),this.xAxis.include(this.maxX);let t=this.minimumVolume,e=this.maximumVolume;const i=this.averageVolume,r=(e-t)/4;switch(this.volumeStyle){case 3:t=-(i+r/2),e=+(i+r/2);break;case 2:e=i+r,t=0;break;default:e=i+r/2,t=0;break}t=Math.max(this.yAxis.filterMinValue,t),e=Math.min(this.yAxis.filterMaxValue,e),this.yAxis.include(t),this.yAxis.include(e)}updateMaxMin(){super.updateMaxMin();let t=B,e=W,i=0,r=W,n=0,a=0;for(const h of this.items)fi.isValid(h)&&(h.sellVolume>0&&n++,h.buyVolume>0&&n++,a+=h.buyVolume,a+=h.sellVolume,t=Math.min(t,h.x),e=Math.max(e,h.x),i=Math.min(i,-h.sellVolume),r=Math.max(r,+h.buyVolume));this.minX=Math.max(this.xAxis.filterMinValue,t),this.maxX=Math.min(this.xAxis.filterMaxValue,e),this.minimumVolume=i,this.maximumVolume=r,this.averageVolume=a/n}getJsonIgnoreProperties(){return[...super.getJsonIgnoreProperties(),"minimumVolume","maximumVolume","averageVolume"]}getElementDefaultValues(){return an}toJSON(t){var e;const i=super.toJSON(t);return(e=this._items)!=null&&e.length&&(i.items=this._items),i}};l(ln,"DefaultTrackerStringFormatter",function(o){const t=o.item;return`Time: ${o.xValue}
Buy Volume: ${t.buyVolume}
Sell Volume: ${t.sellVolume}`});p.DarkGreen,p.Red;({...Ir});({...ue});class $t{constructor(t){l(this,"_item"),this._item=t}static from(t){return new $t(t)}get rangeStart(){return this._item.rangeStart}get rangeEnd(){return this._item.rangeEnd}get area(){return this._item.area}get count(){return this._item.count}get color(){return this._item.color}get center(){return this._item.rangeStart+(this._item.rangeEnd-this._item.rangeStart)/2}get width(){return this._item.rangeEnd-this._item.rangeStart}get height(){return this._item.area/this.width}get value(){return this.height}contains(t){const e=this.height,{rangeStart:i,rangeEnd:r}=this._item;return e<0?t.x<=r&&t.x>=i&&t.y>=e&&t.y<=0||t.x<=i&&t.x>=r&&t.y>=e&&t.y<=0:t.x<=r&&t.x>=i&&t.y<=e&&t.y>=0||t.x<=i&&t.x>=r&&t.y<=e&&t.y>=0}}function hn(o){return o?"rangeStart"in o&&"rangeEnd"in o&&"area"in o&&"count"in o:!1}const zt={baseValue:0,baseLine:NaN,fillColor:p.Automatic,strokeColor:p.Black,negativeFillColor:p.Undefined,negativeStrokeColor:p.Undefined,strokeThickness:0,labelMargin:0,labelPlacement:Bt.Outside,labelStringFormatter:void 0,colorMapping:void 0,mapping:void 0,items:void 0},mn={..._t,...zt},un=class Lr extends nt{constructor(t){super(t),l(this,"_defaultFillColor",p.Undefined),l(this,"_actualItems"),l(this,"baseValue",zt.baseValue),l(this,"baseLine",zt.baseLine),l(this,"_actualBaseLine",NaN),l(this,"fillColor",zt.fillColor),l(this,"strokeColor",zt.strokeColor),l(this,"negativeFillColor",zt.negativeFillColor),l(this,"negativeStrokeColor",zt.negativeStrokeColor),l(this,"strokeThickness",zt.strokeThickness),l(this,"_minValue",0),l(this,"_maxValue",0),l(this,"labelStringFormatter"),l(this,"trackerStringFormatter"),l(this,"labelMargin",zt.labelMargin),l(this,"labelPlacement",zt.labelPlacement),l(this,"colorMapping"),l(this,"mapping"),l(this,"items",[]),this.colorMapping=this.getDefaultColor,this.trackerStringFormatter=Lr.defaultTrackerStringFormatter,it(this,"trackerStringFormatter",t),q(this,zt,t,{exclude:["trackerStringFormatter"]})}getElementName(){return"HistogramSeries"}get actualBaseLine(){return this._actualBaseLine}get actualFillColor(){return F.getActualColor(this.fillColor,this._defaultFillColor)}get minValue(){return this._minValue}get maxValue(){return this._maxValue}get actualItems(){return this.itemsSource?this._actualItems:this.items}async render(t){this.verifyAxes(),await this.renderBins(t,this.actualItems)}getNearestPoint(t,e){const i=this.inverseTransform(t);if(this.isPointInRange(i)&&this.actualItems)for(let r=0;r<this.actualItems.length;r++){const n=$t.from(this.actualItems[r]);if(n.contains(i)){const a=this.getItem(r);return new yt({series:this,dataPoint:i,position:t,item:a,index:r,text:this.formatDefaultTrackerString(n,i)})}}}async renderLegend(t,e){const i=w.right(e),r=w.bottom(e),n=(e.left+i)/2,a=(e.top+r)/2,h=(r-e.top)*.8,m=h,u=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness);await t.drawRectangle(Y(n-.5*m,a-.5*h,m,h),this.getSelectableColor(this.actualFillColor),this.strokeColor,this.strokeThickness,u)}updateData(){this.itemsSource&&this.updateActualItems()}setDefaultValues(){F.isAutomatic(this.fillColor)&&(this._defaultFillColor=this.plotModel.getDefaultColor())}updateAxisMaxMin(){super.updateAxisMaxMin(),this.computeActualBaseLine(),this.yAxis.include(this.actualBaseLine)}computeActualBaseLine(){if(j(this.baseLine))if(this.yAxis.isLogarithmic()){const t=this.actualItems?mt(this.actualItems.map(e=>$t.from(e).value).filter(e=>e>0),1):1;this._actualBaseLine=Math.max(t/10,this.baseValue)}else this._actualBaseLine=0;else this._actualBaseLine=this.baseLine}updateMaxMinXY(){if(this.actualItems&&this.actualItems.length>0){const t=this.actualItems.map(n=>$t.from(n)),e=t.map(n=>n.rangeStart),i=t.map(n=>n.rangeEnd),r=t.map(n=>n.height);this.minX=Math.min(mt(e),mt(i)),this.maxX=Math.max(Mt(e),Mt(i)),this.yAxis.isLogarithmic()?(this.minY=Math.max(mt(r),Number.EPSILON),this.maxY=Mt(r,Number.EPSILON)):(this.minY=mt(r,0),this.maxY=Mt(r,0))}}updateMaxMin(){if(super.updateMaxMin(),!this.actualItems)return;const t=this.actualItems.map(i=>$t.from(i)),e=[];if(Xe(e,t.map(i=>$(i.rangeStart,0))),Xe(e,t.map(i=>$(i.rangeEnd,i.height))),this.internalUpdateMaxMin(e),this.updateMaxMinXY(),t.length>0){const i=t.map(r=>r.value);this._minValue=mt(i),this._maxValue=Mt(i)}}getItem(t){const e=this.actualItems;return!this.itemsSource&&e&&t<e.length?e[t]:super.getItem(t)}async renderBins(t,e){const i=this.yAxis,r=i.isLogarithmic()&&!i.isValidValue(this.baseValue);for(const n of e){const a=$t.from(n);if(i.isLogarithmic()&&!i.isValidValue(a.height))continue;const h=this.getItemFillColor(a),m=this.getItemStrokeColor(a),u=this.transform($(a.rangeStart,r?i.clipMinimum:this.baseValue)),c=this.transform($(a.rangeEnd,a.height)),g=w.fromScreenPoints(u,c),f=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness);await t.drawRectangle(g,h,m,this.strokeThickness,f),this.labelStringFormatter&&await this.renderLabel(t,g,a)}}getItemFillColor(t){const e=$t.from(t);return t.color||(t.color=p.Automatic),F.isAutomatic(t.color)?this.colorMapping(e):t.color}getItemStrokeColor(t){return F.isUndefined(this.negativeStrokeColor)||$t.from(t).height>=this.baseValue?this.strokeColor:this.negativeStrokeColor}async renderLabel(t,e,i){const r=$t.from(i).value,n=this.labelStringFormatter(i,[r,i.rangeStart,i.rangeEnd,i.area,i.count]);let a,h,m=N.Center;const u=(i.rangeStart+i.rangeEnd)/2,c=Math.sign(r);let g=c*this.labelMargin;switch(this.labelPlacement){case Bt.Inside:a=$(u,r),h=-c;break;case Bt.Middle:{const x=this.inverseTransform(w.topLeft(e)),R=this.inverseTransform(w.bottomRight(e));a=$(u,(x.y+R.y)/2),h=E.Middle;break}case Bt.Base:a=$(u,0),g=-g,h=c;break;case Bt.Outside:a=$(u,r),g=-g,h=c;break;default:throw new Error("Invalid label placement")}const f=U.orientateAlignment(this,m,h);m=f[0],h=f[1];const d=U.orientateVector(this,ot(0,g)),b=It(this.transform(a),d);await t.drawText(b,n,this.actualTextColor,this.actualFont,this.actualFontSize,this.actualFontWeight,0,m,h)}isPointInRange(t){return this.updateMaxMinXY(),t.x>=this.minX&&t.x<=this.maxX&&t.y>=this.minY&&t.y<=this.maxY}clearActualItems(){this._actualItems&&(this._actualItems.length=0)}getDefaultColor(t){return F.isUndefined(this.negativeFillColor)||$t.from(t).value>=this.baseValue?this.actualFillColor:this.negativeFillColor}updateActualItems(){if(this.mapping){if(!this.itemsSource)throw new Error("itemsSource is required when using the Mapping property");this.clearActualItems(),this._actualItems=this._actualItems||[];for(const t of this.itemsSource)this._actualItems.push(this.mapping(t));return}this.clearActualItems(),this._actualItems=this._actualItems||[];for(const t of this.itemsSource||[])if(t)throw hn(t)&&this._actualItems.push(t),new Error("invalid item type")}getElementDefaultValues(){return mn}};l(un,"defaultTrackerStringFormatter",function(o){return`Start: ${o.item.rangeStart}
End: ${o.item.rangeEnd}
Value: ${o.item.value}
Area: ${o.item.area}
Count: ${o.item.count}`});function cn(o){return o&&typeof o.getScatterPoint=="function"}const Gt={markerFill:p.Automatic,markerSize:5,markerStroke:p.Automatic,markerStrokeThickness:1,markerType:ct.Square,labelMargin:6,binSize:0,dataFieldValue:void 0,dataFieldSize:void 0,dataFieldTag:void 0,dataFieldX:void 0,dataFieldY:void 0,mapping:void 0,markerOutline:void 0,labelStringFormatter:void 0,colorAxisKey:void 0,points:void 0},gn={..._t,...Gt},fn=class Nr extends nt{constructor(t){super(t),l(this,"_points",[]),l(this,"_defaultMarkerFillColor",p.Undefined),l(this,"markerFill",Gt.markerFill),l(this,"markerOutline"),l(this,"markerSize",Gt.markerSize),l(this,"markerType",Gt.markerType),l(this,"markerStroke",Gt.markerStroke),l(this,"markerStrokeThickness",Gt.markerStrokeThickness),l(this,"labelStringFormatter"),l(this,"labelMargin",Gt.labelMargin),l(this,"binSize",Gt.binSize),l(this,"colorAxisKey"),l(this,"dataFieldX"),l(this,"dataFieldY"),l(this,"dataFieldSize"),l(this,"dataFieldTag"),l(this,"dataFieldValue"),l(this,"mapping"),l(this,"_colorAxis"),l(this,"itemsSourcePoints"),l(this,"_minValue",0),l(this,"_maxValue",0),t!=null&&t.points&&(this._points=t.points,delete t.points),q(this,Gt,t)}get colorAxis(){return this._colorAxis}get actualMarkerFillColor(){return F.getActualColor(this.markerFill,this._defaultMarkerFillColor)}get points(){return this._points}get actualPoints(){return this.itemsSource?this.itemsSourcePoints:this.points}get minValue(){return this._minValue}get maxValue(){return this._maxValue}getElementName(){return"ScatterSeries"}getNearestPoint(t,e){if(!this.xAxis||!this.yAxis||e)return;const i=this.actualPoints;if(!i||i.length===0)return;let r,n=B,a=0;const h=this.colorAxis?this.colorAxis.title:Nr._defaultColorAxisTitle,m=this.xAxis.clipMinimum,u=this.xAxis.clipMaximum,c=this.yAxis.clipMinimum,g=this.yAxis.clipMaximum;for(const f of i){if(f.x<m||f.x>u||f.y<c||f.y>g){a++;continue}const d=this.transform($(f.x,f.y)),b=d.x-t.x,x=d.y-t.y,R=b*b+x*x;if(R<n){const M=this.getItem(a)??f;let S;!J(f.value)&&!isNaN(f.value)&&!xe(f.value)&&(S=f.value);const T=$(f.x,f.y);r=new yt({series:this,dataPoint:T,position:d,item:M,index:a,text:this.formatDefaultTrackerString(M,T,A=>{A.colorAxisTitle=h,A.zValue=S})}),n=R}a++}return r}async render(t){const e=this.actualPoints;if(!e||e.length===0)return;const i=this.getClippingRect(),r=e.length,n=[],a=[],h=[],m=[],u=new Map,c=new Map,g=this.isSelected();for(let d=0;d<r;d++){const b=$(e[d].x,e[d].y);if(!this.isValidPoint(b))continue;let x=NaN,R=NaN;const M=e[d];M&&(J(M.size)||(x=M.size),J(M.value)||(R=M.value)),isNaN(x)&&(x=this.markerSize);const S=this.transform($(b.x,b.y));if(g&&this.isItemSelected(d)){h.push(S),m.push(x);continue}if(this.colorAxis){if(isNaN(R))continue;const T=this.colorAxis.getPaletteIndex(R);u.has(T)||(u.set(T,[]),c.set(T,[])),u.get(T).push(S),c.get(T).push(x)}else n.push(S),a.push(x)}const f=this.transform($(this.minX,this.maxY));if(this.colorAxis){const d=this.markerType===ct.Plus||this.markerType===ct.Star||this.markerType===ct.Cross;for(const[b,x]of u){const R=this.colorAxis.getColor(b);await O.drawMarkers(t,x,this.markerType,this.markerOutline,c.get(b),F.getActualColor(this.markerFill,R),d?R:this.markerStroke,this.markerStrokeThickness,this.edgeRenderingMode,this.binSize,f)}}await O.drawMarkers(t,n,this.markerType,this.markerOutline,a,this.actualMarkerFillColor,this.markerStroke,this.markerStrokeThickness,this.edgeRenderingMode,this.binSize,f),await O.drawMarkers(t,h,this.markerType,this.markerOutline,m,this.plotModel.selectionColor,this.plotModel.selectionColor,this.markerStrokeThickness,this.edgeRenderingMode,this.binSize,f),this.labelStringFormatter&&await this.renderPointLabels(t,i)}async renderLegend(t,e){const i=w.right(e),r=w.bottom(e),n=(e.left+i)/2,a=(e.top+r)/2,h=y(n,a);await O.drawMarker(t,h,this.markerType,this.markerOutline,this.markerSize,this.isSelected()?this.plotModel.selectionColor:this.actualMarkerFillColor,this.isSelected()?this.plotModel.selectionColor:this.markerStroke,this.markerStrokeThickness,this.edgeRenderingMode)}ensureAxes(){super.ensureAxes(),this._colorAxis=this.colorAxisKey?this.plotModel.getAxis(this.colorAxisKey):this.plotModel.defaultColorAxis}setDefaultValues(){F.isAutomatic(this.markerFill)&&(this._defaultMarkerFillColor=this.plotModel.getDefaultColor())}updateData(){this.itemsSource&&this.updateItemsSourcePoints()}updateMaxMin(){super.updateMaxMin(),this.internalUpdateMaxMinValue(this.actualPoints)}async renderPointLabels(t,e){const i=this.actualPoints;if(!i||i.length===0)return;let r=-1;for(const n of i){r++;const a=$(n.x,n.y);if(!this.isValidPoint(a))continue;const h=It(this.transform(a),ot(0,-this.labelMargin));if(!w.containsPoint(e,h))continue;const m=this.getItem(r),u=this.labelStringFormatter(m,[n.x,n.y]);await t.drawText(h,u,this.actualTextColor,this.actualFont,this.actualFontSize,this.actualFontWeight,0,N.Center,E.Bottom)}}internalUpdateMaxMinValue(t){if(!t||t.length===0)return;let e=B,i=B,r=B,n=W,a=W,h=W;isNaN(e)&&(e=B),isNaN(i)&&(i=B),isNaN(n)&&(n=W),isNaN(a)&&(a=W),isNaN(r)&&(r=W),isNaN(h)&&(h=W);for(const m of t){const u=m.x,c=m.y;if(u!==u||c!==c)continue;const g=J(m.value)?Number.NaN:m.value;u<e&&(e=u),u>n&&(n=u),c<i&&(i=c),c>a&&(a=c),g<r&&(r=g),g>h&&(h=g)}e<B&&(this.minX=e),i<B&&(this.minY=i),n>W&&(this.maxX=n),a>W&&(this.maxY=a),r<B&&(this._minValue=r),h>W&&(this._maxValue=h),this.colorAxis instanceof dr&&(this.colorAxis.include(this.minValue),this.colorAxis.include(this.maxValue))}clearItemsSourcePoints(){this.itemsSourcePoints&&(this.itemsSourcePoints.length=0)}updateItemsSourcePoints(){var t,e,i;if(this.clearItemsSourcePoints(),this.mapping){if(!this.itemsSource)throw new Error("itemsSource is required when mapping is set");this.itemsSourcePoints=this.itemsSourcePoints||[];for(const r of this.itemsSource)this.itemsSourcePoints.push(this.mapping(r));return}this.itemsSourcePoints=this.itemsSourcePoints||[];for(const r of this.itemsSource||[])if(!J(r)){if(!ne(r.x)&&!ne(r.y)){(t=this.itemsSourcePoints)==null||t.push(r);continue}if(this.dataFieldX&&this.dataFieldY){const n=this.updateFromDataFields(r);if(!n)continue;(e=this.itemsSourcePoints)==null||e.push(n);continue}if(cn(r)){const n=r.getScatterPoint();if(!n)continue;(i=this.itemsSourcePoints)==null||i.push(n);continue}throw new Error("Invalid item type")}}updateFromDataFields(t){const e=lt(t,this.dataFieldX,Number.NaN),i=lt(t,this.dataFieldY,Number.NaN);return{x:e,y:i,size:lt(t,this.dataFieldSize,Number.NaN),value:lt(t,this.dataFieldValue,Number.NaN),tag:lt(t,this.dataFieldTag,void 0)}}getElementDefaultValues(){return gn}toJSON(t){var e;const i=super.toJSON(t);return(e=this.points)!=null&&e.length&&(i.points=this.points),i}};l(fn,"_defaultColorAxisTitle","Value");const Pt={color:p.Automatic,arrowHeadLength:10,arrowHeadWidth:3,arrowHeadPosition:1,lineJoin:X.Miter,lineStyle:_.Solid,strokeThickness:2,minimumSegmentLength:2,arrowVeeness:0,arrowStartPosition:0,arrowLabelPosition:0,labelFontSize:0,labelStringFormatter:void 0,mapping:void 0,items:void 0},dn={..._t,...Pt},Zs=class ys extends nt{constructor(t){super(t),l(this,"_actualItems"),l(this,"_defaultColor",p.Undefined),l(this,"_defaultLineStyle",_.Solid),l(this,"color",Pt.color),l(this,"_minValue",0),l(this,"_maxValue",0),l(this,"arrowHeadLength",Pt.arrowHeadLength),l(this,"arrowHeadWidth",Pt.arrowHeadWidth),l(this,"arrowHeadPosition",Pt.arrowHeadPosition),l(this,"lineJoin",Pt.lineJoin),l(this,"lineStyle",Pt.lineStyle),l(this,"strokeThickness",Pt.strokeThickness),l(this,"minimumSegmentLength",Pt.minimumSegmentLength),l(this,"arrowVeeness",Pt.arrowVeeness),l(this,"arrowStartPosition",Pt.arrowStartPosition),l(this,"arrowLabelPosition",Pt.arrowLabelPosition),l(this,"_colorAxis"),l(this,"colorAxisKey"),l(this,"labelStringFormatter"),l(this,"trackerStringFormatter"),l(this,"labelFontSize",Pt.labelFontSize),l(this,"canTrackerInterpolatePoints",!1),l(this,"mapping"),l(this,"items",[]),this.trackerStringFormatter=ys.DefaultTrackerStringFormatter,it(this,"trackerStringFormatter",t),this.labelStringFormatter=function(e){return e.value.toFixed(2)},it(this,"labelStringFormatter",t),q(this,Pt,t,{exclude:["trackerStringFormatter","labelStringFormatter"]})}getElementName(){return"VectorSeries"}get minValue(){return this._minValue}get maxValue(){return this._maxValue}get actualLineStyle(){return this.lineStyle!=_.Automatic?this.lineStyle:this._defaultLineStyle}get colorAxis(){return this._colorAxis}set colorAxis(t){this._colorAxis=t}get ActualItems(){return this.itemsSource?this._actualItems:this.items}async render(t){const e=this.ActualItems;this.verifyAxes(),await this.renderVectors(t,e)}updateData(){this.itemsSource&&this.updateActualItems()}clearActualItems(){this._actualItems&&(this._actualItems.length=0)}updateActualItems(){if(!this.itemsSource)return;this.clearActualItems(),this._actualItems=this._actualItems||[];let t=this.itemsSource;this.mapping&&(t=this.itemsSource.map(e=>this.mapping(e))),this._actualItems.push(...t)}async renderVectors(t,e){let i=0;for(const r of e){let n;this.colorAxis&&(F.isUndefined(this.color)||F.isAutomatic(this.color))?n=ze.getColor(this.colorAxis,r.value):n=F.getActualColor(this.color,this._defaultColor),n=this.getSelectableColor(n,i);const a=r.direction,h=Ns(r.origin,a.times(this.arrowStartPosition)),m=di(h,a.times(this.arrowLabelPosition));await this.drawVector(t,h,a,n),this.labelFontSize>0&&this.labelStringFormatter&&await t.drawText(this.transform(m),this.labelStringFormatter(r),this.actualTextColor,this.actualFont,this.labelFontSize,this.actualFontWeight,0,N.Center,E.Middle),i++}}async drawVector(t,e,i,r){const n=[e,di(e,i)],a=[];O.transformAndInterpolateLines(this,n,a,this.minimumSegmentLength),a.length>=2&&await this.drawArrow(t,a,rr(a[a.length-1],a[a.length-2]),r)}async drawArrow(t,e,i,r){const n=wt.fromVector(i).normalize(),a=os(n.y,-n.x),h=this.arrowHeadLength*this.strokeThickness,m=this.arrowHeadWidth*this.strokeThickness,u=_e(e[e.length-1],n.times(h*this.arrowHeadPosition)),c=n.times(this.arrowVeeness*this.strokeThickness),g=It(u,n.times(h)),f=_e(It(u,a.times(m)),c),d=_e(_e(u,a.times(m)),c),b=this.actualLineStyle,x=Vt.getDashArray(b);if(this.arrowHeadPosition>0&&this.arrowHeadPosition<=1){const R=h*this.arrowHeadPosition*h*this.arrowHeadPosition;for(let M=e.length-1;M>=0;M--)Ye(e[M],g)<=R&&e.splice(M,1);e.length>0&&e.push(u)}this.strokeThickness>0&&b!==_.None&&(await t.drawLine(e,r,this.strokeThickness,this.edgeRenderingMode,x,this.lineJoin),await t.drawPolygon([d,g,f,u],r,p.Undefined,0,this.edgeRenderingMode))}getNearestPoint(t,e){const i=this.colorAxis,r=(i==null?void 0:i.title)??ys.DefaultColorAxisTitle;if(!(this.ActualItems&&this.ActualItems.length>0))return;const n=bn(this.ActualItems,m=>Ye(this.transform(m.origin),t)),a=n.origin,h=this.formatDefaultTrackerString(n,a,m=>{const u=m;u.colorAxisTitle=r,u.itemDirection=n.direction});return new yt({series:this,dataPoint:a,position:this.transform(a),item:void 0,index:-1,text:h})}ensureAxes(){super.ensureAxes(),this.colorAxis=this.colorAxisKey?this.plotModel.getAxis(this.colorAxisKey):this.plotModel.defaultColorAxis}setDefaultValues(){F.isAutomatic(this.color)&&this.colorAxis===void 0&&(this._defaultLineStyle=this.plotModel.getDefaultLineStyle(),this._defaultColor=this.plotModel.getDefaultColor())}updateMaxMinXY(){const t=this.ActualItems;t&&t.length>0&&(this.minX=Math.min(...t.map(e=>e.origin.x-e.direction.x*this.arrowStartPosition),...t.map(e=>e.origin.x-e.direction.x*(this.arrowStartPosition-1))),this.maxX=Math.max(...t.map(e=>e.origin.x-e.direction.x*this.arrowStartPosition),...t.map(e=>e.origin.x-e.direction.x*(this.arrowStartPosition-1))),this.minY=Math.min(...t.map(e=>e.origin.y-e.direction.y*this.arrowStartPosition),...t.map(e=>e.origin.y-e.direction.y*(this.arrowStartPosition-1))),this.maxY=Math.max(...t.map(e=>e.origin.y-e.direction.y*this.arrowStartPosition),...t.map(e=>e.origin.y-e.direction.y*(this.arrowStartPosition-1))))}updateMaxMin(){super.updateMaxMin();const t=this.ActualItems,e=[];if(e.push(...t.map(i=>Ns(i.origin,i.direction.times(this.arrowStartPosition)))),e.push(...t.map(i=>di(i.origin,i.direction.times(1-this.arrowStartPosition)))),this.internalUpdateMaxMin(e),this.updateMaxMinXY(),t&&t.length>0){const i=t.map(r=>r.value);this._minValue=mt(i),this._maxValue=Mt(i)}}updateAxisMaxMin(){if(super.updateAxisMaxMin(),!this.colorAxis)return;const t=this.colorAxis;t.include(this._minValue),t.include(this.maxValue)}getElementDefaultValues(){return dn}};l(Zs,"DefaultTrackerStringFormatter",function(o){return`${o.title}
${o.xTitle}: ${o.xValue}
${o.yTitle}: ${o.yValue}
${o.colorAxisTitle}: ${o.item.value}
Δ${o.xTitle}: ${o.itemDirection.x}
Δ${o.yTitle}: ${o.itemDirection.y}`}),l(Zs,"DefaultColorAxisTitle","Value");const bn=(o,t)=>{if(!o)throw new Error("Sequence must be defined.");if(!t)throw new Error("Projection must be defined.");let e,i,r=!0;for(const n of o){const a=t(n);(r||a<i)&&(e=n,i=a,r=!1)}if(r)throw new Error("Sequence must be non-empty.");return e};p.Black,_.Dash,_.Dot;({...ue,...pt});const Ot={contourLevelStep:NaN,labelStep:1,multiLabel:!1,labelSpacing:150,labelBackground:F.fromAColor(220,p.White),color:p.Automatic,strokeThickness:1,lineStyle:_.Solid,minimumSegmentLength:2,columnCoordinates:[],rowCoordinates:[],contourLevels:void 0,contourColors:void 0,data:void 0,labelStringFormatter:void 0},xn={..._t,...Ot},pn=class Ss extends nt{constructor(t){super(t),l(this,"_contours"),l(this,"_segments",[]),l(this,"_defaultColor",p.Undefined),l(this,"color",Ot.color),l(this,"columnCoordinates",[]),l(this,"contourLevelStep",Ot.contourLevelStep),l(this,"contourLevels"),l(this,"contourColors",[]),l(this,"data"),l(this,"labelBackground",Ot.labelBackground),l(this,"labelStringFormatter"),l(this,"trackerStringFormatter"),l(this,"labelSpacing",Ot.labelSpacing),l(this,"multiLabel",Ot.multiLabel),l(this,"labelStep",Ot.labelStep),l(this,"lineStyle",Ot.lineStyle),l(this,"rowCoordinates",[]),l(this,"strokeThickness",Ot.strokeThickness),l(this,"minimumSegmentLength",Ot.minimumSegmentLength),this.trackerStringFormatter=Ss.DefaultTrackerFormatString,q(this,Ot,t)}getElementName(){return"ContourSeries"}get actualColor(){return F.getActualColor(this.color,this._defaultColor)}calculateContours(){if(!this.data)return;let t=this.contourLevels;this._segments=[];const e=(i,r,n,a,h)=>{this._segments.push({startPoint:$(i,r),endPoint:$(n,a),contourLevel:h})};if(!t){let i=this.data[0][0],r=this.data[0][0];for(let a=0;a<this.data.length;a++)for(let h=0;h<this.data[a].length;h++)i=Math.max(i,this.data[a][h]),r=Math.min(r,this.data[a][h]);let n=this.contourLevelStep;if(j(n)){const a=(i-r)/20,h=Math.round(Math.log(Math.abs(a))/Math.LN10);n=Math.pow(10,Math.floor(h)),this.contourLevelStep=n}i=Math.round(n*Math.ceil(i/n)*1e14)/1e14,r=Math.round(n*Math.floor(r/n)*1e14)/1e14,t=_n.createVectorWithStep(r,i,n)}if(Ln.contour(this.data,this.columnCoordinates,this.rowCoordinates,t,e),this.joinContourSegments(),this.contourColors&&this.contourColors.length>0)for(const i of this._contours){let r=Ss.indexOf(t,i.contourLevel);r>=0&&(r=r%this.contourColors.length,i.color=this.contourColors[r])}}getNearestPoint(t,e){let i;const r="Z";for(const n of this._contours){const a=e?this.getNearestInterpolatedPointInternal(n.points,0,t):this.getNearestPointInternal(n.points,0,t);a&&(!i||Ye(i.position,t)>Ye(a.position,t))&&(i=a,i.text=this.formatDefaultTrackerString(n,a.dataPoint,h=>{const m=h;m.zTitle=r,m.contourLevel=n.contourLevel}))}return i}async render(t){if(this._contours||this.calculateContours(),this._contours.length===0)return;this.verifyAxes();const e=[],i=Vt.getDashArray(this.lineStyle);for(const r of this._contours){if(this.strokeThickness<=0||this.lineStyle===_.None)continue;const n=r.points.map(b=>this.transform(b)),a=F.getActualColor(r.color,this.actualColor);await O.drawReducedLine(t,n,this.minimumSegmentLength*this.minimumSegmentLength,this.getSelectableColor(a),this.strokeThickness,this.edgeRenderingMode,i,X.Miter);let h=0;for(let b=1;b<n.length;b++)h+=Jt(n[b],n[b-1]).length;if(n.length<=10||Math.round(r.contourLevel/this.contourLevelStep)%this.labelStep!==0)continue;if(!this.multiLabel){this.addContourLabels(r,n,e,(n.length-1)*.5);continue}const m=Math.floor(h/this.labelSpacing);if(m===0){this.addContourLabels(r,n,e,(n.length-1)*.5);continue}let u=0,c=0,g=1,f=0;const d=(h-(m-1)*this.labelSpacing)/2;for(let b=0;b<m;b++){let x=0;g===1?f=d:f=d+b*this.labelSpacing;for(let R=g;R<n.length;R++){if(u+=Jt(n[R],n[R-1]).length,u>f){x=R-1+(f-c)/(u-c),g=R+1;break}c=u}this.addContourLabels(r,n,e,x)}}for(const r of e)await this.renderLabelBackground(t,r);for(const r of e)await this.renderLabel(t,r)}setDefaultValues(){F.isAutomatic(this.color)&&(this.lineStyle=this.plotModel.getDefaultLineStyle(),this._defaultColor=this.plotModel.getDefaultColor())}updateMaxMin(){this.minX=Math.min(...this.columnCoordinates),this.maxX=Math.max(...this.columnCoordinates),this.minY=Math.min(...this.rowCoordinates),this.maxY=Math.max(...this.rowCoordinates)}static indexOf(t,e){let i=B,r=-1;for(let n=0;n<t.length;n++){const a=Math.abs(t[n]-e);a<i&&(i=a,r=n)}return r}addContourLabels(t,e,i,r){if(e.length<2)return;const n=Math.floor(r),a=n+1,h=e[a].x-e[n].x,m=e[a].y-e[n].y,u=e[n].x+h*(r-n),c=e[n].y+m*(r-n),g=y(u,c);let f=Math.atan2(m,h)*180/Math.PI;f>90&&(f-=180),f<-90&&(f+=180);const d=this.labelStringFormatter?this.labelStringFormatter(t.contourLevel,[]):t.contourLevel.toString();i.push({position:g,angle:f,text:d})}joinContourSegments(t=1e-10){this._contours=new Array;const e=r=>{const n=new Js(r.startPoint),a=new Js(r.endPoint);return n.partner=a,a.partner=n,[n,a]},i=Ur(this._segments,"contourLevel");for(const r of i){const n=r[0],a=r[1].flatMap(h=>e(h)).sort((h,m)=>h.point.x-m.point.x);for(let h=0;h<a.length-1;h++){const m=a[h];if(m.join)continue;const u=Math.sqrt(Math.pow(m.point.x,2)+Math.pow(m.point.y,2))*t,c=m.point.x+u;let g=h+1,f;for(;;){if(g>=a.length){f=void 0;break}if(f=a[g],g++,!f.join){if(f.point.x>c){f=void 0;break}if(Math.sqrt(Math.pow(f.point.x-m.point.x,2)+Math.pow(f.point.y-m.point.y,2))<u)break}}f&&(m.join=f,f.join=m)}for(const h of a){if(h.processed)continue;let m=h;for(;m.join&&(m=m.join.partner,m!==h););const u=new Array(m.point,m.partner.point);for(m.processed=!0,m=m.partner,m.processed=!0;m.join&&(m=m.join,!m.processed);)m.processed=!0,m=m.partner,m.processed=!0,u.push(m.point);const c=new Mn(u,n);this._contours.push(c)}}}async renderLabel(t,e){this.actualFontSize>0&&await t.drawText(e.position,e.text,this.actualTextColor,this.actualFont,this.actualFontSize,this.actualFontWeight,e.angle,N.Center,E.Middle)}async renderLabelBackground(t,e){if(F.isInvisible(this.labelBackground))return;const i=t.measureText(e.text,this.actualFont,this.actualFontSize,this.actualFontWeight),r=e.angle/180*Math.PI,n=Math.cos(r),a=Math.sin(r),h=n*.6,m=a*.6,u=-a*.5,c=n*.5,g=e.position.x,f=e.position.y,d=[y(g-i.width*h-i.height*u,f-i.width*m-i.height*c),y(g+i.width*h-i.height*u,f+i.width*m-i.height*c),y(g+i.width*h+i.height*u,f+i.width*m+i.height*c),y(g-i.width*h+i.height*u,f-i.width*m+i.height*c)];await t.drawPolygon(d,this.labelBackground,p.Undefined,0,this.edgeRenderingMode)}getElementDefaultValues(){return xn}};l(pn,"DefaultTrackerFormatString",function(o){return`${o.title}
${o.xTitle}: ${o.xValue}
${o.yTitle}: ${o.yValue}
${o.zTitle}: ${o.contourLevel}`});class Js{constructor(t){l(this,"partner"),l(this,"join"),l(this,"processed"),l(this,"point"),this.point=t,this.processed=!1}}class Mn{constructor(t,e){l(this,"contourLevel"),l(this,"points"),l(this,"color"),this.points=t,this.contourLevel=e,this.color=p.Automatic}}_.None;({...ue});const St={fill:p.Automatic,stroke:p.Black,boxWidth:.3,strokeThickness:1,medianThickness:2,meanThickness:2,outlierSize:2,outlierType:ct.Circle,medianPointSize:2,meanPointSize:2,whiskerWidth:.5,lineStyle:_.Solid,showMedianAsDot:!1,showMeanAsDot:!1,showBox:!0,outlierOutline:void 0,items:void 0},Rn={..._t,...St},qs=class ws extends nt{constructor(t){super(t),l(this,"_itemsSourceItems",[]),l(this,"trackerStringFormatter"),l(this,"boxWidth",St.boxWidth),l(this,"fill",St.fill),l(this,"items",[]),l(this,"lineStyle",St.lineStyle),l(this,"medianPointSize",St.medianPointSize),l(this,"medianThickness",St.medianThickness),l(this,"meanPointSize",St.meanPointSize),l(this,"meanThickness",St.meanThickness),l(this,"outlierSize",St.outlierSize),l(this,"outlierTrackerStringFormatter"),l(this,"outlierType",St.outlierType),l(this,"outlierOutline"),l(this,"showBox",St.showBox),l(this,"showMedianAsDot",St.showMedianAsDot),l(this,"showMeanAsDot",St.showMeanAsDot),l(this,"stroke",St.stroke),l(this,"strokeThickness",St.strokeThickness),l(this,"whiskerWidth",St.whiskerWidth),this.trackerStringFormatter=ws.DefaultTrackerFormatString,this.outlierTrackerStringFormatter=ws.DefaultOutlierTrackerFormatString,it(this,"trackerStringFormatter",t),it(this,"outlierTrackerStringFormatter",t),q(this,St,t,{exclude:["trackerStringFormatter","outlierTrackerStringFormatter"]})}getElementName(){return"BoxPlotSeries"}get actualItems(){return this.itemsSource?this._itemsSourceItems:this.items}getNearestPoint(t,e){if(!this.xAxis||!this.yAxis)return;let i=B,r;for(const n of this.actualItems){for(const f of n.outliers){const d=U.transform(this,n.x,f),b=Jt(d,t).lengthSquared;if(b<i){const x=this.outlierTrackerStringFormatter({item:n,title:this.title,xTitle:this.xAxis.title||nt.defaultXAxisTitle,xValue:this.xAxis.getValue(n.x),outlier:f});r=new yt({series:this,dataPoint:$(n.x,f),position:d,item:n,text:x}),i=b}}let a=vs;const h=this.getBoxRect(n);if(w.containsPoint(h,t)){const f=this.inverseTransform(t);a=$(n.x,f.y),i=0}const m=U.transform(this,n.x,n.upperWhisker),u=U.transform(this,n.x,n.lowerWhisker),c=ee.findPointOnLine(t,m,u),g=Jt(c,t).lengthSquared;if(g<i&&(a=this.inverseTransform(c),i=g),Or(a)){const f=this.trackerStringFormatter({item:n,title:this.title,xTitle:this.xAxis.title||nt.defaultXAxisTitle,xValue:this.xAxis.getValue(n.x),upperWhisker:this.yAxis.getValue(n.upperWhisker),boxTop:this.yAxis.getValue(n.boxTop),median:this.yAxis.getValue(n.median),boxBottom:this.yAxis.getValue(n.boxBottom),lowerWhisker:this.yAxis.getValue(n.lowerWhisker),mean:this.yAxis.getValue(n.mean!==void 0?n.mean:NaN)});r=new yt({series:this,dataPoint:a,position:this.transform(a),item:n,text:f})}}if(i<B)return r}isValidPointBoxPlot(t,e,i){const r=Qs(t);return!isNaN(t.x)&&!xe(t.x)&&!r.some(isNaN)&&!r.some(xe)&&e&&e.isValidValue(t.x)&&i&&r.every(n=>i.isValidValue(n))}async render(t){if(this.actualItems.length===0)return;const e=this.getClippingRect(),i=[],r=this.boxWidth*.5,n=r*this.whiskerWidth,a=this.getSelectableColor(this.stroke),h=this.getSelectableFillColor(this.fill),m=Vt.getDashArray(this.lineStyle),u=U.transform,c=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness);for(const g of this.actualItems){const f=g.mean!==void 0?g.mean:NaN;i.push(...g.outliers.map(M=>u(this,g.x,M)));const d=u(this,g.x,g.upperWhisker),b=u(this,g.x,g.boxTop),x=u(this,g.x,g.boxBottom),R=u(this,g.x,g.lowerWhisker);if(this.strokeThickness>0&&this.lineStyle!==_.None&&(await t.drawLine([d,b],a,this.strokeThickness,c,m,X.Miter),await t.drawLine([x,R],a,this.strokeThickness,c,m,X.Miter)),this.whiskerWidth>0){const M=u(this,g.x-n,g.upperWhisker),S=u(this,g.x+n,g.upperWhisker),T=u(this,g.x-n,g.lowerWhisker),A=u(this,g.x+n,g.lowerWhisker);await t.drawLine([M,S],a,this.strokeThickness,c,void 0,X.Miter),await t.drawLine([T,A],a,this.strokeThickness,c,void 0,X.Miter)}if(this.showBox){const M=this.getBoxRect(g);await t.drawRectangle(M,h,a,this.strokeThickness,c)}if(this.showMedianAsDot){const M=u(this,g.x,g.median);if(w.containsPoint(e,M)){const S=Y(M.x-this.medianPointSize,M.y-this.medianPointSize,this.medianPointSize*2,this.medianPointSize*2);await t.drawEllipse(S,h,p.Undefined,0,this.edgeRenderingMode)}}else{const M=u(this,g.x-r,g.median),S=u(this,g.x+r,g.median);await t.drawLine([M,S],a,this.strokeThickness*this.medianThickness,c,void 0,X.Miter)}if(!this.showMeanAsDot&&!isNaN(f)){const M=u(this,g.x-r,f),S=u(this,g.x+r,f);await t.drawLine([M,S],a,this.strokeThickness*this.meanThickness,c,Vt.getDashArray(_.Dash),X.Miter)}else if(!isNaN(f)){const M=u(this,g.x,f);if(w.containsPoint(e,M)){const S=Y(M.x-this.meanPointSize,M.y-this.meanPointSize,this.meanPointSize*2,this.meanPointSize*2);await t.drawEllipse(S,h,p.Undefined,0,this.edgeRenderingMode)}}}if(this.outlierType!==ct.None){const g=i.map(f=>this.outlierSize);await O.drawMarkers(t,i,this.outlierType,this.outlierOutline,g,h,a,this.strokeThickness,this.edgeRenderingMode)}}async renderLegend(t,e){const i=w.right(e),r=w.bottom(e),n=(e.left+i)/2,a=e.top+(r-e.top)*.7,h=e.top+(r-e.top)*.3,m=(a+h)*.5,u=e.width*.24,c=u*this.whiskerWidth,g=1,f=this.getSelectableColor(this.stroke),d=this.getSelectableFillColor(this.fill),b=Vt.getDashArray(_.Solid),x=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferGeometricAccuracy);if(await t.drawLine([y(n,e.top),y(n,h)],f,g,x,b,X.Miter),await t.drawLine([y(n,a),y(n,r)],f,g,x,b,X.Miter),this.whiskerWidth>0&&(await t.drawLine([y(n-c,r),y(n+c,r)],f,g,x,b,X.Miter),await t.drawLine([y(n-c,e.top),y(n+c,e.top)],f,g,x,b,X.Miter)),this.showBox&&await t.drawRectangle(Y(n-u,h,2*u,a-h),d,f,g,x),!this.showMedianAsDot)await t.drawLine([y(n-u,m),y(n+u,m)],f,g*this.medianThickness,x,b,X.Miter);else{const R=Y(n-this.medianPointSize,m-this.medianPointSize,this.medianPointSize*2,this.medianPointSize*2);await t.drawEllipse(R,d,p.Undefined,0,x)}}updateData(){this.itemsSource&&(this.clearItemsSourceItems(),this._itemsSourceItems.push(...this.itemsSource),this._itemsSourceItems.forEach(t=>{t.mean===void 0&&(t.median=NaN)}))}updateMaxMin(){super.updateMaxMin(),this.internalUpdateBoxPlotMaxMin(this.actualItems)}internalUpdateBoxPlotMaxMin(t){if(!t||t.length===0)return;let e=this.minX,i=this.minY,r=this.maxX,n=this.maxY;for(const a of t){if(!this.isValidPointBoxPlot(a,this.xAxis,this.yAxis))continue;const h=a.x;(h<e||isNaN(e))&&(e=h),(h>r||isNaN(r))&&(r=h);const m=Qs(a);for(const u of m)(u<i||isNaN(i))&&(i=u),(u>n||isNaN(n))&&(n=u)}this.minX=e,this.minY=i,this.maxX=r,this.maxY=n}getItem(t){return this.itemsSource||!this.actualItems||this.actualItems.length===0?super.getItem(t):this.actualItems[t]}getBoxRect(t){const e=this.boxWidth*.5,i=U.transform(this,t.x-e,t.boxTop),r=U.transform(this,t.x+e,t.boxBottom);return w.fromScreenPoints(i,r)}clearItemsSourceItems(){this._itemsSourceItems.length=0}getElementDefaultValues(){return Rn}};l(qs,"DefaultTrackerFormatString",function(o){return`${o.title||""}
${o.xTitle}: ${o.xValue}
Upper Whisker: ${o.upperWhisker.toFixed(2)}
Third Quartil: ${o.boxTop.toFixed(2)}
Median: ${o.median.toFixed(2)}
First Quartil: ${o.boxBottom.toFixed(2)}
Lower Whisker: ${o.lowerWhisker.toFixed(2)}
Mean: ${o.mean.toFixed(2)}`}),l(qs,"DefaultOutlierTrackerFormatString",function(o){return`${o.title||""}
${o.xTitle}: ${o.xValue}
Y: ${o.outlier.toFixed(2)}`});function Qs(o){const t=[o.lowerWhisker,o.boxBottom,o.median,o.boxTop,o.upperWhisker];return o.mean!==void 0&&!j(o.mean)&&t.push(o.mean),t.push(...o.outliers),t}({...ue});function yn(o){return F.getActualColor(o.fill,o.defaultFillColor)}const At={angleIncrement:1,angleSpan:360,areInsideLabelsAngled:!1,diameter:1,explodedDistance:0,innerDiameter:0,insideLabelColor:p.Automatic,insideLabelPosition:.5,startAngle:0,stroke:p.White,strokeThickness:1,tickDistance:0,tickHorizontalLength:8,tickLabelDistance:4,tickRadialLength:6,fontSize:12,colorField:void 0,insideLabelFormatter:void 0,isExplodedField:void 0,labelField:void 0,outsideLabelFormatter:void 0,slices:void 0,valueField:void 0},Sn={...Is,...At},es=class vi extends Oi{constructor(t){super(t),l(this,"_slicePoints",[]),l(this,"_total",0),l(this,"angleIncrement",At.angleIncrement),l(this,"angleSpan",At.angleSpan),l(this,"areInsideLabelsAngled",!1),l(this,"colorField"),l(this,"diameter",At.diameter),l(this,"explodedDistance",At.explodedDistance),l(this,"innerDiameter",At.innerDiameter),l(this,"insideLabelColor",At.insideLabelColor),l(this,"insideLabelFormatter"),l(this,"insideLabelPosition",At.insideLabelPosition),l(this,"isExplodedField"),l(this,"labelField"),l(this,"outsideLabelFormatter"),l(this,"slices",[]),l(this,"startAngle",At.startAngle),l(this,"stroke",At.stroke),l(this,"strokeThickness",At.strokeThickness),l(this,"tickDistance",At.tickDistance),l(this,"tickHorizontalLength",At.tickHorizontalLength),l(this,"tickLabelDistance",At.tickLabelDistance),l(this,"tickRadialLength",At.tickRadialLength),l(this,"valueField"),l(this,"trackerStringFormatter"),this.outsideLabelFormatter=vi.DefaultOutsideLabelFormatter,it(this,"outsideLabelFormatter",t),this.insideLabelFormatter=vi.DefaultInsideLabelFormatter,it(this,"insideLabelFormatter",t),this.trackerStringFormatter=vi.DefaultTrackerStringFormatter,it(this,"trackerStringFormatter",t),q(this,At,t,{exclude:["outsideLabelFormatter","insideLabelFormatter","trackerStringFormatter"]})}getElementName(){return"PieSeries"}getNearestPoint(t,e){const i=this.trackerStringFormatter;for(let r=0;r<this._slicePoints.length;r++)if(ee.isPointInPolygon(t,this._slicePoints[r])){const n=this.slices[r],a=this.getItem(r),h=i?i({item:a,title:this.title,xTitle:n.label,xValue:n.value,percent:n.value/this._total*100}):void 0;return new yt({series:this,position:t,item:a,index:r,text:h})}}async render(t){if(this._slicePoints=[],this.slices.length===0||(this._total=this.slices.reduce((u,c)=>u+c.value,0),Math.abs(this._total)<=0))return;const e=Math.min(this.plotModel.plotArea.width,this.plotModel.plotArea.height)/2,i=e*(this.diameter-this.explodedDistance),r=e*this.innerDiameter;let n=this.startAngle;const a=w.right(this.plotModel.plotArea),h=w.bottom(this.plotModel.plotArea),m=y((this.plotModel.plotArea.left+a)*.5,(this.plotModel.plotArea.top+h)*.5);for(const u of this.slices){const c=[],g=[],f=u.value/this._total*this.angleSpan,d=n+f,b=u.isExploded?this.explodedDistance*e:0,x=n+f/2,R=x*Math.PI/180,M=y(m.x+b*Math.cos(R),m.y+b*Math.sin(R));for(;;){let T=!1;n>=d&&(n=d,T=!0);const A=n*Math.PI/180,P=y(M.x+i*Math.cos(A),M.y+i*Math.sin(A));c.push(P);const C=y(M.x+r*Math.cos(A),M.y+r*Math.sin(A));if(r+b>0&&g.push(C),T)break;n+=this.angleIncrement}g.reverse(),g.length===0&&g.push(M),g.push(c[0]);const S=[...c,...g];if(await t.drawPolygon(S,yn(u),this.stroke,this.strokeThickness,this.edgeRenderingMode,void 0,X.Bevel),this._slicePoints.push(S),this.outsideLabelFormatter){const T=this.outsideLabelFormatter(u,u.value/this._total*100),A=Math.sign(Math.cos(R)),P=y(M.x+(i+this.tickDistance)*Math.cos(R),M.y+(i+this.tickDistance)*Math.sin(R)),C=y(P.x+this.tickRadialLength*Math.cos(R),P.y+this.tickRadialLength*Math.sin(R)),D=y(C.x+this.tickHorizontalLength*A,C.y);await t.drawLine([P,C,D],this.actualTextColor,1,this.edgeRenderingMode,void 0,X.Bevel);const k=y(D.x+this.tickLabelDistance*A,D.y);await t.drawText(k,T,this.actualTextColor,this.actualFont,this.actualFontSize,this.actualFontWeight,0,A>0?N.Left:N.Right,E.Middle)}if(this.insideLabelFormatter&&!F.isUndefined(this.insideLabelColor)){const T=this.insideLabelFormatter(u,u.value/this._total*100),A=r*(1-this.insideLabelPosition)+i*this.insideLabelPosition,P=y(M.x+A*Math.cos(R),M.y+A*Math.sin(R));let C=0;this.areInsideLabelsAngled&&(C=x,Math.cos(R)<0&&(C+=180));const D=F.isAutomatic(this.insideLabelColor)?this.actualTextColor:this.insideLabelColor;await t.drawText(P,T,D,this.actualFont,this.actualFontSize,this.actualFontWeight,C,N.Center,E.Middle)}}}async renderLegend(t,e){}areAxesRequired(){return!1}ensureAxes(){}isUsing(t){return!1}setDefaultValues(){for(const t of this.slices)t.fill=t.fill||p.Automatic,F.isAutomatic(t.fill)&&(t.defaultFillColor=this.plotModel.getDefaultColor())}updateAxisMaxMin(){}updateData(){if(this.itemsSource){this.slices=[];for(const t of this.itemsSource){const e=lt(t,this.labelField,""),i=lt(t,this.valueField,NaN),r=lt(t,this.colorField,p.Automatic),n=lt(t,this.isExplodedField,!1);this.slices.push({label:e,value:i,fill:r,isExploded:n})}}}updateMaxMin(){}getElementDefaultValues(){return Sn}};l(es,"DefaultTrackerStringFormatter",function(o){return`${o.xTitle}: ${Et(o.xValue,3)} (${ao((o.percent||0)/100)})`}),l(es,"DefaultOutsideLabelFormatter",function(o,t){return`${Et(t,0)} %`}),l(es,"DefaultInsideLabelFormatter",function(o,t){return o.label});const wn={constantY2:0,color2:p.Automatic,fill:p.Automatic,reverse2:!0,dataFieldX2:void 0,dataFieldY2:void 0},kn={...ue,...wn},Wt={x0:0,x1:0,y0:0,y1:0,interpolate:!0,coordinateDefinition:0,renderMethod:0,labelFontSize:0,data:void 0,colorAxis:void 0,colorAxisKey:void 0,labelStringFormatter:void 0},An={..._t,...Wt},tr=class ti extends nt{constructor(t){super(t),l(this,"_dataHash",0),l(this,"_colorAxisHash",0),l(this,"_image"),l(this,"x0",Wt.x0),l(this,"x1",Wt.x1),l(this,"y0",Wt.y0),l(this,"y1",Wt.y1),l(this,"data"),l(this,"interpolate",Wt.interpolate),l(this,"_minValue",0),l(this,"_maxValue",0),l(this,"_colorAxis"),l(this,"colorAxisKey"),l(this,"coordinateDefinition",Wt.coordinateDefinition),l(this,"renderMethod",Wt.renderMethod),l(this,"labelStringFormatter",e=>e.toFixed(2)),l(this,"labelFontSize",Wt.labelFontSize),this.trackerStringFormatter=ti.DefaultTrackerFormatString,it(this,"trackerStringFormatter",t),q(this,Wt,t,{exclude:["trackerStringFormatter"]})}getElementName(){return"HeatMapSeries"}get minValue(){return this._minValue}get maxValue(){return this._maxValue}get colorAxis(){return this._colorAxis}set colorAxis(t){this._colorAxis=t}invalidate(){this._image=void 0}async render(t){if(!this.data){this._image=void 0;return}if(!this.colorAxis)throw new Error("Color axis not specified.");let e=this.x0,i=this.x1,r=this.y0,n=this.y1;const a=this.data.length,h=this.data[0].length,m=(this.x1-this.x0)/(a-1),u=(this.y1-this.y0)/(h-1);if(this.coordinateDefinition===0){if(this.xAxis.isLogarithmic()){const M=Math.log(this.x1/this.x0)/(a-1);e*=Math.exp(M/-2),i*=Math.exp(M/2)}else e-=m/2,i+=m/2;if(this.yAxis.isLogarithmic()){const M=Math.log(this.y1/this.y0)/(h-1);r*=Math.exp(M/-2),n*=Math.exp(M/2)}else r-=u/2,n+=u/2}const c=U.transform(this,e,r),g=U.transform(this,i,n),f=w.fromScreenPoints(c,g),d=this.renderMethod===0,b=Tn(this.data),x=this.colorAxis.getElementHashCode();(d&&!this._image||b!==this._dataHash||x!==this._colorAxisHash)&&(d&&await this.updateImage(),this._dataHash=b,this._colorAxisHash=x);const R=U.orientate;if(d)this._image&&await O.drawImage(t,this._image,f.left,f.top,f.width,f.height,1,this.interpolate);else{const M=R(this,c),S=R(this,g),T=(S.x-M.x)/a,A=(S.y-M.y)/h,P=ze.getColor;for(let C=0;C<a;C++)for(let D=0;D<h;D++){const k=P(this.colorAxis,this.data[C][D]),L=R(this,y(M.x+C*T,M.y+D*A)),et=R(this,y(M.x+(C+1)*T,M.y+(D+1)*A)),ht=w.fromScreenPoints(L,et);await t.drawRectangle(ht,k,p.Undefined,0,this.edgeRenderingMode)}}this.labelFontSize>0&&await this.renderLabels(t,f)}getNearestPoint(t,e){if(!this.data)return;this.interpolate||(e=!1);let i=this.inverseTransform(t);if(!this.isPointInRange(i))return;let r,n;if(this.xAxis.isLogarithmic()){const c=Math.log(this.x1/this.x0)/(this.data.length-1);r=Math.log(i.x/this.x0)/c}else{const c=(this.x1-this.x0)/(this.data.length-1);r=(i.x-this.x0)/c}if(this.yAxis.isLogarithmic()){const c=Math.log(this.y1/this.y0)/(this.data[0].length-1);n=Math.log(i.y/this.y0)/c}else{const c=(this.y1-this.y0)/(this.data[0].length-1);n=(i.y-this.y0)/c}if(!e){r=Math.round(r),n=Math.round(n);let c,g;if(this.xAxis.isLogarithmic()){const f=Math.log(this.x1/this.x0)/(this.data.length-1);c=this.x0*Math.exp(r*f)}else{const f=(this.x1-this.x0)/(this.data.length-1);c=r*f+this.x0}if(this.yAxis.isLogarithmic()){const f=Math.log(this.y1/this.y0)/(this.data[0].length-1);g=this.y0*Math.exp(n*f)}else{const f=(this.y1-this.y0)/(this.data[0].length-1);g=n*f+this.y0}i=$(c,g),t=this.transform(i)}if(r<-.5||r>this.data.length-.5||n<-.5||n>this.data[0].length-.5)return;const a=ti.getValue(this.data,r,n),h=this.colorAxis,m=(h==null?void 0:h.title)??ti.DefaultColorAxisTitle,u=this.formatDefaultTrackerString(void 0,i,c=>{c.colorAxisTitle=m,c.value=a});return new yt({series:this,dataPoint:i,position:t,item:null,index:-1,text:u})}ensureAxes(){super.ensureAxes(),this.colorAxis=this.colorAxisKey?this.plotModel.getAxis(this.colorAxisKey):this.plotModel.defaultColorAxis}updateMaxMinXY(){if(!this.data)return;const t=this.data.length,e=this.data[0].length;if(this.minX=Math.min(this.x0,this.x1),this.maxX=Math.max(this.x0,this.x1),this.minY=Math.min(this.y0,this.y1),this.maxY=Math.max(this.y0,this.y1),this.coordinateDefinition===0){if(this.xAxis.isLogarithmic()){const i=Math.log(this.maxX/this.minX)/(t-1);this.minX*=Math.exp(i/-2),this.maxX*=Math.exp(i/2)}else{const i=(this.maxX-this.minX)/(t-1);this.minX-=i/2,this.maxX+=i/2}if(this.yAxis.isLogarithmic()){const i=Math.log(this.maxY/this.minY)/(e-1);this.minY*=Math.exp(i/-2),this.maxY*=Math.exp(i/2)}else{const i=(this.maxY-this.minY)/(e-1);this.minY-=i/2,this.maxY+=i/2}}}updateMaxMin(){if(super.updateMaxMin(),this.updateMaxMinXY(),!this.data)return;const t=this.data.flat().filter(e=>!isNaN(e));this._minValue=mt(t),this._maxValue=Mt(t)}updateAxisMaxMin(){super.updateAxisMaxMin();const t=this.colorAxis;t&&(t.include(this.minValue),t.include(this.maxValue))}async renderLabels(t,e){if(!this.data)return;const i=this.data.length,r=this.data[0].length,n=e.height/r*this.labelFontSize,a=this.x0,h=this.x1,m=this.y0,u=this.y1,c=U.orientate,g=U.transform,f=c(this,g(this,a,m)),d=c(this,g(this,h,u)),b=(d.x-f.x)/(i-1),x=(d.y-f.y)/(r-1),R=ze.getColor;for(let M=0;M<i;M++)for(let S=0;S<r;S++){const T=c(this,y(f.x+M*b,f.y+S*x)),A=ti.getValue(this.data,M,S),P=R(this.colorAxis,A),C=F.toHsv(P)[2]>.6?p.Black:p.White,D=this.getLabel(A,M,S);await t.drawText(T,D,C,this.actualFont,n,500,0,N.Center,E.Middle)}}getLabel(t,e,i){return this.labelStringFormatter(t,[])}static getValue(t,e,i){e=Math.max(e,0),i=Math.max(i,0);const r=Math.floor(e),n=r+1<t.length?r+1:r,a=Math.floor(i),h=a+1<t[0].length?a+1:a;if(e=Math.min(e,n),i=Math.min(i,h),e===r&&i===a)return t[r][a];if(e!==r&&i===a){if(isNaN(t[r][a])||isNaN(t[n][a]))return NaN;const m=e-r;return r!==n?t[r][a]*(1-m)+t[n][a]*m:t[r][a]}if(e===r&&i!==a){if(isNaN(t[r][a])||isNaN(t[r][h]))return NaN;const m=i-a;return a!==h?t[r][a]*(1-m)+t[r][h]*m:t[r][a]}else{if(isNaN(t[r][a])||isNaN(t[n][a])||isNaN(t[r][h])||isNaN(t[n][h]))return NaN;const m=e-r,u=i-a;let c,g;return r!==n?(c=t[r][a]*(1-m)+t[n][a]*m,g=t[r][h]*(1-m)+t[n][h]*m):(c=t[r][a],g=t[r][h]),a!==h?c*(1-u)+g*u:c}}isPointInRange(t){return this.updateMaxMinXY(),t.x>=this.minX&&t.x<=this.maxX&&t.y>=this.minY&&t.y<=this.maxY}async updateImage(){if(!this.data)return;const t=this.xAxis.transform(this.x0)>this.xAxis.transform(this.x1),e=this.yAxis.transform(this.y0)>this.yAxis.transform(this.y1),i=U.isTransposed(this),r=this.data.length,n=this.data[0].length,a=i?new Pi(n,r):new Pi(r,n),h=ze.getColor;for(let m=0;m<r;m++){const u=t?r-1-m:m;for(let c=0;c<n;c++){const g=e?n-1-c:c,f=h(this.colorAxis,this.data[u][g]);i?a.set(c,m,f):a.set(m,c,f)}}this._image=await Ei.create(a,Ne.Png)}getElementDefaultValues(){return An}};l(tr,"DefaultTrackerFormatString",function(o){return`${o.title}
${o.xTitle}: ${o.xValue}
${o.yTitle}: ${o.yValue}
${o.colorAxisTitle}: ${o.value}`}),l(tr,"DefaultColorAxisTitle","Value");function Tn(o){return hr(o.flat())}function vn(o,t){const{a:e,b:i}=o;return t.x<=i.x&&t.x>=e.x&&t.y<=i.y&&t.y>=e.y||t.x<=e.x&&t.x>=i.x&&t.y<=e.y&&t.y>=i.y}function Cn(o){return"a"in o&&"b"in o&&"value"in o}const ks={labelFontSize:0,items:void 0,mapping:void 0,colorAxisKey:void 0,labelStringFormatter:void 0,colorAxisTitle:void 0,colorAxis:void 0},Pn={..._t,...ks},er=class As extends nt{constructor(t){super(t),l(this,"_actualItems",[]),l(this,"_minValue",0),l(this,"_maxValue",0),l(this,"_colorAxis"),l(this,"colorAxisKey"),l(this,"labelStringFormatter",e=>e.toFixed(2)),l(this,"labelFontSize",ks.labelFontSize),l(this,"mapping"),l(this,"items",[]),this.trackerStringFormatter=As.DefaultTrackerFormatString,it(this,"trackerStringFormatter",t),q(this,ks,t,{exclude:["trackerStringFormatter"]})}getElementName(){return"RectangleSeries"}get minValue(){return this._minValue}get maxValue(){return this._maxValue}get colorAxis(){return this._colorAxis}set colorAxis(t){this._colorAxis=t}get actualItems(){return this.itemsSource?this._actualItems:this.items}async render(t){this.verifyAxes(),await this.renderRectangles(t,this.actualItems)}updateData(){this.itemsSource&&this.updateActualItems()}getItem(t){const e=this.actualItems;return!this.itemsSource&&e&&t<e.length?e[t]:super.getItem(t)}clearActualItems(){this._actualItems.length=0}updateActualItems(){if(this.clearActualItems(),!(!this.itemsSource||this.itemsSource.length==0)){for(const t of this.itemsSource)if(t){if(Cn(t)){this._actualItems.push(t);continue}if(this.mapping){this._actualItems.push(this.mapping(t));continue}throw new Error("Invalid itemsSource")}}}async renderRectangles(t,e){const i=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness),r=U.transform;for(const n of e){const a=ze.getColor(this.colorAxis,n.value),h=r(this,n.a.x,n.a.y),m=r(this,n.b.x,n.b.y),u=w.fromScreenPoints(h,m);await t.drawRectangle(u,a,p.Undefined,0,i),this.labelFontSize>0&&await t.drawText(w.center(u),this.labelStringFormatter(n.value,[]),this.actualTextColor,this.actualFont,this.labelFontSize,this.actualFontWeight,0,N.Center,E.Middle)}}getNearestPoint(t,e){const i=this.inverseTransform(t);if(!this.isPointInRange(i)||!this.actualItems)return;const r=this.colorAxis,n=(r==null?void 0:r.title)??As.DefaultColorAxisTitle;for(const a of this.actualItems)if(vn(a,i)){const h=this.formatDefaultTrackerString(a,i,m=>{m.colorAxisTitle=n,m.value=a.value});return new yt({series:this,dataPoint:i,position:t,item:null,index:-1,text:h})}}ensureAxes(){super.ensureAxes(),this.colorAxis=this.colorAxisKey?this.plotModel.getAxis(this.colorAxisKey):this.plotModel.defaultColorAxis}updateMaxMinXY(){if(this.actualItems&&this.actualItems.length>0){const t=mt(this.actualItems.map(u=>u.a.x)),e=mt(this.actualItems.map(u=>u.b.x)),i=Mt(this.actualItems.map(u=>u.a.x)),r=Mt(this.actualItems.map(u=>u.b.x)),n=mt(this.actualItems.map(u=>u.a.y)),a=mt(this.actualItems.map(u=>u.b.y)),h=Mt(this.actualItems.map(u=>u.a.y)),m=Mt(this.actualItems.map(u=>u.b.y));this.minX=Math.min(t,e),this.maxX=Math.max(i,r),this.minY=Math.min(n,a),this.maxY=Math.max(h,m)}}updateMaxMin(){super.updateMaxMin();const t=[];if(Xe(t,this.actualItems.map(e=>e.a)),Xe(t,this.actualItems.map(e=>e.b)),this.internalUpdateMaxMin(t),this.updateMaxMinXY(),this.actualItems&&this.actualItems.length>0){const e=this.actualItems.map(i=>i.value);this._minValue=mt(e),this._maxValue=Mt(e)}}updateAxisMaxMin(){super.updateAxisMaxMin();const t=this.colorAxis;t&&(t.include(this.minValue),t.include(this.maxValue))}isPointInRange(t){return this.updateMaxMinXY(),t.x>=this.minX&&t.x<=this.maxX&&t.y>=this.minY&&t.y<=this.maxY}getElementDefaultValues(){return Pn}};l(er,"DefaultTrackerFormatString",function(o){return`${o.title}
${o.xTitle}: ${o.xValue}
${o.yTitle}: ${o.yValue}
${o.colorAxisTitle}: ${o.value}`}),l(er,"DefaultColorAxisTitle","Value");F.fromRgb(0,0,255),F.fromRgb(255,0,0),_.Solid,_.Solid;({...ue});F.fromRgb(0,0,255),p.Automatic,_.Solid,p.Automatic,p.Automatic,p.Automatic;({...kn});F.fromRgb(0,0,255);({...ue});const ei={stroke:p.Undefined,strokeThickness:2,labelFontSize:0,items:void 0,mapping:void 0,colorAxisKey:void 0,labelStringFormatter:void 0},Fn={..._t,...ei},ir=class Ts extends nt{constructor(t){super(t),l(this,"_actualItems",[]),l(this,"_minValue",0),l(this,"_maxValue",0),l(this,"_colorAxis"),l(this,"colorAxisKey"),l(this,"labelStringFormatter",(e,i)=>e.value.toFixed(2)),l(this,"labelFontSize",ei.labelFontSize),l(this,"mapping"),l(this,"items",[]),l(this,"stroke",ei.stroke),l(this,"strokeThickness",ei.strokeThickness),this.trackerStringFormatter=Ts.defaultTrackerStringFormatter,it(this,"trackerStringFormatter",t),it(this,"labelStringFormatter",t),q(this,ei,t,{exclude:["trackerStringFormatter","labelStringFormatter"]})}get actualItems(){return this.itemsSource?this._actualItems:this.items}get minValue(){return this._minValue}get maxValue(){return this._maxValue}get colorAxis(){return this._colorAxis}getElementName(){return"PolygonSeries"}async render(t){this.verifyAxes(),await this.renderPolygons(t,this.actualItems)}updateData(){this.itemsSource&&this.updateActualItems()}getItem(t){const e=this.actualItems;return!this.itemsSource&&e&&t<e.length?e[t]:super.getItem(t)}clearActualItems(){this._actualItems&&(this._actualItems.length=0),this._actualItems=[]}updateActualItems(){this.clearActualItems();for(const t of this.itemsSource||[]){if(Dn(t)){this._actualItems.push(t);continue}if(this.mapping){this._actualItems.push(this.mapping(t));continue}throw new Error("Invalid item")}}async renderPolygons(t,e){const i=[];for(const r of e){const n=ze.getColor(this.colorAxis,r.value),a=O.getActualEdgeRenderingMode(this.edgeRenderingMode,tt.PreferSharpness);for(const h of r.outlines)if(i.length=0,i.push(...h.map(m=>this.transform(m))),await t.drawPolygon(i,n,this.stroke,this.strokeThickness,a),this.labelFontSize>0){const m=this.labelStringFormatter(r,[]);await t.drawText(ee.getCentroid(i),m,this.actualTextColor,this.actualFont,this.labelFontSize,this.actualFontWeight,0,N.Center,E.Middle)}}}getNearestPoint(t,e){const i=this.inverseTransform(t);if(!this.isPointInRange(i))return;const r=this.colorAxis,n=(r==null?void 0:r.title)??Ts._defaultColorAxisTitle,a=[],h=this.actualItems;if(h)for(const m of h)for(let u=0;u<m.outlines.length;u++){const c=m.bounds[u];if(w.contains(c,i.x,i.y)&&(a.length=0,a.push(...m.outlines[u].map(g=>this.transform(g))),ee.isPointInPolygon(t,a))){const g=super.formatDefaultTrackerString(m,i,f=>{f.colorAxisTitle=n});return new yt({series:this,dataPoint:i,position:t,item:m,index:-1,text:g})}}}ensureAxes(){super.ensureAxes(),this._colorAxis=this.colorAxisKey?this.plotModel.getAxis(this.colorAxisKey):this.plotModel.defaultColorAxis}updateMaxMin(){super.updateMaxMin(),this.updateMaxMinXY();const t=this.actualItems;t&&t.length>0&&(this._minValue=mt(t.map(e=>e.value)),this._maxValue=Mt(t.map(e=>e.value)))}updateAxisMaxMin(){super.updateAxisMaxMin();const t=this.colorAxis;t&&(t.include(this.minValue),t.include(this.maxValue))}updateMaxMinXY(){const t=this.actualItems;if(t&&t.length>0){const e=t.flatMap(i=>i.bounds);this.minX=mt(e.map(i=>i.left)),this.maxX=Mt(e.map(i=>w.right(i))),this.minY=mt(e.map(i=>i.top)),this.maxY=Mt(e.map(i=>w.bottom(i)))}}isPointInRange(t){return this.updateMaxMinXY(),t.x>=this.minX&&t.x<=this.maxX&&t.y>=this.minY&&t.y<=this.maxY}getElementDefaultValues(){return Fn}};l(ir,"defaultTrackerStringFormatter",function(o){return`${o.title}
${o.xTitle}: ${o.xValue}
${o.yTitle}: ${o.yValue}
${o.colorAxisTitle}: ${o.item.value}`}),l(ir,"_defaultColorAxisTitle","Value");function Dn(o){return o&&o.outlines&&o.value&&o.bounds}class In{static convertToFractionString(t,e=1,i,r=1e-6,n){if(Math.abs(t)<r)return"0";t/=e;for(let a=1;a<=64;a++){const h=t*a,m=Math.round(h);if(Math.abs(h-m)<r){const u=!i||m!=1?m.toString():"";return a==1?`${u}${i}`:`${u}${i}/${a}`}}return n?n(t)+(i||""):`${t.toString()}${i||""}`}}class Vn{static splitLines(t){return t.split(/\r?\n/)}}class ve{static isReversible(t){if(t.axes.length===0&&t.series.length===0)return!1;for(const e of t.axes){if(e.position===v.None)return!1;const i=e.__isReversible;if(i!==void 0&&!i)return!1}for(const e of t.series){const i=e.getElementName();if(!(e instanceof nt)||this.NonReversibleSeriesTypes.has(i))return!1}for(const e of t.annotations){const i=e.getElementName();if(this.NonReversibleDataSpaceAnnotationTypes.has(i))return!1}return!0}static isTransposable(t){if(t.axes.length===0&&t.series.length===0)return!1;for(const e of t.axes)if(e.position===v.None)return!1;for(const e of t.series){const i=e.getElementName();if(!js(e)||this.NonTransposableSeriesTypes.has(i))return!1}for(const e of t.annotations){const i=e.getElementName();if(!js(e)||this.NonTransposableDataSpaceAnnotationTypes.has(i))return!1}return!0}static reverseXAxis(t){t.title&&(t.title+=" (reversed X Axis)");let e=!1;for(const i of t.axes)i.position===v.Bottom&&(i.startPosition=1-i.startPosition,i.endPosition=1-i.endPosition,e=!0);return e||t.axes.push(new le({position:v.Bottom,startPosition:1,endPosition:0})),t}static reverseYAxis(t){t.title&&(t.title+=" (reversed Y Axis)");let e=!1;for(const i of t.axes)i.position===v.Left&&(i.startPosition=1-i.startPosition,i.endPosition=1-i.endPosition,e=!0);return e||t.axes.push(new le({position:v.Left,startPosition:1,endPosition:0})),t}static reverseAllAxes(t){t.title&&(t.title+=" (reversed all Axes)"),t.update(!1);for(const e of t.axes)(e.position===v.Left||e.position===v.Bottom||e.position===v.Right||e.position===v.Top)&&(e.startPosition=1-e.startPosition,e.endPosition=1-e.endPosition);return t}static transpose(t){t.title&&(t.title+=" (transposed)"),t.update(!1);for(const e of t.axes)switch(e.position){case v.Bottom:e.position=v.Left;break;case v.Left:e.position=v.Bottom;break;case v.Right:e.position=v.Top;break;case v.Top:e.position=v.Right;break;case v.None:break;default:throw new Error("Invalid axis position")}for(const e of t.annotations)e.xAxis&&!e.xAxisKey&&(e.xAxis.key||(e.xAxis.key=this.XAXIS_KEY),e.xAxisKey=e.xAxis.key),e.yAxis&&!e.yAxisKey&&(e.yAxis.key||(e.yAxis.key=this.YAXIS_KEY),e.yAxisKey=e.yAxis.key);for(const e of t.series)e instanceof nt&&(e.xAxisKey||(e.xAxis?(e.xAxis.key||(e.xAxis.key=this.XAXIS_KEY),e.xAxisKey=e.xAxis.key):e.xAxisKey=this.XAXIS_KEY),e.yAxisKey||(e.yAxis?(e.yAxis.key||(e.yAxis.key=this.YAXIS_KEY),e.yAxisKey=e.yAxis.key):e.yAxisKey=this.YAXIS_KEY));return t}}l(ve,"XAXIS_KEY","x"),l(ve,"YAXIS_KEY","y"),l(ve,"NonReversibleSeriesTypes",new Set),l(ve,"NonReversibleDataSpaceAnnotationTypes",new Set([])),l(ve,"NonTransposableSeriesTypes",new Set(["CandleStickAndVolumeSeries","OldCandleStickSeries"])),l(ve,"NonTransposableDataSpaceAnnotationTypes",new Set);class _n{static createVector(t,e,i){if(i.toFixed(0)!==i.toString())throw new Error("use createVectorWithStep instead");const r=[];for(let n=0;n<i;n++)r[n]=Number((t+(e-t)*n/(i-1)).toFixed(8));return r}static createVectorWithStep(t,e,i){const r=Math.round((e-t)/i),n=[];for(let a=0;a<=r;a++)n[a]=Number((t+a*i).toFixed(8));return n}static evaluate(t,e,i){const r=e.length,n=i.length,a=[];for(let h=0;h<r;h++){a[h]=[];for(let m=0;m<n;m++)a[h][m]=t(e[h],i[m])}return a}static fill(t,e){for(let i=0;i<t.length;i++)t[i]=e}static fill2D(t,e){for(let i=0;i<t.length;i++)for(let r=0;r<t[i].length;r++)t[i][r]=e}}class Br{static getNearestHit(t,e,i,r,n,a){if(t){if(i||r){const h=t.getNearestPoint(e,!1);if(this.shouldTrackerOpen(h,e,n))return h}if(!r){const h=t.getNearestPoint(e,!0);if(!a||this.shouldTrackerOpen(h,e,n))return h}}}static shouldTrackerOpen(t,e,i){return t!=null&&t.position?Cs(t.position,e)<i:!1}}class Ln{static contour(t,e,i,r,n){let a=0,h=0,m=0,u=0;const c=new Array(5),g=new Array(5),f=new Array(5),d=new Array(5),b=0,x=t.length-1,R=0,M=t[0].length-1,S=r.length,T=[0,1,1,0],A=[0,0,1,1],P=[[[0,0,8],[0,2,5],[7,6,9]],[[0,3,4],[1,3,1],[4,3,0]],[[9,6,7],[5,2,0],[8,0,0]]],C=(k,L)=>(c[L]*f[k]-c[k]*f[L])/(c[L]-c[k]),D=(k,L)=>(c[L]*d[k]-c[k]*d[L])/(c[L]-c[k]);for(let k=M-1;k>=R;k--)for(let L=b;L<=x-1;L++){const et=Math.min(t[L][k],t[L][k+1]),ht=Math.min(t[L+1][k],t[L+1][k+1]),gt=Math.min(et,ht),Rt=Math.max(t[L][k],t[L][k+1]),Tt=Math.max(t[L+1][k],t[L+1][k+1]),ft=Math.max(Rt,Tt);if(ft>=r[0]&&gt<=r[S-1]){for(let dt=0;dt<S;dt++)if(r[dt]>=gt&&r[dt]<=ft){for(let H=4;H>=0;H--)H>0?(c[H]=t[L+T[H-1]][k+A[H-1]]-r[dt],f[H]=e[L+T[H-1]],d[H]=i[k+A[H-1]]):(c[0]=.25*(c[1]+c[2]+c[3]+c[4]),f[0]=.5*(e[L]+e[L+1]),d[0]=.5*(i[k]+i[k+1])),c[H]>0?g[H]=1:c[H]<0?g[H]=-1:g[H]=0;for(let H=1;H<=4;H++){const G=H,st=0,bt=H!==4?H+1:1,Ls=P[g[G]+1][g[st]+1][g[bt]+1];if(Ls!==0){switch(Ls){case 1:a=f[G],m=d[G],h=f[st],u=d[st];break;case 2:a=f[st],m=d[st],h=f[bt],u=d[bt];break;case 3:a=f[bt],m=d[bt],h=f[G],u=d[G];break;case 4:a=f[G],m=d[G],h=C(st,bt),u=D(st,bt);break;case 5:a=f[st],m=d[st],h=C(bt,G),u=D(bt,G);break;case 6:a=f[bt],m=d[bt],h=C(G,st),u=D(G,st);break;case 7:a=C(G,st),m=D(G,st),h=C(st,bt),u=D(st,bt);break;case 8:a=C(st,bt),m=D(st,bt),h=C(bt,G),u=D(bt,G);break;case 9:a=C(bt,G),m=D(bt,G),h=C(G,st),u=D(G,st);break}n(a,m,h,u,r[dt])}}}}}}}export{w as A,v as F,Et as H,_ as I,be as J,Z as K,p as M,Bn as Q,y as S,Wi as U,$ as V,Y as W,te as Y,N as _,Vn as a,Ei as b,s as c,En as d,Ct as e,zn as f,$n as g,ve as h,J as i,Le as j,le as k,Yt as l,Yn as m,_e as o,$e as p,X as q,It as r,tt as s,at as t,F as v,os as x,E as z};
